import React, { PureComponent, Component } from 'react';
import { DefaultDraftInlineStyle, Modifier, SelectionState, EditorState, AtomicBlockUtils, RichUtils, KeyBindingUtil, DefaultDraftBlockRenderMap, getDefaultKeyBinding } from 'draft-js';
import Editor from 'draft-js-plugins-editor';
import { blockDepthStyleFn, createEditorStateFromRaw, registerCopySource, serialiseEditorStateToRaw, handleDraftEditorPastedText, ListNestingStyles } from 'draftjs-conductor';
export { createEditorStateFromRaw, serialiseEditorStateToRaw } from 'draftjs-conductor';
import decorateComponentWithProps from 'decorate-component-with-props';
import isSoftNewlineEvent from 'draft-js/lib/isSoftNewlineEvent';
import { filterEditorState } from 'draftjs-filters';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var BLOCK_TYPE = {
  // This is used to represent a normal text block (paragraph).
  UNSTYLED: "unstyled",
  HEADER_ONE: "header-one",
  HEADER_TWO: "header-two",
  HEADER_THREE: "header-three",
  HEADER_FOUR: "header-four",
  HEADER_FIVE: "header-five",
  HEADER_SIX: "header-six",
  UNORDERED_LIST_ITEM: "unordered-list-item",
  ORDERED_LIST_ITEM: "ordered-list-item",
  BLOCKQUOTE: "blockquote",
  CODE: "code-block",
  // This represents a "custom" block, not for rich text, with arbitrary content.
  ATOMIC: "atomic"
};
var ENTITY_TYPE = {
  LINK: "LINK",
  IMAGE: "IMAGE",
  HORIZONTAL_RULE: "HORIZONTAL_RULE"
}; // See https://github.com/facebook/draft-js/blob/master/src/model/immutable/DefaultDraftInlineStyle.js

var INLINE_STYLE = {
  BOLD: "BOLD",
  ITALIC: "ITALIC",
  CODE: "CODE",
  UNDERLINE: "UNDERLINE",
  STRIKETHROUGH: "STRIKETHROUGH",
  MARK: "MARK",
  QUOTATION: "QUOTATION",
  SMALL: "SMALL",
  SAMPLE: "SAMPLE",
  INSERT: "INSERT",
  DELETE: "DELETE",
  KEYBOARD: "KEYBOARD",
  SUPERSCRIPT: "SUPERSCRIPT",
  SUBSCRIPT: "SUBSCRIPT"
};
var BLOCK_TYPES = Object.values(BLOCK_TYPE);
var ENTITY_TYPES = Object.values(ENTITY_TYPE);
var INLINE_STYLES = Object.values(INLINE_STYLE);
var KEY_COMMANDS = [].concat(_toConsumableArray(BLOCK_TYPES), _toConsumableArray(ENTITY_TYPES), _toConsumableArray(INLINE_STYLES), [// Lowercase identifiers used by Draft.js
// See https://github.com/facebook/draft-js/blob/585af35c3a8c31fefb64bc884d4001faa96544d3/src/model/constants/DraftEditorCommand.js#L58-L61.
"bold", "italic", "underline", "code"]);
var FONT_FAMILY_MONOSPACE = "Consolas, Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, sans-serif"; // See https://github.com/facebook/draft-js/blob/master/src/model/immutable/DefaultDraftInlineStyle.js

var CUSTOM_STYLE_MAP = {};
CUSTOM_STYLE_MAP[INLINE_STYLE.BOLD] = DefaultDraftInlineStyle[INLINE_STYLE.BOLD];
CUSTOM_STYLE_MAP[INLINE_STYLE.ITALIC] = DefaultDraftInlineStyle[INLINE_STYLE.ITALIC];
CUSTOM_STYLE_MAP[INLINE_STYLE.STRIKETHROUGH] = DefaultDraftInlineStyle[INLINE_STYLE.STRIKETHROUGH];
CUSTOM_STYLE_MAP[INLINE_STYLE.UNDERLINE] = DefaultDraftInlineStyle[INLINE_STYLE.UNDERLINE];
CUSTOM_STYLE_MAP[INLINE_STYLE.CODE] = {
  padding: "0.2em 0.3125em",
  margin: "0",
  fontSize: "85%",
  backgroundColor: "rgba(27, 31, 35, 0.05)",
  fontFamily: FONT_FAMILY_MONOSPACE,
  borderRadius: "3px"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.MARK] = {
  backgroundColor: "yellow"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.QUOTATION] = {
  fontStyle: "italic"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SMALL] = {
  fontSize: "smaller"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SAMPLE] = {
  fontFamily: FONT_FAMILY_MONOSPACE
};
CUSTOM_STYLE_MAP[INLINE_STYLE.INSERT] = {
  textDecoration: "underline"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.DELETE] = {
  textDecoration: "line-through"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.KEYBOARD] = {
  fontFamily: FONT_FAMILY_MONOSPACE,
  padding: "3px 5px",
  fontSize: "11px",
  lineHeight: "10px",
  color: "#444d56",
  verticalAlign: "middle",
  backgroundColor: "#fafbfc",
  border: "solid 1px #c6cbd1",
  borderBottomColor: "#959da5",
  borderRadius: "3px",
  boxShadow: "inset 0 -1px 0 #959da5"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SUPERSCRIPT] = {
  fontSize: "80%",
  verticalAlign: "super",
  lineHeight: "1"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SUBSCRIPT] = {
  fontSize: "80%",
  verticalAlign: "sub",
  lineHeight: "1"
};
var BR_TYPE = "BR";
var UNDO_TYPE = "undo";
var REDO_TYPE = "redo"; // Originally from https://github.com/facebook/draft-js/blob/master/src/component/utils/getDefaultKeyBinding.js.

var KEY_CODES = {
  K: 75,
  B: 66,
  U: 85,
  J: 74,
  I: 73,
  X: 88,
  "0": 48,
  "1": 49,
  "2": 50,
  "3": 51,
  "4": 52,
  "5": 53,
  "6": 54,
  "7": 55,
  "8": 56,
  ".": 190,
  ",": 188
};
var INPUT_BLOCK_MAP = {
  "* ": BLOCK_TYPE.UNORDERED_LIST_ITEM,
  "- ": BLOCK_TYPE.UNORDERED_LIST_ITEM,
  "1. ": BLOCK_TYPE.ORDERED_LIST_ITEM,
  "# ": BLOCK_TYPE.HEADER_ONE,
  "## ": BLOCK_TYPE.HEADER_TWO,
  "### ": BLOCK_TYPE.HEADER_THREE,
  "#### ": BLOCK_TYPE.HEADER_FOUR,
  "##### ": BLOCK_TYPE.HEADER_FIVE,
  "###### ": BLOCK_TYPE.HEADER_SIX,
  "> ": BLOCK_TYPE.BLOCKQUOTE,
  // It makes more sense not to require a space here.
  // This matches how Dropbox Paper operates.
  "```": BLOCK_TYPE.CODE
};
var INPUT_STYLE_MAP = [// Order matters, as shorter patterns are contained in the longer ones.
{
  pattern: "**",
  type: INLINE_STYLE.BOLD
}, {
  pattern: "__",
  type: INLINE_STYLE.BOLD
}, {
  pattern: "*",
  type: INLINE_STYLE.ITALIC
}, {
  pattern: "_",
  type: INLINE_STYLE.ITALIC
}, {
  pattern: "~~",
  type: INLINE_STYLE.STRIKETHROUGH
}, {
  pattern: "~",
  type: INLINE_STYLE.STRIKETHROUGH
}, {
  pattern: "`",
  type: INLINE_STYLE.CODE
}].map(function (_ref) {
  var pattern = _ref.pattern,
      type = _ref.type;
  var pat = pattern.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  var char = pattern[0].replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // https://regexper.com/#%28%5Cs%7C%5E%29__%28%5B%5E%5Cs_%5D%7B1%2C2%7D%7C%5B%5E%5Cs_%5D.%2B%5B%5E%5Cs_%5D%29__%24
  // This is stored as an escaped string instead of a RegExp object because they are stateful.
  // This regex encapsulates a few rules:
  // - The pattern must be preceded by whitespace, or be at the start of the input.
  // - The pattern must end the input.
  // - In-between the start and end patterns, there can't be only whitespace or characters from the pattern.
  // - There has to be at least 1 char that's not whitespace or the pattern’s char.

  var regex = "(\\s|^)".concat(pat, "([^\\s").concat(char, "]{1,2}|[^\\s").concat(char, "].+[^\\s").concat(char, "])").concat(pat, "$");
  return {
    pattern: pattern,
    type: type,
    regex: regex
  };
});
var INPUT_ENTITY_MAP = {};
INPUT_ENTITY_MAP[ENTITY_TYPE.HORIZONTAL_RULE] = "---";
var LABELS = {};
LABELS[BLOCK_TYPE.UNSTYLED] = "P";
LABELS[BLOCK_TYPE.HEADER_ONE] = "H1";
LABELS[BLOCK_TYPE.HEADER_TWO] = "H2";
LABELS[BLOCK_TYPE.HEADER_THREE] = "H3";
LABELS[BLOCK_TYPE.HEADER_FOUR] = "H4";
LABELS[BLOCK_TYPE.HEADER_FIVE] = "H5";
LABELS[BLOCK_TYPE.HEADER_SIX] = "H6";
LABELS[BLOCK_TYPE.UNORDERED_LIST_ITEM] = "UL";
LABELS[BLOCK_TYPE.ORDERED_LIST_ITEM] = "OL";
LABELS[BLOCK_TYPE.CODE] = "{ }";
LABELS[BLOCK_TYPE.BLOCKQUOTE] = "❝";
LABELS[INLINE_STYLE.BOLD] = "B";
LABELS[INLINE_STYLE.ITALIC] = "𝘐";
LABELS[INLINE_STYLE.CODE] = "{ }";
LABELS[INLINE_STYLE.UNDERLINE] = "U";
LABELS[INLINE_STYLE.STRIKETHROUGH] = "S";
LABELS[INLINE_STYLE.MARK] = "☆";
LABELS[INLINE_STYLE.QUOTATION] = "❛";
LABELS[INLINE_STYLE.SMALL] = "𝖲𝗆a𝗅𝗅";
LABELS[INLINE_STYLE.SAMPLE] = "𝙳𝚊𝚝𝚊";
LABELS[INLINE_STYLE.INSERT] = "Ins";
LABELS[INLINE_STYLE.DELETE] = "Del";
LABELS[INLINE_STYLE.SUPERSCRIPT] = "Sup";
LABELS[INLINE_STYLE.SUBSCRIPT] = "Sub";
LABELS[INLINE_STYLE.KEYBOARD] = "⌘";
LABELS[ENTITY_TYPE.LINK] = "🔗";
LABELS[ENTITY_TYPE.IMAGE] = "🖼";
LABELS[ENTITY_TYPE.HORIZONTAL_RULE] = "―";
LABELS[BR_TYPE] = "↵";
LABELS[UNDO_TYPE] = "↺";
LABELS[REDO_TYPE] = "↻";
var DESCRIPTIONS = {};
DESCRIPTIONS[BLOCK_TYPE.UNSTYLED] = "Paragraph";
DESCRIPTIONS[BLOCK_TYPE.HEADER_ONE] = "Heading 1";
DESCRIPTIONS[BLOCK_TYPE.HEADER_TWO] = "Heading 2";
DESCRIPTIONS[BLOCK_TYPE.HEADER_THREE] = "Heading 3";
DESCRIPTIONS[BLOCK_TYPE.HEADER_FOUR] = "Heading 4";
DESCRIPTIONS[BLOCK_TYPE.HEADER_FIVE] = "Heading 5";
DESCRIPTIONS[BLOCK_TYPE.HEADER_SIX] = "Heading 6";
DESCRIPTIONS[BLOCK_TYPE.UNORDERED_LIST_ITEM] = "Bulleted list";
DESCRIPTIONS[BLOCK_TYPE.ORDERED_LIST_ITEM] = "Numbered list";
DESCRIPTIONS[BLOCK_TYPE.BLOCKQUOTE] = "Blockquote";
DESCRIPTIONS[BLOCK_TYPE.CODE] = "Code block";
DESCRIPTIONS[INLINE_STYLE.BOLD] = "Bold";
DESCRIPTIONS[INLINE_STYLE.ITALIC] = "Italic";
DESCRIPTIONS[INLINE_STYLE.CODE] = "Code";
DESCRIPTIONS[INLINE_STYLE.UNDERLINE] = "Underline";
DESCRIPTIONS[INLINE_STYLE.STRIKETHROUGH] = "Strikethrough";
DESCRIPTIONS[INLINE_STYLE.MARK] = "Highlight";
DESCRIPTIONS[INLINE_STYLE.QUOTATION] = "Inline quotation";
DESCRIPTIONS[INLINE_STYLE.SMALL] = "Small";
DESCRIPTIONS[INLINE_STYLE.SAMPLE] = "Program output";
DESCRIPTIONS[INLINE_STYLE.INSERT] = "Inserted";
DESCRIPTIONS[INLINE_STYLE.DELETE] = "Deleted";
DESCRIPTIONS[INLINE_STYLE.KEYBOARD] = "Shortcut key";
DESCRIPTIONS[INLINE_STYLE.SUPERSCRIPT] = "Superscript";
DESCRIPTIONS[INLINE_STYLE.SUBSCRIPT] = "Subscript";
DESCRIPTIONS[ENTITY_TYPE.LINK] = "Link";
DESCRIPTIONS[ENTITY_TYPE.IMAGE] = "Image";
DESCRIPTIONS[ENTITY_TYPE.HORIZONTAL_RULE] = "Horizontal line";
DESCRIPTIONS[BR_TYPE] = "Line break";
DESCRIPTIONS[UNDO_TYPE] = "Undo";
DESCRIPTIONS[REDO_TYPE] = "Redo";
var KEYBOARD_SHORTCUTS = {};
KEYBOARD_SHORTCUTS[BLOCK_TYPE.UNSTYLED] = "⌫";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_ONE] = "#";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_TWO] = "##";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_THREE] = "###";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_FOUR] = "####";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_FIVE] = "#####";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_SIX] = "######";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.UNORDERED_LIST_ITEM] = "-";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.ORDERED_LIST_ITEM] = "1.";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.BLOCKQUOTE] = ">";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.CODE] = "```";
KEYBOARD_SHORTCUTS[INLINE_STYLE.BOLD] = {
  other: "Ctrl + B",
  macOS: "⌘ + B"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.ITALIC] = {
  other: "Ctrl + I",
  macOS: "⌘ + I"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.UNDERLINE] = {
  other: "Ctrl + U",
  macOS: "⌘ + U"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.STRIKETHROUGH] = {
  other: "Ctrl + ⇧ + X",
  macOS: "⌘ + ⇧ + X"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.SUPERSCRIPT] = {
  other: "Ctrl + .",
  macOS: "⌘ + ."
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.SUBSCRIPT] = {
  other: "Ctrl + ,",
  macOS: "⌘ + ,"
};
KEYBOARD_SHORTCUTS[ENTITY_TYPE.LINK] = {
  other: "Ctrl + K",
  macOS: "⌘ + K"
};
KEYBOARD_SHORTCUTS[BR_TYPE] = "⇧ + ↵";
KEYBOARD_SHORTCUTS[ENTITY_TYPE.HORIZONTAL_RULE] = "- - -";
KEYBOARD_SHORTCUTS[UNDO_TYPE] = {
  other: "Ctrl + Z",
  macOS: "⌘ + Z"
};
KEYBOARD_SHORTCUTS[REDO_TYPE] = {
  other: "Ctrl + ⇧ + Z",
  macOS: "⌘ + ⇧ + Z"
};
var HANDLED = "handled";
var NOT_HANDLED = "not-handled";

/**
 * Inspired by draftjs-utils, with our custom functions.
 *
 * DraftUtils functions are utility helpers useful in isolation, specific to the Draft.js API,
 * without ties to Draftail's specific behavior or other APIs.
 */

var DraftUtils = {
  /**
   * Returns the first selected block.
   */
  getSelectedBlock: function getSelectedBlock(editorState) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    return content.getBlockMap().get(selection.getStartKey());
  },

  /**
   * Returns the entity applicable to whole of current selection.
   * An entity can not span multiple blocks.
   * https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/inline.js#L75
   */
  getSelectionEntity: function getSelectionEntity(editorState) {
    var entity;
    var selection = editorState.getSelection();
    var start = selection.getStartOffset();
    var end = selection.getEndOffset();

    if (start === end && start === 0) {
      end = 1;
    } else if (start === end) {
      start -= 1;
    }

    var block = this.getSelectedBlock(editorState);

    for (var i = start; i < end; i += 1) {
      var currentEntity = block.getEntityAt(i);

      if (!currentEntity) {
        entity = undefined;
        break;
      }

      if (i === start) {
        entity = currentEntity;
      } else if (entity !== currentEntity) {
        entity = undefined;
        break;
      }
    }

    return entity;
  },

  /**
   * Creates a selection on a given entity in the currently selected block.
   * Returns the current selection if no entity key is provided, or if the entity could not be found.
   */
  getEntitySelection: function getEntitySelection(editorState, entityKey) {
    var selection = editorState.getSelection();

    if (!entityKey) {
      return selection;
    }

    var block = this.getSelectedBlock(editorState);
    var entityRange; // https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/inline.js#L111

    block.findEntityRanges(function (value) {
      return value.get("entity") === entityKey;
    }, function (start, end) {
      entityRange = {
        start: start,
        end: end
      };
    });

    if (!entityRange) {
      return selection;
    }

    return selection.merge({
      anchorOffset: selection.isBackward ? entityRange.end : entityRange.start,
      focusOffset: selection.isBackward ? entityRange.start : entityRange.end
    });
  },

  /**
   * Updates a given atomic block's entity, merging new data with the old one.
   */
  updateBlockEntity: function updateBlockEntity(editorState, block, data) {
    var content = editorState.getCurrentContent();
    var nextContent = content.mergeEntityData(block.getEntityAt(0), data); // To remove in Draft.js 0.11.
    // This is necessary because entity data is still using a mutable, global store.

    nextContent = Modifier.mergeBlockData(nextContent, new SelectionState({
      anchorKey: block.getKey(),
      anchorOffset: 0,
      focusKey: block.getKey(),
      focusOffset: block.getLength()
    }), {});
    return EditorState.push(editorState, nextContent, "apply-entity");
  },

  /**
   * Inserts a horizontal rule in the place of the current selection.
   * Returns updated EditorState.
   * Inspired by DraftUtils.addLineBreakRemovingSelection.
   */
  addHorizontalRuleRemovingSelection: function addHorizontalRuleRemovingSelection(editorState) {
    var contentState = editorState.getCurrentContent();
    var contentStateWithEntity = contentState.createEntity( // Draft.js Flow typing issue.
    // See https://github.com/facebook/draft-js/issues/868.
    // $FlowFixMe
    ENTITY_TYPE.HORIZONTAL_RULE, "IMMUTABLE", {});
    var entityKey = contentStateWithEntity.getLastCreatedEntityKey();
    return AtomicBlockUtils.insertAtomicBlock(editorState, entityKey, " ");
  },

  /**
   * Changes a block type to be `newType`, setting its new text.
   * Also removes the required characters from the characterList,
   * and resets block data.
   */
  resetBlockWithType: function resetBlockWithType(editorState, newType, newText) {
    var newData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var contentState = editorState.getCurrentContent();
    var selectionState = editorState.getSelection();
    var key = selectionState.getStartKey();
    var blockMap = contentState.getBlockMap();
    var block = blockMap.get(key); // Maintain persistence in the list while removing chars from the start.
    // https://github.com/facebook/draft-js/blob/788595984da7c1e00d1071ea82b063ff87140be4/src/model/transaction/removeRangeFromContentState.js#L333

    var chars = block.getCharacterList();
    var startOffset = 0;
    var sliceOffset = block.getText().length - newText.length;

    while (startOffset < sliceOffset) {
      chars = chars.shift();
      startOffset += 1;
    }

    var newBlock = block.merge({
      type: newType,
      text: newText,
      characterList: chars,
      data: newData
    });
    var newContentState = contentState.merge({
      blockMap: blockMap.set(key, newBlock)
    });
    var newSelectionState = selectionState.merge({
      anchorOffset: 0,
      focusOffset: 0
    });
    return EditorState.acceptSelection(EditorState.set(editorState, {
      currentContent: newContentState
    }), newSelectionState);
  },

  /**
   * Applies an inline style on a given range, based on a Markdown shortcut,
   * removing the Markdown markers.
   * Supports adding styles on existing styles, and entities.
   */
  applyMarkdownStyle: function applyMarkdownStyle(editorState, range, char) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var marked = selection.merge({
      anchorOffset: range.start,
      focusOffset: range.end
    });
    var endMarker = selection.merge({
      anchorOffset: range.end - range.pattern.length,
      focusOffset: range.end
    });
    var startMarker = selection.merge({
      anchorOffset: range.start,
      focusOffset: range.start + range.pattern.length
    }); // Remove the markers separately to preserve existing styles and entities on the marked text.

    content = Modifier.applyInlineStyle(content, marked, range.type);
    content = Modifier.removeRange(content, endMarker, "forward");
    content = Modifier.removeRange(content, startMarker, "forward");
    var offset = selection.getFocusOffset() - range.pattern.length * 2;
    var endSelection = selection.merge({
      anchorOffset: offset,
      focusOffset: offset
    });
    content = content.merge({
      selectionAfter: endSelection
    });
    content = Modifier.insertText(content, endSelection, char);
    return EditorState.push(editorState, content, "change-inline-style");
  },

  /**
   * Removes the block at the given key.
   */
  removeBlock: function removeBlock(editorState, key) {
    var content = editorState.getCurrentContent();
    var blockMap = content.getBlockMap().remove(key);
    return EditorState.set(editorState, {
      currentContent: content.merge({
        blockMap: blockMap
      })
    });
  },

  /**
   * Removes a block-level entity, turning the block into an empty paragraph,
   * and placing the selection on it.
   */
  removeBlockEntity: function removeBlockEntity(editorState, entityKey, blockKey) {
    var newState = editorState;
    var content = editorState.getCurrentContent();
    var blockMap = content.getBlockMap();
    var block = blockMap.get(blockKey);
    var newBlock = block.merge({
      type: BLOCK_TYPE.UNSTYLED,
      text: "",
      // No text = no character list
      characterList: block.getCharacterList().slice(0, 0),
      data: {}
    });
    var newSelection = new SelectionState({
      anchorKey: blockKey,
      focusKey: blockKey,
      anchorOffset: 0,
      focusOffset: 0
    });
    var newContent = content.merge({
      blockMap: blockMap.set(blockKey, newBlock)
    });
    newState = EditorState.push(newState, newContent, "change-block-type");
    newState = EditorState.forceSelection(newState, newSelection);
    return newState;
  },

  /**
   * Handles pressing delete within an atomic block. This can happen when selection is placed on an image.
   * Ideally this should be handled by the built-in RichUtils, but it's not.
   * See https://github.com/wagtail/wagtail/issues/4370.
   */
  handleDeleteAtomic: function handleDeleteAtomic(editorState) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var key = selection.getAnchorKey();
    var offset = selection.getAnchorOffset();
    var block = content.getBlockForKey(key); // Problematic selection. Pressing delete here would remove the entity, but not the block.

    if (selection.isCollapsed() && block.getType() === BLOCK_TYPE.ATOMIC && offset === 0) {
      return this.removeBlockEntity(editorState, block.getEntityAt(0), key);
    }

    return false;
  },

  /**
   * Get an entity decorator strategy based on the given entity type.
   * This strategy will find all entities of the given type.
   */
  getEntityTypeStrategy: function getEntityTypeStrategy(entityType) {
    var strategy = function strategy(block, callback, contentState) {
      block.findEntityRanges(function (character) {
        var entityKey = character.getEntity();
        return entityKey !== null && contentState.getEntity(entityKey).getType() === entityType;
      }, callback);
    };

    return strategy;
  },

  /**
   * Determines whether the editor should show its placeholder.
   * See https://draftjs.org/docs/api-reference-editor.html#placeholder
   * for details on why this is useful.
   */
  shouldHidePlaceholder: function shouldHidePlaceholder(editorState) {
    var contentState = editorState.getCurrentContent();
    return contentState.hasText() || contentState.getBlockMap().first().getType() !== BLOCK_TYPE.UNSTYLED;
  },

  /**
   * Inserts new unstyled block.
   * Initially inspired from https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/block.js#L153,
   * but changed so that the split + block type reset amounts to
   * only one change in the undo stack.
   */
  insertNewUnstyledBlock: function insertNewUnstyledBlock(editorState) {
    var selection = editorState.getSelection();
    var newContent = Modifier.splitBlock(editorState.getCurrentContent(), selection);
    var blockMap = newContent.getBlockMap();
    var blockKey = selection.getStartKey();
    var insertedBlockKey = newContent.getKeyAfter(blockKey);
    var newBlock = blockMap.get(insertedBlockKey).set("type", BLOCK_TYPE.UNSTYLED);
    newContent = newContent.merge({
      blockMap: blockMap.set(insertedBlockKey, newBlock)
    });
    return EditorState.push(editorState, newContent, "split-block");
  },

  /**
   * Handles Shift + Enter keypress removing selection and inserting a line break.
   * https://github.com/jpuri/draftjs-utils/blob/112bbe449cc9156522fcf2b40f2910a071b795c2/js/block.js#L133
   */
  addLineBreak: function addLineBreak(editorState) {
    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();

    if (selection.isCollapsed()) {
      return RichUtils.insertSoftNewline(editorState);
    }

    var newContent = Modifier.removeRange(content, selection, "forward");
    var fragment = newContent.getSelectionAfter();
    var block = newContent.getBlockForKey(fragment.getStartKey());
    newContent = Modifier.insertText(newContent, fragment, "\n", block.getInlineStyleAt(fragment.getStartOffset()), null);
    return EditorState.push(editorState, newContent, "insert-fragment");
  },

  /**
   * Handles hard newlines.
   * https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/keyPress.js#L17
   */
  handleHardNewline: function handleHardNewline(editorState) {
    var selection = editorState.getSelection();

    if (!selection.isCollapsed()) {
      return false;
    }

    var content = editorState.getCurrentContent();
    var blockKey = selection.getStartKey();
    var block = content.getBlockForKey(blockKey);
    var blockType = block.getType(); // Use a loose check to allow custom list item types to reuse the continuation behavior.

    var isListBlock = blockType.endsWith("-list-item");

    if (!isListBlock && block.getType() !== BLOCK_TYPE.UNSTYLED && block.getLength() === selection.getStartOffset()) {
      return this.insertNewUnstyledBlock(editorState);
    }

    if (isListBlock && block.getLength() === 0) {
      var depth = block.getDepth();

      if (depth === 0) {
        var nextContent = RichUtils.tryToRemoveBlockStyle(editorState); // At the moment, tryToRemoveBlockStyle always returns for
        // collapsed selections at the start of a block. So in theory this corner case should never happen.

        return nextContent ? EditorState.push(editorState, nextContent, "change-block-type") : false;
      }

      var blockMap = content.getBlockMap();
      var newBlock = block.set("depth", depth - 1);
      return EditorState.push(editorState, content.merge({
        blockMap: blockMap.set(blockKey, newBlock)
      }), "adjust-depth");
    }

    return false;
  },

  /**
   * Handles three scenarios:
   * - Soft newlines.
   * - Hard newlines in the "defer breaking out of the block" case.
   * - Other hard newlines.
   * See https://github.com/springload/draftail/issues/104,
   * https://github.com/jpuri/draftjs-utils/issues/10.
   */
  handleNewLine: function handleNewLine(editorState, event) {
    // https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/keyPress.js#L64
    if (isSoftNewlineEvent(event)) {
      return this.addLineBreak(editorState);
    }

    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var key = selection.getStartKey();
    var offset = selection.getStartOffset();
    var block = content.getBlockForKey(key);
    var isDeferredBreakoutBlock = [BLOCK_TYPE.CODE].includes(block.getType());

    if (isDeferredBreakoutBlock) {
      var isEmpty = selection.isCollapsed() && offset === 0 && block.getLength() === 0;

      if (isEmpty) {
        return EditorState.push(editorState, Modifier.setBlockType(content, selection, BLOCK_TYPE.UNSTYLED), "change-block-type");
      }

      return false;
    }

    return this.handleHardNewline(editorState);
  }
};

var hasCommandModifier = KeyBindingUtil.hasCommandModifier,
    isOptionKeyCommand = KeyBindingUtil.isOptionKeyCommand;
var hasCmd = hasCommandModifier; // Hack relying on the internals of Draft.js.
// See https://github.com/facebook/draft-js/pull/869
// $FlowFixMe

var IS_MAC_OS = isOptionKeyCommand({
  altKey: "test"
}) === "test";
/**
 * Methods defining the behavior of the editor, depending on its configuration.
 */

var behavior = {
  /**
   * Configure block render map from block types list.
   */
  getBlockRenderMap: function getBlockRenderMap(blockTypes) {
    var renderMap = DefaultDraftBlockRenderMap; // Override default element for code block.
    // Fix https://github.com/facebook/draft-js/issues/406.

    if (blockTypes.some(function (block) {
      return block.type === BLOCK_TYPE.CODE;
    })) {
      renderMap = renderMap.set(BLOCK_TYPE.CODE, {
        element: "code",
        wrapper: DefaultDraftBlockRenderMap.get(BLOCK_TYPE.CODE).wrapper
      });
    }

    blockTypes.filter(function (block) {
      return block.element;
    }).forEach(function (block) {
      renderMap = renderMap.set(block.type, {
        element: block.element
      });
    });
    return renderMap;
  },

  /**
   * block style function automatically adding a class with the block's type.
   */
  blockStyleFn: function blockStyleFn(block) {
    var type = block.getType();
    return "Draftail-block--".concat(type, " ").concat(blockDepthStyleFn(block));
  },

  /**
   * Configure key binding function from enabled blocks, styles, entities.
   */
  getKeyBindingFn: function getKeyBindingFn(blockTypes, inlineStyles, entityTypes) {
    var getEnabled = function getEnabled(activeTypes) {
      return activeTypes.reduce(function (enabled, type) {
        enabled[type.type] = type.type;
        return enabled;
      }, {});
    };

    var blocks = getEnabled(blockTypes);
    var styles = getEnabled(inlineStyles);
    var entities = getEnabled(entityTypes); // Emits key commands to use in `handleKeyCommand` in `Editor`.

    var keyBindingFn = function keyBindingFn(e) {
      // Safeguard that we only trigger shortcuts with exact matches.
      // eg. cmd + shift + b should not trigger bold.
      if (e.shiftKey) {
        // Key bindings supported by Draft.js must be explicitely discarded.
        // See https://github.com/facebook/draft-js/issues/941.
        switch (e.keyCode) {
          case KEY_CODES.B:
            return undefined;

          case KEY_CODES.I:
            return undefined;

          case KEY_CODES.J:
            return undefined;

          case KEY_CODES.U:
            return undefined;

          case KEY_CODES.X:
            return hasCmd(e) && styles[INLINE_STYLE.STRIKETHROUGH];

          case KEY_CODES[7]:
            return hasCmd(e) && blocks[BLOCK_TYPE.ORDERED_LIST_ITEM];

          case KEY_CODES[8]:
            return hasCmd(e) && blocks[BLOCK_TYPE.UNORDERED_LIST_ITEM];

          default:
            return getDefaultKeyBinding(e);
        }
      }

      var ctrlAlt = (e.ctrlKey || e.metaKey) && e.altKey;

      switch (e.keyCode) {
        case KEY_CODES.K:
          return hasCmd(e) && entities.LINK;

        case KEY_CODES.B:
          return hasCmd(e) && styles[INLINE_STYLE.BOLD];

        case KEY_CODES.I:
          return hasCmd(e) && styles[INLINE_STYLE.ITALIC];

        case KEY_CODES.J:
          return hasCmd(e) && styles[INLINE_STYLE.CODE];

        case KEY_CODES.U:
          return hasCmd(e) && styles[INLINE_STYLE.UNDERLINE];

        case KEY_CODES["."]:
          return hasCmd(e) && styles[INLINE_STYLE.SUPERSCRIPT];

        case KEY_CODES[","]:
          return hasCmd(e) && styles[INLINE_STYLE.SUBSCRIPT];

        case KEY_CODES[0]:
          // Reverting to unstyled block is always available.
          return ctrlAlt && BLOCK_TYPE.UNSTYLED;

        case KEY_CODES[1]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_ONE];

        case KEY_CODES[2]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_TWO];

        case KEY_CODES[3]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_THREE];

        case KEY_CODES[4]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_FOUR];

        case KEY_CODES[5]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_FIVE];

        case KEY_CODES[6]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_SIX];

        default:
          return getDefaultKeyBinding(e);
      }
    };

    return keyBindingFn;
  },
  hasKeyboardShortcut: function hasKeyboardShortcut(type) {
    return !!KEYBOARD_SHORTCUTS[type];
  },
  getKeyboardShortcut: function getKeyboardShortcut(type) {
    var isMacOS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IS_MAC_OS;
    var shortcut = KEYBOARD_SHORTCUTS[type];
    var system = isMacOS ? "macOS" : "other";
    return shortcut && shortcut[system] || shortcut;
  },

  /**
   * Defines whether a block should be altered to a new type when
   * the user types a given mark.
   * This powers the "autolist" feature.
   *
   * Returns the new block type, or false if no replacement should occur.
   */
  handleBeforeInputBlockType: function handleBeforeInputBlockType(mark, blockTypes) {
    return blockTypes.find(function (b) {
      return b.type === INPUT_BLOCK_MAP[mark];
    }) ? INPUT_BLOCK_MAP[mark] : false;
  },
  handleBeforeInputHR: function handleBeforeInputHR(mark, block) {
    return mark === INPUT_ENTITY_MAP[ENTITY_TYPE.HORIZONTAL_RULE] && block.getType() !== BLOCK_TYPE.CODE;
  },

  /**
   * Checks whether a given input string contains style shortcuts.
   * If so, returns the range onto which the shortcut is applied.
   */
  handleBeforeInputInlineStyle: function handleBeforeInputInlineStyle(input, inlineStyles) {
    var activeShortcuts = INPUT_STYLE_MAP.filter(function (_ref) {
      var type = _ref.type;
      return inlineStyles.some(function (s) {
        return s.type === type;
      });
    });
    var range;
    var match = activeShortcuts.find(function (_ref2) {
      var regex = _ref2.regex;
      // Re-create a RegExp object every time because RegExp is stateful.
      range = new RegExp(regex, "g").exec(input);
      return range;
    });
    return range && match ? {
      pattern: match.pattern,
      start: range.index === 0 ? 0 : range.index + 1,
      end: range.index + range[0].length,
      type: match.type
    } : false;
  },
  getCustomStyleMap: function getCustomStyleMap(inlineStyles) {
    var customStyleMap = {};
    inlineStyles.forEach(function (style) {
      if (style.style) {
        customStyleMap[style.type] = style.style;
      } else if (CUSTOM_STYLE_MAP[style.type]) {
        customStyleMap[style.type] = CUSTOM_STYLE_MAP[style.type];
      } else {
        customStyleMap[style.type] = {};
      }
    });
    return customStyleMap;
  },

  /**
   * Applies whitelist and blacklist operations to the editor content,
   * so the resulting editor state is shaped according to Draftail
   * expectations and configuration.
   */
  filterPaste: function filterPaste(_ref3, editorState) {
    var maxListNesting = _ref3.maxListNesting,
        enableHorizontalRule = _ref3.enableHorizontalRule,
        enableLineBreak = _ref3.enableLineBreak,
        blockTypes = _ref3.blockTypes,
        inlineStyles = _ref3.inlineStyles,
        entityTypes = _ref3.entityTypes;
    var enabledEntityTypes = entityTypes.slice();
    var whitespacedCharacters = ["\t", "📷"];

    if (enableHorizontalRule) {
      enabledEntityTypes.push({
        type: ENTITY_TYPE.HORIZONTAL_RULE
      });
    }

    if (!enableLineBreak) {
      whitespacedCharacters.push("\n");
    }

    return filterEditorState({
      blocks: blockTypes.map(function (b) {
        return b.type;
      }),
      styles: inlineStyles.map(function (s) {
        return s.type;
      }),
      entities: enabledEntityTypes,
      maxNesting: maxListNesting,
      whitespacedCharacters: whitespacedCharacters
    }, editorState);
  }
};

/**
 * Icon as SVG element. Can optionally render a React element instead.
 */
var Icon = function Icon(_ref) {
  var icon = _ref.icon,
      title = _ref.title,
      className = _ref.className;
  var children;

  if (typeof icon === "string") {
    if (icon.includes("#")) {
      children = /*#__PURE__*/React.createElement("use", {
        xlinkHref: icon
      });
    } else {
      children = /*#__PURE__*/React.createElement("path", {
        d: icon
      });
    }
  } else if (Array.isArray(icon)) {
    // eslint-disable-next-line @thibaudcolas/cookbook/react/no-array-index-key
    children = icon.map(function (d, i) {
      return /*#__PURE__*/React.createElement("path", {
        key: i,
        d: d
      });
    });
  } else {
    return icon;
  }

  return /*#__PURE__*/React.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 1024 1024",
    className: "Draftail-Icon ".concat(className || ""),
    "aria-hidden": title ? null : true,
    role: title ? "img" : null,
    "aria-label": title || null
  }, children);
};

Icon.defaultProps = {
  title: null,
  className: null
};

/**
 * Displays a basic button, with optional active variant,
 * enriched with a tooltip. The tooltip stops showing on click.
 */
var ToolbarButton = /*#__PURE__*/function (_PureComponent) {
  _inherits(ToolbarButton, _PureComponent);

  var _super = _createSuper(ToolbarButton);

  function ToolbarButton(props) {
    var _this;

    _classCallCheck(this, ToolbarButton);

    _this = _super.call(this, props);
    _this.state = {
      showTooltipOnHover: true
    };
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_this));
    _this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized(_this));
    return _this;
  }
  /* :: onMouseDown: (e: Event) => void; */


  _createClass(ToolbarButton, [{
    key: "onMouseDown",
    value: function onMouseDown(e) {
      var _this$props = this.props,
          name = _this$props.name,
          onClick = _this$props.onClick;
      e.preventDefault();
      this.setState({
        showTooltipOnHover: false
      });

      if (onClick) {
        onClick(name || "");
      }
    }
    /* :: onMouseLeave: () => void; */

  }, {
    key: "onMouseLeave",
    value: function onMouseLeave() {
      this.setState({
        showTooltipOnHover: true
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          name = _this$props2.name,
          active = _this$props2.active,
          label = _this$props2.label,
          title = _this$props2.title,
          icon = _this$props2.icon;
      var showTooltipOnHover = this.state.showTooltipOnHover;
      return /*#__PURE__*/React.createElement("button", {
        name: name,
        className: "Draftail-ToolbarButton".concat(active ? " Draftail-ToolbarButton--active" : ""),
        type: "button",
        "aria-label": title || null,
        "data-draftail-balloon": title && showTooltipOnHover ? true : null,
        tabIndex: -1,
        onMouseDown: this.onMouseDown,
        onMouseLeave: this.onMouseLeave
      }, typeof icon !== "undefined" && icon !== null ? /*#__PURE__*/React.createElement(Icon, {
        icon: icon
      }) : null, label ? /*#__PURE__*/React.createElement("span", {
        className: "Draftail-ToolbarButton__label"
      }, label) : null);
    }
  }]);

  return ToolbarButton;
}(PureComponent);

ToolbarButton.defaultProps = {
  name: null,
  active: false,
  label: null,
  title: null,
  icon: null,
  onClick: null
};

var ToolbarGroup = function ToolbarGroup(_ref) {
  var children = _ref.children;
  var hasChildren = React.Children.toArray(children).some(function (c) {
    return c !== null;
  });
  return hasChildren ? /*#__PURE__*/React.createElement("div", {
    className: "Draftail-ToolbarGroup"
  }, children) : null;
};

ToolbarGroup.defaultProps = {
  children: null
};

var getButtonLabel = function getButtonLabel(type, config) {
  var icon = typeof config === "boolean" ? undefined : config.icon;

  if (typeof config.label === "string" || config.label === null) {
    return config.label;
  }

  if (typeof icon !== "undefined") {
    return null;
  }

  return LABELS[type];
};

var showButton = function showButton(config) {
  return Boolean(config.icon) || Boolean(getButtonLabel(config.type, config));
};

var getButtonTitle = function getButtonTitle(type, config) {
  var description = typeof config === "boolean" || typeof config.description === "undefined" ? DESCRIPTIONS[type] : config.description;
  var hasShortcut = behavior.hasKeyboardShortcut(type);
  var title = description;

  if (hasShortcut) {
    var desc = description ? "".concat(description, "\n") : "";
    title = "".concat(desc).concat(behavior.getKeyboardShortcut(type));
  }

  return title;
};

var ToolbarDefaults = /*#__PURE__*/function (_PureComponent) {
  _inherits(ToolbarDefaults, _PureComponent);

  var _super = _createSuper(ToolbarDefaults);

  function ToolbarDefaults() {
    _classCallCheck(this, ToolbarDefaults);

    return _super.apply(this, arguments);
  }

  _createClass(ToolbarDefaults, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          currentStyles = _this$props.currentStyles,
          currentBlock = _this$props.currentBlock,
          blockTypes = _this$props.blockTypes,
          inlineStyles = _this$props.inlineStyles,
          enableHorizontalRule = _this$props.enableHorizontalRule,
          enableLineBreak = _this$props.enableLineBreak,
          showUndoControl = _this$props.showUndoControl,
          showRedoControl = _this$props.showRedoControl,
          entityTypes = _this$props.entityTypes,
          toggleBlockType = _this$props.toggleBlockType,
          toggleInlineStyle = _this$props.toggleInlineStyle,
          addHR = _this$props.addHR,
          addBR = _this$props.addBR,
          onUndoRedo = _this$props.onUndoRedo,
          onRequestSource = _this$props.onRequestSource;
      return [/*#__PURE__*/React.createElement(ToolbarGroup, {
        key: "styles"
      }, inlineStyles.filter(showButton).map(function (t) {
        return /*#__PURE__*/React.createElement(ToolbarButton, {
          key: t.type,
          name: t.type,
          active: currentStyles.has(t.type),
          label: getButtonLabel(t.type, t),
          title: getButtonTitle(t.type, t),
          icon: t.icon,
          onClick: toggleInlineStyle
        });
      })), /*#__PURE__*/React.createElement(ToolbarGroup, {
        key: "blocks"
      }, blockTypes.filter(showButton).map(function (t) {
        return /*#__PURE__*/React.createElement(ToolbarButton, {
          key: t.type,
          name: t.type,
          active: currentBlock === t.type,
          label: getButtonLabel(t.type, t),
          title: getButtonTitle(t.type, t),
          icon: t.icon,
          onClick: toggleBlockType
        });
      })), /*#__PURE__*/React.createElement(ToolbarGroup, {
        key: "hr-br"
      }, enableHorizontalRule ? /*#__PURE__*/React.createElement(ToolbarButton, {
        name: ENTITY_TYPE.HORIZONTAL_RULE,
        onClick: addHR,
        label: getButtonLabel(ENTITY_TYPE.HORIZONTAL_RULE, enableHorizontalRule),
        title: getButtonTitle(ENTITY_TYPE.HORIZONTAL_RULE, enableHorizontalRule),
        icon: typeof enableHorizontalRule !== "boolean" ? enableHorizontalRule.icon : null
      }) : null, enableLineBreak ? /*#__PURE__*/React.createElement(ToolbarButton, {
        name: BR_TYPE,
        onClick: addBR,
        label: getButtonLabel(BR_TYPE, enableLineBreak),
        title: getButtonTitle(BR_TYPE, enableLineBreak),
        icon: typeof enableLineBreak !== "boolean" ? enableLineBreak.icon : null
      }) : null), /*#__PURE__*/React.createElement(ToolbarGroup, {
        key: "entities"
      }, entityTypes.filter(showButton).map(function (t) {
        return /*#__PURE__*/React.createElement(ToolbarButton, {
          key: t.type,
          name: t.type,
          onClick: onRequestSource,
          label: getButtonLabel(t.type, t),
          title: getButtonTitle(t.type, t),
          icon: t.icon
        });
      })), /*#__PURE__*/React.createElement(ToolbarGroup, {
        key: "undo-redo"
      }, showUndoControl ? /*#__PURE__*/React.createElement(ToolbarButton, {
        name: UNDO_TYPE,
        onClick: onUndoRedo,
        label: getButtonLabel(UNDO_TYPE, showUndoControl),
        title: getButtonTitle(UNDO_TYPE, showUndoControl),
        icon: typeof showUndoControl !== "boolean" ? showUndoControl.icon : null
      }) : null, showRedoControl ? /*#__PURE__*/React.createElement(ToolbarButton, {
        name: REDO_TYPE,
        onClick: onUndoRedo,
        label: getButtonLabel(REDO_TYPE, showRedoControl),
        title: getButtonTitle(REDO_TYPE, showRedoControl),
        icon: typeof showRedoControl !== "boolean" ? showRedoControl.icon : null
      }) : null)];
    }
  }]);

  return ToolbarDefaults;
}(PureComponent);

var Toolbar = function Toolbar(props) {
  var controls = props.controls,
      getEditorState = props.getEditorState,
      onChange = props.onChange;
  return /*#__PURE__*/React.createElement("div", {
    className: "Draftail-Toolbar",
    role: "toolbar"
  }, /*#__PURE__*/React.createElement(ToolbarDefaults, props), /*#__PURE__*/React.createElement(ToolbarGroup, null, controls.map(function (Control, i) {
    return /*#__PURE__*/React.createElement(Control // eslint-disable-next-line @thibaudcolas/cookbook/react/no-array-index-key
    , {
      key: i,
      getEditorState: getEditorState,
      onChange: onChange
    });
  })));
};

/**
 * An <hr/> in the editor.
 */

var DividerBlock = function DividerBlock() {
  return /*#__PURE__*/React.createElement("hr", {
    className: "Draftail-DividerBlock"
  });
};

var defaultProps = {
  /** Initial content of the editor. Use this to edit pre-existing content. */
  rawContentState: null,

  /** Called when changes occured. Use this to persist editor content. */
  onSave: null,

  /** Content of the editor, when using the editor as a controlled component. Incompatible with `rawContentState` and `onSave`. */
  editorState: null,

  /** Called whenever the editor state is updated. Use this to manage the content of a controlled editor. Incompatible with `rawContentState` and `onSave`. */
  onChange: null,

  /** Called when the editor receives focus. */
  onFocus: null,

  /** Called when the editor loses focus. */
  onBlur: null,

  /** Displayed when the editor is empty. Hidden if the user changes styling. */
  placeholder: null,

  /** Enable the use of horizontal rules in the editor. */
  enableHorizontalRule: false,

  /** Enable the use of line breaks in the editor. */
  enableLineBreak: false,

  /** Show undo control in the toolbar. */
  showUndoControl: false,

  /** Show redo control in the toolbar. */
  showRedoControl: false,

  /** Disable copy/paste of rich text in the editor. */
  stripPastedStyles: true,

  /** Set whether spellcheck is turned on for your editor.
   * See https://draftjs.org/docs/api-reference-editor.html#spellcheck.
   */
  spellCheck: false,

  /** Set whether the editor should be rendered in readOnly mode.
   * See https://draftjs.org/docs/api-reference-editor.html#readonly
   */
  readOnly: false,

  /** Optionally set the overriding text alignment for this editor.
   * See https://draftjs.org/docs/api-reference-editor.html#textalignment.
   */
  textAlignment: null,

  /** Optionally set the overriding text directionality for this editor.
   * See https://draftjs.org/docs/api-reference-editor.html#textdirectionality.
   */
  textDirectionality: null,

  /** Set if auto capitalization is turned on and how it behaves.
   * See https://draftjs.org/docs/api-reference-editor.html#autocapitalize-string.
   */
  autoCapitalize: null,

  /** Set if auto complete is turned on and how it behaves.
   * See https://draftjs.org/docs/api-reference-editor.html#autocomplete-string.
   */
  autoComplete: null,

  /** Set if auto correct is turned on and how it behaves.
   * See https://draftjs.org/docs/api-reference-editor.html#autocorrect-string.
   */
  autoCorrect: null,

  /** See https://draftjs.org/docs/api-reference-editor.html#aria-props. */
  ariaDescribedBy: null,

  /** List of the available block types. */
  blockTypes: [],

  /** List of the available inline styles. */
  inlineStyles: [],

  /** List of the available entity types. */
  entityTypes: [],

  /** List of active decorators. */
  decorators: [],

  /** List of extra toolbar controls. */
  controls: [],

  /** List of plugins of the draft-js-plugins architecture. */
  plugins: [],

  /** Optionally override the default Draftail toolbar, removing or replacing it. */
  topToolbar: Toolbar,

  /** Optionally add a custom toolbar underneath the editor, e.g. for metrics. */
  bottomToolbar: null,

  /** Max level of nesting for list items. 0 = no nesting. Maximum = 10. */
  maxListNesting: 1,

  /** Frequency at which to call the onSave callback (ms). */
  stateSaveInterval: 250
};

/* :: import type { ElementRef, Node } from "react"; */

/**
 * Main component of the Draftail editor.
 * Contains the Draft.js editor instance, and ties together UI and behavior.
 */
var DraftailEditor = /*#__PURE__*/function (_Component) {
  _inherits(DraftailEditor, _Component);

  var _super = _createSuper(DraftailEditor);

  /* :: editorRef: ElementRef<Editor>; */

  /* :: copySource: { unregister: () => void }; */

  /* :: updateTimeout: ?number; */

  /* :: lockEditor: () => void; */

  /* :: unlockEditor: () => void; */

  /* :: getEditorState: () => EditorState; */
  function DraftailEditor(props) {
    var _this;

    _classCallCheck(this, DraftailEditor);

    _this = _super.call(this, props);
    _this.onChange = _this.onChange.bind(_assertThisInitialized(_this));
    _this.saveState = _this.saveState.bind(_assertThisInitialized(_this));
    _this.toggleSource = _this.toggleSource.bind(_assertThisInitialized(_this));
    _this.toggleEditor = _this.toggleEditor.bind(_assertThisInitialized(_this));
    _this.lockEditor = _this.toggleEditor.bind(_assertThisInitialized(_this), true);
    _this.unlockEditor = _this.toggleEditor.bind(_assertThisInitialized(_this), false);
    _this.handleReturn = _this.handleReturn.bind(_assertThisInitialized(_this));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized(_this));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized(_this));
    _this.onTab = _this.onTab.bind(_assertThisInitialized(_this));
    _this.handleKeyCommand = _this.handleKeyCommand.bind(_assertThisInitialized(_this));
    _this.handleBeforeInput = _this.handleBeforeInput.bind(_assertThisInitialized(_this));
    _this.handlePastedText = _this.handlePastedText.bind(_assertThisInitialized(_this));
    _this.toggleBlockType = _this.toggleBlockType.bind(_assertThisInitialized(_this));
    _this.toggleInlineStyle = _this.toggleInlineStyle.bind(_assertThisInitialized(_this));
    _this.onEditEntity = _this.onEditEntity.bind(_assertThisInitialized(_this));
    _this.onRemoveEntity = _this.onRemoveEntity.bind(_assertThisInitialized(_this));
    _this.addHR = _this.addHR.bind(_assertThisInitialized(_this));
    _this.addBR = _this.addBR.bind(_assertThisInitialized(_this));
    _this.onUndoRedo = _this.onUndoRedo.bind(_assertThisInitialized(_this));
    _this.blockRenderer = _this.blockRenderer.bind(_assertThisInitialized(_this));
    _this.onRequestSource = _this.onRequestSource.bind(_assertThisInitialized(_this));
    _this.onCompleteSource = _this.onCompleteSource.bind(_assertThisInitialized(_this));
    _this.onCloseSource = _this.onCloseSource.bind(_assertThisInitialized(_this));
    _this.focus = _this.focus.bind(_assertThisInitialized(_this));
    _this.renderSource = _this.renderSource.bind(_assertThisInitialized(_this));
    var editorState = props.editorState,
        rawContentState = props.rawContentState;
    _this.state = {
      readOnlyState: false,
      hasFocus: false,
      sourceOptions: null
    };

    if (editorState !== null) {
      _this.getEditorState = _this.getEditorStateProp.bind(_assertThisInitialized(_this));
    } else {
      // If editorState is not used as a prop, create it in local state from rawContentState.
      _this.state.editorState = createEditorStateFromRaw(rawContentState);
      _this.getEditorState = _this.getEditorStateState.bind(_assertThisInitialized(_this));
    }

    return _this;
  }

  _createClass(DraftailEditor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.copySource = registerCopySource(this.editorRef.editor);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.copySource.unregister();
      window.clearTimeout(this.updateTimeout);
    }
    /* :: onFocus: () => void; */

  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        hasFocus: true
      });
      var onFocus = this.props.onFocus;

      if (onFocus) {
        onFocus();
      }
    }
    /* :: onBlur: () => void; */

  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        hasFocus: false
      });
      var onBlur = this.props.onBlur;

      if (onBlur) {
        onBlur();
      }
    }
    /* :: onTab: (event: SyntheticKeyboardEvent<>) => true; */

  }, {
    key: "onTab",
    value: function onTab(event) {
      var maxListNesting = this.props.maxListNesting;
      var editorState = this.getEditorState();
      var newState = RichUtils.onTab(event, editorState, maxListNesting);
      this.onChange(newState);
      return true;
    }
    /* :: onChange: (nextState: EditorState) => void; */

  }, {
    key: "onChange",
    value: function onChange(nextState) {
      var _this2 = this;

      var _this$props = this.props,
          stateSaveInterval = _this$props.stateSaveInterval,
          maxListNesting = _this$props.maxListNesting,
          enableHorizontalRule = _this$props.enableHorizontalRule,
          enableLineBreak = _this$props.enableLineBreak,
          blockTypes = _this$props.blockTypes,
          inlineStyles = _this$props.inlineStyles,
          entityTypes = _this$props.entityTypes,
          onChange = _this$props.onChange;
      var editorState = this.getEditorState();
      var shouldFilterPaste = nextState.getCurrentContent() !== editorState.getCurrentContent() && nextState.getLastChangeType() === "insert-fragment";
      var filteredState = nextState;

      if (shouldFilterPaste) {
        filteredState = behavior.filterPaste({
          maxListNesting: maxListNesting,
          enableHorizontalRule: enableHorizontalRule,
          enableLineBreak: enableLineBreak,
          blockTypes: blockTypes,
          inlineStyles: inlineStyles,
          entityTypes: entityTypes
        }, filteredState);
      }

      if (onChange) {
        onChange(filteredState);
      } else {
        this.setState({
          editorState: filteredState
        }, function () {
          window.clearTimeout(_this2.updateTimeout);
          _this2.updateTimeout = window.setTimeout(_this2.saveState, stateSaveInterval);
        });
      }
    }
    /* :: onEditEntity: (entityKey: string) => void; */

  }, {
    key: "onEditEntity",
    value: function onEditEntity(entityKey) {
      var entityTypes = this.props.entityTypes;
      var editorState = this.getEditorState();
      var content = editorState.getCurrentContent();
      var entity = content.getEntity(entityKey);
      var entityType = entityTypes.find(function (t) {
        return t.type === entity.type;
      }); // $FlowFixMe

      if (!entityType.block) {
        var entitySelection = DraftUtils.getEntitySelection(editorState, entityKey);
        var nextState = EditorState.acceptSelection(editorState, entitySelection);
        this.onChange(nextState);
      }

      this.toggleSource(entity.getType(), entityKey, entity);
    }
    /* :: onRemoveEntity: (entityKey: string, blockKey: string) => void; */

  }, {
    key: "onRemoveEntity",
    value: function onRemoveEntity(entityKey, blockKey) {
      var entityTypes = this.props.entityTypes;
      var editorState = this.getEditorState();
      var content = editorState.getCurrentContent();
      var entity = content.getEntity(entityKey);
      var entityType = entityTypes.find(function (t) {
        return t.type === entity.type;
      });
      var newState = editorState; // $FlowFixMe

      if (entityType.block) {
        newState = DraftUtils.removeBlockEntity(newState, entityKey, blockKey);
      } else {
        var entitySelection = DraftUtils.getEntitySelection(editorState, entityKey);
        newState = RichUtils.toggleLink(newState, entitySelection, null);
      }

      this.onChange(newState);
    }
    /* :: onUndoRedo: (type: string) => void; */

  }, {
    key: "onUndoRedo",
    value: function onUndoRedo(type) {
      var editorState = this.getEditorState();
      var newEditorState = editorState;

      if (type === UNDO_TYPE) {
        newEditorState = EditorState.undo(editorState);
      } else if (type === REDO_TYPE) {
        newEditorState = EditorState.redo(editorState);
      }

      this.onChange(newEditorState);
    }
    /* :: onRequestSource: (entityType: string) => void; */

  }, {
    key: "onRequestSource",
    value: function onRequestSource(entityType) {
      var editorState = this.getEditorState();
      var contentState = editorState.getCurrentContent();
      var entityKey = DraftUtils.getSelectionEntity(editorState);
      this.toggleSource(entityType, entityKey, entityKey ? contentState.getEntity(entityKey) : null);
    }
    /* :: onCompleteSource: (nextState: EditorState) => void; */

  }, {
    key: "onCompleteSource",
    value: function onCompleteSource(nextState) {
      var _this3 = this;

      this.setState({
        sourceOptions: null
      }, function () {
        if (nextState) {
          _this3.onChange(nextState);
        }

        window.setTimeout(function () {
          _this3.setState({
            readOnlyState: false
          }, function () {
            window.setTimeout(function () {
              _this3.focus();
            }, 0);
          });
        }, 0);
      });
    }
    /* :: onCloseSource: () => void; */

  }, {
    key: "onCloseSource",
    value: function onCloseSource() {
      this.setState({
        sourceOptions: null,
        readOnlyState: false
      });
    }
    /* :: getEditorStateProp: () => EditorState; */

  }, {
    key: "getEditorStateProp",
    value: function getEditorStateProp() {
      var editorState = this.props.editorState;
      return editorState;
    }
    /* :: getEditorStateState: () => EditorState; */

  }, {
    key: "getEditorStateState",
    value: function getEditorStateState() {
      var editorState = this.state.editorState;
      return editorState;
    }
    /* :: saveState: () => void; */

  }, {
    key: "saveState",
    value: function saveState() {
      var onSave = this.props.onSave;
      var editorState = this.getEditorState();

      if (onSave) {
        onSave(serialiseEditorStateToRaw(editorState));
      }
    }
    /* :: toggleEditor: (readOnlyState: boolean) => void; */

  }, {
    key: "toggleEditor",
    value: function toggleEditor(readOnlyState) {
      this.setState({
        readOnlyState: readOnlyState
      });
    }
    /* :: toggleSource: (type:string, entityKey: ?string, entity: ?EntityInstance) => void; */

  }, {
    key: "toggleSource",
    value: function toggleSource(type, entityKey, entity) {
      var entityTypes = this.props.entityTypes;
      var entityType = entityTypes.find(function (item) {
        return item.type === type;
      });
      this.setState({
        readOnlyState: true,
        sourceOptions: {
          entity: entity,
          entityKey: entityKey,
          entityType: entityType
        }
      });
    }
    /* :: handleReturn: (e: SyntheticKeyboardEvent<>) => 'not-handled' | 'handled'; */

  }, {
    key: "handleReturn",
    value: function handleReturn(e) {
      var _this$props2 = this.props,
          enableLineBreak = _this$props2.enableLineBreak,
          inlineStyles = _this$props2.inlineStyles;
      var editorState = this.getEditorState();
      var ret = NOT_HANDLED; // alt + enter opens links and other entities with a `url` property.

      if (e.altKey) {
        // Mark the return as handled even if there is no entity.
        // alt + enter should never create a newline anyway.
        ret = HANDLED;
        var entityKey = DraftUtils.getSelectionEntity(editorState);

        if (entityKey) {
          var _content = editorState.getCurrentContent();

          var entityData = _content.getEntity(entityKey).getData();

          if (entityData.url) {
            window.open(entityData.url);
          }
        }
      } else {
        if (!enableLineBreak) {
          // Quick hack to disable soft line breaks.
          e.which = 0;
        }

        var newState = editorState;
        var newStyle = false;
        var selection = newState.getSelection(); // Check whether we should apply a Markdown styles shortcut.

        if (selection.isCollapsed()) {
          var block = DraftUtils.getSelectedBlock(editorState);
          newStyle = behavior.handleBeforeInputInlineStyle(block.getText(), inlineStyles);

          if (newStyle) {
            newState = DraftUtils.applyMarkdownStyle(newState, newStyle, "");
          }
        }

        var newLineState = DraftUtils.handleNewLine(newState, e); // Manually handle the return if there is a style to apply.

        if (!newLineState && newStyle) {
          var _content2 = newState.getCurrentContent();

          var newContent = Modifier.splitBlock(_content2, selection);
          newState = EditorState.push(newState, newContent, "split-block"); // Do not propagate the style from the last block.

          newState = RichUtils.toggleInlineStyle(newState, newStyle.type);
        } else {
          newState = newLineState;
        }

        if (newState && newState !== editorState) {
          ret = HANDLED;
          this.onChange(newState);
        }
      }

      return ret;
    }
    /* :: handleKeyCommand: (command: DraftEditorCommand) => 'handled' | 'not-handled'; */

  }, {
    key: "handleKeyCommand",
    value: function handleKeyCommand(command) {
      var _this$props3 = this.props,
          entityTypes = _this$props3.entityTypes,
          blockTypes = _this$props3.blockTypes,
          inlineStyles = _this$props3.inlineStyles;
      var editorState = this.getEditorState();

      if (entityTypes.some(function (t) {
        return t.type === command;
      })) {
        this.onRequestSource(command);
        return HANDLED;
      }

      if (blockTypes.some(function (t) {
        return t.type === command;
      })) {
        this.toggleBlockType(command);
        return HANDLED;
      }

      if (inlineStyles.some(function (t) {
        return t.type === command;
      })) {
        this.toggleInlineStyle(command);
        return HANDLED;
      } // Special case – some delete commands on atomic blocks are not covered by RichUtils.


      if (command === "delete") {
        var _newState = DraftUtils.handleDeleteAtomic(editorState);

        if (_newState) {
          this.onChange(_newState);
          return HANDLED;
        }
      } // If the command is known but not whitelisted for this editor, treat it as handled but don't do anything.


      if (KEY_COMMANDS.includes(command)) {
        return HANDLED;
      }

      var newState = RichUtils.handleKeyCommand(editorState, command);

      if (newState) {
        this.onChange(newState);
        return HANDLED;
      }

      return NOT_HANDLED;
    }
    /* :: handleBeforeInput: (char: string) => 'handled' | 'not-handled'; */

  }, {
    key: "handleBeforeInput",
    value: function handleBeforeInput(char) {
      var _this$props4 = this.props,
          blockTypes = _this$props4.blockTypes,
          inlineStyles = _this$props4.inlineStyles,
          enableHorizontalRule = _this$props4.enableHorizontalRule;
      var editorState = this.getEditorState();
      var selection = editorState.getSelection();

      if (selection.isCollapsed()) {
        var block = DraftUtils.getSelectedBlock(editorState);
        var startOffset = selection.getStartOffset();
        var text = block.getText();
        var beforeInput = text.slice(0, startOffset);
        var mark = "".concat(beforeInput).concat(char);
        var newEditorState = editorState;
        var newBlockType = behavior.handleBeforeInputBlockType(mark, blockTypes);

        if (newBlockType) {
          newEditorState = DraftUtils.resetBlockWithType(newEditorState, newBlockType, text.replace(beforeInput, ""));
        }

        if (enableHorizontalRule && behavior.handleBeforeInputHR(mark, block)) {
          newEditorState = DraftUtils.removeBlock(DraftUtils.addHorizontalRuleRemovingSelection(newEditorState), block.getKey());
        }

        var newStyle = behavior.handleBeforeInputInlineStyle(beforeInput, inlineStyles);

        if (newStyle) {
          newEditorState = DraftUtils.applyMarkdownStyle(newEditorState, newStyle, char);
        }

        if (newEditorState !== editorState) {
          this.onChange(newEditorState);
          return HANDLED;
        }
      }

      return NOT_HANDLED;
    }
    /* :: handlePastedText: (text: string, html: ?string, editorState: EditorState) => 'handled' | 'not-handled'; */

  }, {
    key: "handlePastedText",
    value: function handlePastedText(text, html, editorState) {
      var stripPastedStyles = this.props.stripPastedStyles; // Leave paste handling to Draft.js when stripping styles is desirable.

      if (stripPastedStyles) {
        return NOT_HANDLED;
      }

      var pastedState = handleDraftEditorPastedText(html, editorState);

      if (pastedState) {
        this.onChange(pastedState);
        return HANDLED;
      }

      return NOT_HANDLED;
    }
    /* :: toggleBlockType: (blockType: string) => void; */

  }, {
    key: "toggleBlockType",
    value: function toggleBlockType(blockType) {
      var editorState = this.getEditorState();
      this.onChange(RichUtils.toggleBlockType(editorState, blockType));
    }
    /* :: toggleInlineStyle: (inlineStyle: string) => void; */

  }, {
    key: "toggleInlineStyle",
    value: function toggleInlineStyle(inlineStyle) {
      var editorState = this.getEditorState();
      this.onChange(RichUtils.toggleInlineStyle(editorState, inlineStyle));
    }
    /* :: addHR: () => void; */

  }, {
    key: "addHR",
    value: function addHR() {
      var editorState = this.getEditorState();
      this.onChange(DraftUtils.addHorizontalRuleRemovingSelection(editorState));
    }
    /* :: addBR: () => void; */

  }, {
    key: "addBR",
    value: function addBR() {
      var editorState = this.getEditorState();
      this.onChange(DraftUtils.addLineBreak(editorState));
    }
    /* :: blockRenderer: (block: ContentBlock) => {}; */

  }, {
    key: "blockRenderer",
    value: function blockRenderer(block) {
      var entityTypes = this.props.entityTypes;
      var editorState = this.getEditorState();
      var contentState = editorState.getCurrentContent();

      if (block.getType() !== BLOCK_TYPE.ATOMIC) {
        return null;
      }

      var entityKey = block.getEntityAt(0);

      if (!entityKey) {
        return {
          editable: false
        };
      }

      var entity = contentState.getEntity(entityKey);
      var isHorizontalRule = entity.type === ENTITY_TYPE.HORIZONTAL_RULE;

      if (isHorizontalRule) {
        return {
          component: DividerBlock,
          editable: false
        };
      }

      var entityType = entityTypes.find(function (t) {
        return t.type === entity.type;
      });
      return {
        // $FlowFixMe
        component: entityType.block,
        editable: false,
        props: {
          /** The editorState is available for arbitrary content manipulation. */
          editorState: editorState,

          /** Current entity to manage. */
          entity: entity,

          /** Current entityKey to manage. */
          entityKey: entityKey,

          /** Whole entityType configuration, as provided to the editor. */
          entityType: entityType,

          /** Make the whole editor read-only, except for the block. */
          lockEditor: this.lockEditor,

          /** Make the editor editable again. */
          unlockEditor: this.unlockEditor,

          /** Shorthand to edit entity data. */
          onEditEntity: this.onEditEntity.bind(null, entityKey),

          /** Shorthand to remove an entity, and the related block. */
          onRemoveEntity: this.onRemoveEntity.bind(null, entityKey, block.getKey()),

          /** Update the editorState with arbitrary changes. */
          onChange: this.onChange
        }
      };
    }
    /**
     * Imperative focus API similar to that of Draft.js.
     * See https://draftjs.org/docs/advanced-topics-managing-focus.html#content.
     */

    /* :: focus: () => void; */

  }, {
    key: "focus",
    value: function focus() {
      this.editorRef.focus();
    }
    /* :: renderSource: () => ?Node; */

  }, {
    key: "renderSource",
    value: function renderSource() {
      var sourceOptions = this.state.sourceOptions;
      var editorState = this.getEditorState();

      if (sourceOptions && sourceOptions.entityType) {
        var Source = sourceOptions.entityType.source;
        return /*#__PURE__*/React.createElement(Source
        /** The editorState is available for arbitrary content manipulation. */
        , {
          editorState: editorState
          /** Takes the updated editorState, or null if there are no changes, and focuses the editor. */
          ,
          onComplete: this.onCompleteSource
          /** Closes the source, without focusing the editor again. */
          ,
          onClose: this.onCloseSource
          /** Current entity to edit, if any. */
          ,
          entity: sourceOptions.entity
          /** Current entityKey to edit, if any. */
          ,
          entityKey: sourceOptions.entityKey
          /** Whole entityType configuration, as provided to the editor. */
          ,
          entityType: sourceOptions.entityType
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props5 = this.props,
          placeholder = _this$props5.placeholder,
          enableHorizontalRule = _this$props5.enableHorizontalRule,
          enableLineBreak = _this$props5.enableLineBreak,
          showUndoControl = _this$props5.showUndoControl,
          showRedoControl = _this$props5.showRedoControl,
          stripPastedStyles = _this$props5.stripPastedStyles,
          spellCheck = _this$props5.spellCheck,
          textAlignment = _this$props5.textAlignment,
          textDirectionality = _this$props5.textDirectionality,
          autoCapitalize = _this$props5.autoCapitalize,
          autoComplete = _this$props5.autoComplete,
          autoCorrect = _this$props5.autoCorrect,
          ariaDescribedBy = _this$props5.ariaDescribedBy,
          blockTypes = _this$props5.blockTypes,
          inlineStyles = _this$props5.inlineStyles,
          entityTypes = _this$props5.entityTypes,
          decorators = _this$props5.decorators,
          controls = _this$props5.controls,
          readOnly = _this$props5.readOnly,
          maxListNesting = _this$props5.maxListNesting,
          plugins = _this$props5.plugins,
          topToolbar = _this$props5.topToolbar,
          bottomToolbar = _this$props5.bottomToolbar;
      var _this$state = this.state,
          hasFocus = _this$state.hasFocus,
          readOnlyState = _this$state.readOnlyState;
      var editorState = this.getEditorState();
      var isReadOnly = readOnlyState || readOnly;
      var hidePlaceholder = DraftUtils.shouldHidePlaceholder(editorState);
      var entityDecorators = entityTypes.filter(function (type) {
        return !!type.decorator;
      }).map(function (type) {
        return {
          strategy: DraftUtils.getEntityTypeStrategy(type.type),
          // $FlowFixMe
          component: decorateComponentWithProps(type.decorator, {
            onEdit: _this4.onEditEntity,
            onRemove: _this4.onRemoveEntity
          })
        };
      });
      var TopToolbar = topToolbar;
      var BottomToolbar = bottomToolbar;
      var toolbarProps = {
        currentStyles: editorState.getCurrentInlineStyle(),
        currentBlock: DraftUtils.getSelectedBlock(editorState).getType(),
        enableHorizontalRule: enableHorizontalRule,
        enableLineBreak: enableLineBreak,
        showUndoControl: showUndoControl,
        showRedoControl: showRedoControl,
        blockTypes: blockTypes,
        inlineStyles: inlineStyles,
        entityTypes: entityTypes,
        controls: controls,
        readOnly: isReadOnly,
        toggleBlockType: this.toggleBlockType,
        toggleInlineStyle: this.toggleInlineStyle,
        addHR: this.addHR,
        addBR: this.addBR,
        onUndoRedo: this.onUndoRedo,
        onRequestSource: this.onRequestSource,
        getEditorState: this.getEditorState,
        onChange: this.onChange
      };
      return /*#__PURE__*/React.createElement("div", {
        className: "Draftail-Editor".concat(isReadOnly ? " Draftail-Editor--readonly" : "").concat(hidePlaceholder ? " Draftail-Editor--hide-placeholder" : "").concat(hasFocus ? " Draftail-Editor--focus" : "")
      }, TopToolbar ? /*#__PURE__*/React.createElement(TopToolbar, toolbarProps) : null, /*#__PURE__*/React.createElement(Editor, {
        customStyleMap: behavior.getCustomStyleMap(inlineStyles),
        ref: function ref(_ref) {
          _this4.editorRef = _ref;
        },
        editorState: editorState,
        onChange: this.onChange,
        placeholder: placeholder,
        readOnly: isReadOnly,
        stripPastedStyles: stripPastedStyles,
        spellCheck: spellCheck,
        textAlignment: textAlignment,
        textDirectionality: textDirectionality,
        autoCapitalize: autoCapitalize,
        autoComplete: autoComplete,
        autoCorrect: autoCorrect,
        ariaDescribedBy: ariaDescribedBy,
        handleReturn: this.handleReturn,
        defaultKeyBindings: false,
        handleKeyCommand: this.handleKeyCommand,
        handleBeforeInput: this.handleBeforeInput,
        handlePastedText: this.handlePastedText,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onTab: this.onTab,
        blockRendererFn: this.blockRenderer,
        blockRenderMap: behavior.getBlockRenderMap(blockTypes),
        blockStyleFn: behavior.blockStyleFn // Include the keyBindingFn in a plugin here so that
        // other plugin keyBindingFn's are still called, while
        // still being able to override the Draft.js oversensitive
        // keyboard shortcuts.
        ,
        plugins: plugins.concat([{
          keyBindingFn: behavior.getKeyBindingFn(blockTypes, inlineStyles, entityTypes)
        }]) // $FlowFixMe
        ,
        decorators: decorators.concat(entityDecorators)
      }), BottomToolbar ? /*#__PURE__*/React.createElement(BottomToolbar, toolbarProps) : null, this.renderSource(), /*#__PURE__*/React.createElement(ListNestingStyles, {
        max: maxListNesting
      }));
    }
  }]);

  return DraftailEditor;
}(Component);

DraftailEditor.defaultProps = defaultProps;

export { BLOCK_TYPE, DraftUtils, DraftailEditor, ENTITY_TYPE, INLINE_STYLE, Icon, ToolbarButton };
