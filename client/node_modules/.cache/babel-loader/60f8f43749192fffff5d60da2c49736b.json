{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Text from './text';\nimport { last } from 'lodash-es'; // To check if component is loaded more than once.\n\nimport '@ckeditor/ckeditor5-utils/src/version';\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\n\nexport default class Position {\n  /**\n   * Creates a position.\n   *\n   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * See {@link module:engine/model/position~PositionStickiness}.\n   */\n  constructor(root, path, stickiness = 'toNone') {\n    if (!root.is('element') && !root.is('documentFragment')) {\n      /**\n       * Position root is invalid.\n       *\n       * Positions can only be anchored in elements or document fragments.\n       *\n       * @error model-position-root-invalid\n       */\n      throw new CKEditorError('model-position-root-invalid: Position root invalid.', root);\n    }\n\n    if (!(path instanceof Array) || path.length === 0) {\n      /**\n       * Position path must be an array with at least one item.\n       *\n       * @error model-position-path-incorrect-format\n       * @param path\n       */\n      throw new CKEditorError('model-position-path-incorrect-format: Position path must be an array with at least one item.', root, {\n        path\n      });\n    } // Normalize the root and path (if element was passed).\n\n\n    path = root.getPath().concat(path);\n    root = root.root;\n    /**\n     * Root of the position path.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n     * module:engine/model/position~Position#root\n     */\n\n    this.root = root;\n    /**\n     * Position of the node in the tree. **Path contains offsets, not indexes.**\n     *\n     * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n     * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n     * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n     * down to the position offset in it's parent.\n     *\n     *\t\t ROOT\n     *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n     *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n     *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n     *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n     *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n     *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n     *\n     * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n     * greater than `1` you can place position offset between their start and end:\n     *\n     *\t\t ROOT\n     *\t\t  |- P\n     *\t\t  |- UL\n     *\t\t     |- LI\n     *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n     *\t\t     |- LI\n     *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n     *\n     * @readonly\n     * @member {Array.<Number>} module:engine/model/position~Position#path\n     */\n\n    this.path = path;\n    /**\n     * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n     *\n     * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n     */\n\n    this.stickiness = stickiness;\n  }\n  /**\n   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n   * to the last item in position {@link module:engine/model/position~Position#path path}.\n   *\n   * @type {Number}\n   */\n\n\n  get offset() {\n    return last(this.path);\n  }\n  /**\n   * @param {Number} newOffset\n   */\n\n\n  set offset(newOffset) {\n    this.path[this.path.length - 1] = newOffset;\n  }\n  /**\n   * Parent element of this position.\n   *\n   * Keep in mind that `parent` value is calculated when the property is accessed.\n   * If {@link module:engine/model/position~Position#path position path}\n   * leads to a non-existing element, `parent` property will throw error.\n   *\n   * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n   *\n   * @readonly\n   * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n   */\n\n\n  get parent() {\n    let parent = this.root;\n\n    for (let i = 0; i < this.path.length - 1; i++) {\n      parent = parent.getChild(parent.offsetToIndex(this.path[i]));\n\n      if (!parent) {\n        throw new CKEditorError('model-position-path-incorrect: The position\\'s path is incorrect.', this, {\n          position: this\n        });\n      }\n    }\n\n    if (parent.is('text')) {\n      /**\n       * The position's path is incorrect. This means that a position does not point to\n       * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n       *\n       * **Note**: Unlike DOM and view positions, in the model, the\n       * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n       * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element where\n       * this position points.\n       *\n       * Read more about model positions and offsets in\n       * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n       *\n       * @error position-incorrect-path\n       * @param {module:engine/model/position~Position} position The incorrect position.\n       */\n      throw new CKEditorError('model-position-path-incorrect: The position\\'s path is incorrect.', this, {\n        position: this\n      });\n    }\n\n    return parent;\n  }\n  /**\n   * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n   * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n   * in text node, position index is equal to the index of that text node.\n   *\n   * @readonly\n   * @type {Number}\n   */\n\n\n  get index() {\n    return this.parent.offsetToIndex(this.offset);\n  }\n  /**\n   * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n   * position is not in a text node.\n   *\n   * @readonly\n   * @type {module:engine/model/text~Text|null}\n   */\n\n\n  get textNode() {\n    const node = this.parent.getChild(this.index);\n    return node instanceof Text && node.startOffset < this.offset ? node : null;\n  }\n  /**\n   * Node directly after this position or `null` if this position is in text node.\n   *\n   * @readonly\n   * @type {module:engine/model/node~Node|null}\n   */\n\n\n  get nodeAfter() {\n    return this.textNode === null ? this.parent.getChild(this.index) : null;\n  }\n  /**\n   * Node directly before this position or `null` if this position is in text node.\n   *\n   * @readonly\n   * @type {Node}\n   */\n\n\n  get nodeBefore() {\n    return this.textNode === null ? this.parent.getChild(this.index - 1) : null;\n  }\n  /**\n   * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAtStart() {\n    return this.offset === 0;\n  }\n  /**\n   * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n   *\n   * @readonly\n   * @type {Boolean}\n   */\n\n\n  get isAtEnd() {\n    return this.offset == this.parent.maxOffset;\n  }\n  /**\n   * Checks whether this position is before or after given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {module:engine/model/position~PositionRelation}\n   */\n\n\n  compareWith(otherPosition) {\n    if (this.root != otherPosition.root) {\n      return 'different';\n    }\n\n    const result = compareArrays(this.path, otherPosition.path);\n\n    switch (result) {\n      case 'same':\n        return 'same';\n\n      case 'prefix':\n        return 'before';\n\n      case 'extension':\n        return 'after';\n\n      default:\n        return this.path[result] < otherPosition.path[result] ? 'before' : 'after';\n    }\n  }\n  /**\n   * Gets the farthest position which matches the callback using\n   * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n   *\n   * For example:\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n   * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n   *\n   * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n   * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n   *\n   * \t\tgetLastMatchingPosition( value => false );\n   * \t\t// Do not move the position.\n   *\n   * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n   * return `true` if the value should be skipped or `false` if not.\n   * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n   *\n   * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n   */\n\n\n  getLastMatchingPosition(skip, options = {}) {\n    options.startPosition = this;\n    const treeWalker = new TreeWalker(options);\n    treeWalker.skip(skip);\n    return treeWalker.position;\n  }\n  /**\n   * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n   * but without the last item.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @returns {Array.<Number>} Path to the parent.\n   */\n\n\n  getParentPath() {\n    return this.path.slice(0, -1);\n  }\n  /**\n   * Returns ancestors array of this position, that is this position's parent and its ancestors.\n   *\n   * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n   */\n\n\n  getAncestors() {\n    if (this.parent.is('documentFragment')) {\n      return [this.parent];\n    } else {\n      return this.parent.getAncestors({\n        includeSelf: true\n      });\n    }\n  }\n  /**\n   * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n   * of these two paths must be identical.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} position The second position.\n   * @returns {Array.<Number>} The common path.\n   */\n\n\n  getCommonPath(position) {\n    if (this.root != position.root) {\n      return [];\n    } // We find on which tree-level start and end have the lowest common ancestor\n\n\n    const cmp = compareArrays(this.path, position.path); // If comparison returned string it means that arrays are same.\n\n    const diffAt = typeof cmp == 'string' ? Math.min(this.path.length, position.path.length) : cmp;\n    return this.path.slice(0, diffAt);\n  }\n  /**\n   * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n   * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n   *\n   * @param {module:engine/model/position~Position} position The second position.\n   * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n   */\n\n\n  getCommonAncestor(position) {\n    const ancestorsA = this.getAncestors();\n    const ancestorsB = position.getAncestors();\n    let i = 0;\n\n    while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {\n      i++;\n    }\n\n    return i === 0 ? null : ancestorsA[i - 1];\n  }\n  /**\n   * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n   * is shifted by `shift` value (can be a negative value).\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {Number} shift Offset shift. Can be a negative value.\n   * @returns {module:engine/model/position~Position} Shifted position.\n   */\n\n\n  getShiftedBy(shift) {\n    const shifted = this.clone();\n    const offset = shifted.offset + shift;\n    shifted.offset = offset < 0 ? 0 : offset;\n    return shifted;\n  }\n  /**\n   * Checks whether this position is after given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @see module:engine/model/position~Position#isBefore\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if this position is after given position.\n   */\n\n\n  isAfter(otherPosition) {\n    return this.compareWith(otherPosition) == 'after';\n  }\n  /**\n   * Checks whether this position is before given position.\n   *\n   * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n   * be `true` if positions are in different roots and you might not expect this. You should probably use\n   * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n   * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n   *\n   *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n   *\t\t\t// do A.\n   *\t\t} else {\n   *\t\t\t// do B.\n   *\t\t}\n   *\n   * or, if you have only one if-branch:\n   *\n   *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n   *\t\t\t// do B.\n   *\t\t}\n   *\n   * rather than:\n   *\n   *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n   *\t\t\t// do B.\n   *\t\t} else {\n   *\t\t\t// do A.\n   *\t\t}\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if this position is before given position.\n   */\n\n\n  isBefore(otherPosition) {\n    return this.compareWith(otherPosition) == 'before';\n  }\n  /**\n   * Checks whether this position is equal to given position.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions are same.\n   */\n\n\n  isEqual(otherPosition) {\n    return this.compareWith(otherPosition) == 'same';\n  }\n  /**\n   * Checks whether this position is touching given position. Positions touch when there are no text nodes\n   * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n   * they are very similar or even indistinguishable.\n   *\n   * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n   * @returns {Boolean} True if positions touch.\n   */\n\n\n  isTouching(otherPosition) {\n    let left = null;\n    let right = null;\n    const compare = this.compareWith(otherPosition);\n\n    switch (compare) {\n      case 'same':\n        return true;\n\n      case 'before':\n        left = Position._createAt(this);\n        right = Position._createAt(otherPosition);\n        break;\n\n      case 'after':\n        left = Position._createAt(otherPosition);\n        right = Position._createAt(this);\n        break;\n\n      default:\n        return false;\n    } // Cached for optimization purposes.\n\n\n    let leftParent = left.parent;\n\n    while (left.path.length + right.path.length) {\n      if (left.isEqual(right)) {\n        return true;\n      }\n\n      if (left.path.length > right.path.length) {\n        if (left.offset !== leftParent.maxOffset) {\n          return false;\n        }\n\n        left.path = left.path.slice(0, -1);\n        leftParent = leftParent.parent;\n        left.offset++;\n      } else {\n        if (right.offset !== 0) {\n          return false;\n        }\n\n        right.path = right.path.slice(0, -1);\n      }\n    }\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\tposition.is( 'position' ); // -> true\n   *\t\tposition.is( 'model:position' ); // -> true\n   *\n   *\t\tposition.is( 'view:position' ); // -> false\n   *\t\tposition.is( 'documentSelection' ); // -> false\n   *\n   * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n   *\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\n\n  is(type) {\n    return type == 'position' || type == 'model:position';\n  }\n  /**\n   * Checks if two positions are in the same parent.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/position~Position} position Position to compare with.\n   * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n   */\n\n\n  hasSameParentAs(position) {\n    if (this.root !== position.root) {\n      return false;\n    }\n\n    const thisParentPath = this.getParentPath();\n    const posParentPath = position.getParentPath();\n    return compareArrays(thisParentPath, posParentPath) == 'same';\n  }\n  /**\n   * Returns a copy of this position that is transformed by given `operation`.\n   *\n   * The new position's parameters are updated accordingly to the effect of the `operation`.\n   *\n   * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n   * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n   *\n   * This method is safe to use it on non-existing positions (for example during operational transformation).\n   *\n   * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n\n\n  getTransformedByOperation(operation) {\n    let result;\n\n    switch (operation.type) {\n      case 'insert':\n        result = this._getTransformedByInsertOperation(operation);\n        break;\n\n      case 'move':\n      case 'remove':\n      case 'reinsert':\n        result = this._getTransformedByMoveOperation(operation);\n        break;\n\n      case 'split':\n        result = this._getTransformedBySplitOperation(operation);\n        break;\n\n      case 'merge':\n        result = this._getTransformedByMergeOperation(operation);\n        break;\n\n      default:\n        result = Position._createAt(this);\n        break;\n    }\n\n    return result;\n  }\n  /**\n   * Returns a copy of this position transformed by an insert operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedByInsertOperation(operation) {\n    return this._getTransformedByInsertion(operation.position, operation.howMany);\n  }\n  /**\n   * Returns a copy of this position transformed by a move operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedByMoveOperation(operation) {\n    return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);\n  }\n  /**\n   * Returns a copy of this position transformed by a split operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedBySplitOperation(operation) {\n    const movedRange = operation.movedRange;\n    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == 'toNext';\n\n    if (isContained) {\n      return this._getCombined(operation.splitPosition, operation.moveTargetPosition);\n    } else {\n      if (operation.graveyardPosition) {\n        return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);\n      } else {\n        return this._getTransformedByInsertion(operation.insertionPosition, 1);\n      }\n    }\n  }\n  /**\n   * Returns a copy of this position transformed by merge operation.\n   *\n   * @protected\n   * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  _getTransformedByMergeOperation(operation) {\n    const movedRange = operation.movedRange;\n    const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);\n    let pos;\n\n    if (isContained) {\n      pos = this._getCombined(operation.sourcePosition, operation.targetPosition);\n\n      if (operation.sourcePosition.isBefore(operation.targetPosition)) {\n        // Above happens during OT when the merged element is moved before the merged-to element.\n        pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);\n      }\n    } else if (this.isEqual(operation.deletionPosition)) {\n      pos = Position._createAt(operation.deletionPosition);\n    } else {\n      pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);\n    }\n\n    return pos;\n  }\n  /**\n   * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n   * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n   * @param {Number} howMany How many nodes are removed.\n   * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n   */\n\n\n  _getTransformedByDeletion(deletePosition, howMany) {\n    const transformed = Position._createAt(this); // This position can't be affected if deletion was in a different root.\n\n\n    if (this.root != deletePosition.root) {\n      return transformed;\n    }\n\n    if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {\n      // If nodes are removed from the node that is pointed by this position...\n      if (deletePosition.offset < this.offset) {\n        // And are removed from before an offset of that position...\n        if (deletePosition.offset + howMany > this.offset) {\n          // Position is in removed range, it's no longer in the tree.\n          return null;\n        } else {\n          // Decrement the offset accordingly.\n          transformed.offset -= howMany;\n        }\n      }\n    } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {\n      // If nodes are removed from a node that is on a path to this position...\n      const i = deletePosition.path.length - 1;\n\n      if (deletePosition.offset <= this.path[i]) {\n        // And are removed from before next node of that path...\n        if (deletePosition.offset + howMany > this.path[i]) {\n          // If the next node of that path is removed return null\n          // because the node containing this position got removed.\n          return null;\n        } else {\n          // Otherwise, decrement index on that path.\n          transformed.path[i] -= howMany;\n        }\n      }\n    }\n\n    return transformed;\n  }\n  /**\n   * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n   * @param {Number} howMany How many nodes are inserted.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n\n\n  _getTransformedByInsertion(insertPosition, howMany) {\n    const transformed = Position._createAt(this); // This position can't be affected if insertion was in a different root.\n\n\n    if (this.root != insertPosition.root) {\n      return transformed;\n    }\n\n    if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {\n      // If nodes are inserted in the node that is pointed by this position...\n      if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != 'toPrevious') {\n        // And are inserted before an offset of that position...\n        // \"Push\" this positions offset.\n        transformed.offset += howMany;\n      }\n    } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {\n      // If nodes are inserted in a node that is on a path to this position...\n      const i = insertPosition.path.length - 1;\n\n      if (insertPosition.offset <= this.path[i]) {\n        // And are inserted before next node of that path...\n        // \"Push\" the index on that path.\n        transformed.path[i] += howMany;\n      }\n    }\n\n    return transformed;\n  }\n  /**\n   * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n   * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n   * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n   * @returns {module:engine/model/position~Position} Transformed position.\n   */\n\n\n  _getTransformedByMove(sourcePosition, targetPosition, howMany) {\n    // Update target position, as it could be affected by nodes removal.\n    targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);\n\n    if (sourcePosition.isEqual(targetPosition)) {\n      // If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n      return Position._createAt(this);\n    } // Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\n\n    const transformed = this._getTransformedByDeletion(sourcePosition, howMany);\n\n    const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == 'toNext' || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == 'toPrevious';\n\n    if (isMoved) {\n      // This position is inside moved range (or sticks to it).\n      // In this case, we calculate a combination of this position, move source position and target position.\n      return this._getCombined(sourcePosition, targetPosition);\n    } else {\n      // This position is not inside a removed range.\n      //\n      // In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n      return transformed._getTransformedByInsertion(targetPosition, howMany);\n    }\n  }\n  /**\n   * Returns a new position that is a combination of this position and given positions.\n   *\n   * The combined position is a copy of this position transformed by moving a range starting at `source` position\n   * to the `target` position. It is expected that this position is inside the moved range.\n   *\n   * Example:\n   *\n   *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n   *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n   *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n   *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n   *\n   * Explanation:\n   *\n   * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n   * was inside moved nodes and now should point to the new place. The moved nodes will be after\n   * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n   * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n   * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n   * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n   *\n   * @protected\n   * @param {module:engine/model/position~Position} source Beginning of the moved range.\n   * @param {module:engine/model/position~Position} target Position where the range is moved.\n   * @returns {module:engine/model/position~Position} Combined position.\n   */\n\n\n  _getCombined(source, target) {\n    const i = source.path.length - 1; // The first part of a path to combined position is a path to the place where nodes were moved.\n\n    const combined = Position._createAt(target);\n\n    combined.stickiness = this.stickiness; // Then we have to update the rest of the path.\n    // Fix the offset because this position might be after `from` position and we have to reflect that.\n\n    combined.offset = combined.offset + this.path[i] - source.offset; // Then, add the rest of the path.\n    // If this position is at the same level as `from` position nothing will get added.\n\n    combined.path = combined.path.concat(this.path.slice(i + 1));\n    return combined;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  toJSON() {\n    return {\n      root: this.root.toJSON(),\n      path: Array.from(this.path),\n      stickiness: this.stickiness\n    };\n  }\n  /**\n   * Returns a new position that is equal to current position.\n   *\n   * @returns {module:engine/model/position~Position}\n   */\n\n\n  clone() {\n    return new this.constructor(this.root, this.path, this.stickiness);\n  }\n  /**\n   * Creates position at the given location. The location can be specified as:\n   *\n   * * a {@link module:engine/model/position~Position position},\n   * * parent element and offset (offset defaults to `0`),\n   * * parent element and `'end'` (sets position at the end of that element),\n   * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n   *\n   * This method is a shortcut to other factory methods such as:\n   *\n   * * {@link module:engine/model/position~Position._createBefore},\n   * * {@link module:engine/model/position~Position._createAfter}.\n   *\n   * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n   * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n   * first parameter is a {@link module:engine/model/item~Item model item}.\n   * @protected\n   */\n\n\n  static _createAt(itemOrPosition, offset, stickiness = 'toNone') {\n    if (itemOrPosition instanceof Position) {\n      return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);\n    } else {\n      const node = itemOrPosition;\n\n      if (offset == 'end') {\n        offset = node.maxOffset;\n      } else if (offset == 'before') {\n        return this._createBefore(node, stickiness);\n      } else if (offset == 'after') {\n        return this._createAfter(node, stickiness);\n      } else if (offset !== 0 && !offset) {\n        /**\n         * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n         * requires the offset to be specified when the first parameter is a model item.\n         *\n         * @error model-createPositionAt-offset-required\n         */\n        throw new CKEditorError('model-createPositionAt-offset-required: ' + 'Model#createPositionAt() requires the offset when the first parameter is a model item.', [this, itemOrPosition]);\n      }\n\n      if (!node.is('element') && !node.is('documentFragment')) {\n        /**\n         * Position parent have to be a model element or model document fragment.\n         *\n         * @error model-position-parent-incorrect\n         */\n        throw new CKEditorError('model-position-parent-incorrect: Position parent have to be a element or document fragment.', [this, itemOrPosition]);\n      }\n\n      const path = node.getPath();\n      path.push(offset);\n      return new this(node.root, path, stickiness);\n    }\n  }\n  /**\n   * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n   *\n   * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * @returns {module:engine/model/position~Position}\n   * @protected\n   */\n\n\n  static _createAfter(item, stickiness) {\n    if (!item.parent) {\n      /**\n       * You can not make a position after a root element.\n       *\n       * @error model-position-after-root\n       * @param {module:engine/model/item~Item} root\n       */\n      throw new CKEditorError('model-position-after-root: You cannot make a position after root.', [this, item], {\n        root: item\n      });\n    }\n\n    return this._createAt(item.parent, item.endOffset, stickiness);\n  }\n  /**\n   * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n   *\n   * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n   * @returns {module:engine/model/position~Position}\n   * @protected\n   */\n\n\n  static _createBefore(item, stickiness) {\n    if (!item.parent) {\n      /**\n       * You can not make a position before a root element.\n       *\n       * @error model-position-before-root\n       * @param {module:engine/model/item~Item} root\n       */\n      throw new CKEditorError('model-position-before-root: You cannot make a position before root.', item, {\n        root: item\n      });\n    }\n\n    return this._createAt(item.parent, item.startOffset, stickiness);\n  }\n  /**\n   * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n   *\n   * @param {Object} json Plain object to be converted to `Position`.\n   * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n   * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n   */\n\n\n  static fromJSON(json, doc) {\n    if (json.root === '$graveyard') {\n      const pos = new Position(doc.graveyard, json.path);\n      pos.stickiness = json.stickiness;\n      return pos;\n    }\n\n    if (!doc.getRoot(json.root)) {\n      /**\n       * Cannot create position for document. Root with specified name does not exist.\n       *\n       * @error model-position-fromjson-no-root\n       * @param {String} rootName\n       */\n      throw new CKEditorError('model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.', doc, {\n        rootName: json.root\n      });\n    }\n\n    return new Position(doc.getRoot(json.root), json.path, json.stickiness);\n  }\n\n}\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js"],"names":["TreeWalker","compareArrays","CKEditorError","Text","last","Position","constructor","root","path","stickiness","is","Array","length","getPath","concat","offset","newOffset","parent","i","getChild","offsetToIndex","position","index","textNode","node","startOffset","nodeAfter","nodeBefore","isAtStart","isAtEnd","maxOffset","compareWith","otherPosition","result","getLastMatchingPosition","skip","options","startPosition","treeWalker","getParentPath","slice","getAncestors","includeSelf","getCommonPath","cmp","diffAt","Math","min","getCommonAncestor","ancestorsA","ancestorsB","getShiftedBy","shift","shifted","clone","isAfter","isBefore","isEqual","isTouching","left","right","compare","_createAt","leftParent","type","hasSameParentAs","thisParentPath","posParentPath","getTransformedByOperation","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","_getTransformedByInsertion","howMany","_getTransformedByMove","sourcePosition","targetPosition","movedRange","isContained","containsPosition","start","_getCombined","splitPosition","moveTargetPosition","graveyardPosition","insertionPosition","pos","_getTransformedByDeletion","deletionPosition","deletePosition","transformed","insertPosition","isMoved","source","target","combined","toJSON","from","itemOrPosition","_createBefore","_createAfter","push","item","endOffset","fromJSON","json","doc","graveyard","getRoot","rootName"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,UAAP,MAAuB,cAAvB;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,aAAP,MAA0B,6CAA1B;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,SAASC,IAAT,QAAqB,WAArB,C,CAEA;;AACA,OAAO,uCAAP;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,QAAN,CAAe;AAC7B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,IAAR,EAAcC,UAAU,GAAG,QAA3B,EAAsC;AAChD,QAAK,CAACF,IAAI,CAACG,EAAL,CAAS,SAAT,CAAD,IAAyB,CAACH,IAAI,CAACG,EAAL,CAAS,kBAAT,CAA/B,EAA+D;AAC9D;AACH;AACA;AACA;AACA;AACA;AACA;AACG,YAAM,IAAIR,aAAJ,CACL,qDADK,EAELK,IAFK,CAAN;AAIA;;AAED,QAAK,EAAGC,IAAI,YAAYG,KAAnB,KAA8BH,IAAI,CAACI,MAAL,KAAgB,CAAnD,EAAuD;AACtD;AACH;AACA;AACA;AACA;AACA;AACG,YAAM,IAAIV,aAAJ,CACL,8FADK,EAELK,IAFK,EAGL;AAAEC,QAAAA;AAAF,OAHK,CAAN;AAKA,KA3B+C,CA6BhD;;;AACAA,IAAAA,IAAI,GAAGD,IAAI,CAACM,OAAL,GAAeC,MAAf,CAAuBN,IAAvB,CAAP;AACAD,IAAAA,IAAI,GAAGA,IAAI,CAACA,IAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKA,IAAL,GAAYA,IAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,IAAL,G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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\n\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Text from './text';\nimport { last } from 'lodash-es';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t */\n\tconstructor( root, path, stickiness = 'toNone' ) {\n\t\tif ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position root is invalid.\n\t\t\t *\n\t\t\t * Positions can only be anchored in elements or document fragments.\n\t\t\t *\n\t\t\t * @error model-position-root-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-root-invalid: Position root invalid.',\n\t\t\t\troot\n\t\t\t);\n\t\t}\n\n\t\tif ( !( path instanceof Array ) || path.length === 0 ) {\n\t\t\t/**\n\t\t\t * Position path must be an array with at least one item.\n\t\t\t *\n\t\t\t * @error model-position-path-incorrect-format\n\t\t\t * @param path\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-path-incorrect-format: Position path must be an array with at least one item.',\n\t\t\t\troot,\n\t\t\t\t{ path }\n\t\t\t);\n\t\t}\n\n\t\t// Normalize the root and path (if element was passed).\n\t\tpath = root.getPath().concat( path );\n\t\troot = root.root;\n\n\t\t/**\n\t\t * Root of the position path.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/position~Position#root\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Position of the node in the tree. **Path contains offsets, not indexes.**\n\t\t *\n\t\t * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n\t\t * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n\t\t * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n\t\t * down to the position offset in it's parent.\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n\t\t *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n\t\t *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n\t\t *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n\t\t *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n\t\t *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n\t\t *\n\t\t * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n\t\t * greater than `1` you can place position offset between their start and end:\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P\n\t\t *\t\t  |- UL\n\t\t *\t\t     |- LI\n\t\t *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n\t\t *\t\t     |- LI\n\t\t *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Number>} module:engine/model/position~Position#path\n\t\t */\n\t\tthis.path = path;\n\n\t\t/**\n\t\t * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n\t\t *\n\t\t * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n\t\t */\n\t\tthis.stickiness = stickiness;\n\t}\n\n\t/**\n\t * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n\t * to the last item in position {@link module:engine/model/position~Position#path path}.\n\t *\n\t * @type {Number}\n\t */\n\tget offset() {\n\t\treturn last( this.path );\n\t}\n\n\t/**\n\t * @param {Number} newOffset\n\t */\n\tset offset( newOffset ) {\n\t\tthis.path[ this.path.length - 1 ] = newOffset;\n\t}\n\n\t/**\n\t * Parent element of this position.\n\t *\n\t * Keep in mind that `parent` value is calculated when the property is accessed.\n\t * If {@link module:engine/model/position~Position#path position path}\n\t * leads to a non-existing element, `parent` property will throw error.\n\t *\n\t * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget parent() {\n\t\tlet parent = this.root;\n\n\t\tfor ( let i = 0; i < this.path.length - 1; i++ ) {\n\t\t\tparent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );\n\n\t\t\tif ( !parent ) {\n\t\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: The position\\'s path is incorrect.', this, { position: this } );\n\t\t\t}\n\t\t}\n\n\t\tif ( parent.is( 'text' ) ) {\n\t\t\t/**\n\t\t\t * The position's path is incorrect. This means that a position does not point to\n\t\t\t * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n\t\t\t *\n\t\t\t * **Note**: Unlike DOM and view positions, in the model, the\n\t\t\t * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n\t\t\t * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element where\n\t\t\t * this position points.\n\t\t\t *\n\t\t\t * Read more about model positions and offsets in\n\t\t\t * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n\t\t\t *\n\t\t\t * @error position-incorrect-path\n\t\t\t * @param {module:engine/model/position~Position} position The incorrect position.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: The position\\'s path is incorrect.', this, { position: this } );\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n\t * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n\t * in text node, position index is equal to the index of that text node.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget index() {\n\t\treturn this.parent.offsetToIndex( this.offset );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n\t * position is not in a text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/text~Text|null}\n\t */\n\tget textNode() {\n\t\tconst node = this.parent.getChild( this.index );\n\n\t\treturn ( node instanceof Text && node.startOffset < this.offset ) ? node : null;\n\t}\n\n\t/**\n\t * Node directly after this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index ) : null;\n\t}\n\n\t/**\n\t * Node directly before this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {Node}\n\t */\n\tget nodeBefore() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index - 1 ) : null;\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\treturn this.offset == this.parent.maxOffset;\n\t}\n\n\t/**\n\t * Checks whether this position is before or after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/model/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root != otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tconst result = compareArrays( this.path, otherPosition.path );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'same':\n\t\t\t\treturn 'same';\n\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn this.path[ result ] < otherPosition.path[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n\t * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n\t * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => false );\n\t * \t\t// Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n\t * but without the last item.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @returns {Array.<Number>} Path to the parent.\n\t */\n\tgetParentPath() {\n\t\treturn this.path.slice( 0, -1 );\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and its ancestors.\n\t *\n\t * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tif ( this.parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ this.parent ];\n\t\t} else {\n\t\t\treturn this.parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n\t * of these two paths must be identical.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {Array.<Number>} The common path.\n\t */\n\tgetCommonPath( position ) {\n\t\tif ( this.root != position.root ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We find on which tree-level start and end have the lowest common ancestor\n\t\tconst cmp = compareArrays( this.path, position.path );\n\t\t// If comparison returned string it means that arrays are same.\n\t\tconst diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;\n\n\t\treturn this.path.slice( 0, diffAt );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n\t * is shifted by `shift` value (can be a negative value).\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {Number} shift Offset shift. Can be a negative value.\n\t * @returns {module:engine/model/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = this.clone();\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Checks whether this position is after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @see module:engine/model/position~Position#isBefore\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before given position.\n\t *\n\t * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n\t * be `true` if positions are in different roots and you might not expect this. You should probably use\n\t * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n\t * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n\t *\n\t *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do A.\n\t *\t\t} else {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * or, if you have only one if-branch:\n\t *\n\t *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * rather than:\n\t *\n\t *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t} else {\n\t *\t\t\t// do A.\n\t *\t\t}\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is equal to given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'same';\n\t}\n\n\t/**\n\t * Checks whether this position is touching given position. Positions touch when there are no text nodes\n\t * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n\t * they are very similar or even indistinguishable.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions touch.\n\t */\n\tisTouching( otherPosition ) {\n\t\tlet left = null;\n\t\tlet right = null;\n\t\tconst compare = this.compareWith( otherPosition );\n\n\t\tswitch ( compare ) {\n\t\t\tcase 'same':\n\t\t\t\treturn true;\n\n\t\t\tcase 'before':\n\t\t\t\tleft = Position._createAt( this );\n\t\t\t\tright = Position._createAt( otherPosition );\n\t\t\t\tbreak;\n\n\t\t\tcase 'after':\n\t\t\t\tleft = Position._createAt( otherPosition );\n\t\t\t\tright = Position._createAt( this );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Cached for optimization purposes.\n\t\tlet leftParent = left.parent;\n\n\t\twhile ( left.path.length + right.path.length ) {\n\t\t\tif ( left.isEqual( right ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( left.path.length > right.path.length ) {\n\t\t\t\tif ( left.offset !== leftParent.maxOffset ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tleft.path = left.path.slice( 0, -1 );\n\t\t\t\tleftParent = leftParent.parent;\n\t\t\t\tleft.offset++;\n\t\t\t} else {\n\t\t\t\tif ( right.offset !== 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tright.path = right.path.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tposition.is( 'position' ); // -> true\n\t *\t\tposition.is( 'model:position' ); // -> true\n\t *\n\t *\t\tposition.is( 'view:position' ); // -> false\n\t *\t\tposition.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'position' || type == 'model:position';\n\t}\n\n\t/**\n\t * Checks if two positions are in the same parent.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position Position to compare with.\n\t * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n\t */\n\thasSameParentAs( position ) {\n\t\tif ( this.root !== position.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisParentPath = this.getParentPath();\n\t\tconst posParentPath = position.getParentPath();\n\n\t\treturn compareArrays( thisParentPath, posParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Returns a copy of this position that is transformed by given `operation`.\n\t *\n\t * The new position's parameters are updated accordingly to the effect of the `operation`.\n\t *\n\t * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n\t * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tlet result;\n\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\tresult = this._getTransformedByInsertOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\tresult = this._getTransformedByMoveOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'split':\n\t\t\t\tresult = this._getTransformedBySplitOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tresult = this._getTransformedByMergeOperation( operation );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = Position._createAt( this );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by an insert operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByInsertOperation( operation ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a move operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMoveOperation( operation ) {\n\t\treturn this._getTransformedByMove( operation.sourcePosition, operation.targetPosition, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a split operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\n\t\tconst isContained = movedRange.containsPosition( this ) ||\n\t\t\t( movedRange.start.isEqual( this ) && this.stickiness == 'toNext' );\n\n\t\tif ( isContained ) {\n\t\t\treturn this._getCombined( operation.splitPosition, operation.moveTargetPosition );\n\t\t} else {\n\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\treturn this._getTransformedByMove( operation.graveyardPosition, operation.insertionPosition, 1 );\n\t\t\t} else {\n\t\t\t\treturn this._getTransformedByInsertion( operation.insertionPosition, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by merge operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\t\tconst isContained = movedRange.containsPosition( this ) || movedRange.start.isEqual( this );\n\n\t\tlet pos;\n\n\t\tif ( isContained ) {\n\t\t\tpos = this._getCombined( operation.sourcePosition, operation.targetPosition );\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Above happens during OT when the merged element is moved before the merged-to element.\n\t\t\t\tpos = pos._getTransformedByDeletion( operation.deletionPosition, 1 );\n\t\t\t}\n\t\t} else if ( this.isEqual( operation.deletionPosition ) ) {\n\t\t\tpos = Position._createAt( operation.deletionPosition );\n\t\t} else {\n\t\t\tpos = this._getTransformedByMove( operation.deletionPosition, operation.graveyardPosition, 1 );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n\t * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if deletion was in a different root.\n\t\tif ( this.root != deletePosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are removed from the node that is pointed by this position...\n\t\t\tif ( deletePosition.offset < this.offset ) {\n\t\t\t\t// And are removed from before an offset of that position...\n\t\t\t\tif ( deletePosition.offset + howMany > this.offset ) {\n\t\t\t\t\t// Position is in removed range, it's no longer in the tree.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the offset accordingly.\n\t\t\t\t\ttransformed.offset -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are removed from a node that is on a path to this position...\n\t\t\tconst i = deletePosition.path.length - 1;\n\n\t\t\tif ( deletePosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are removed from before next node of that path...\n\t\t\t\tif ( deletePosition.offset + howMany > this.path[ i ] ) {\n\t\t\t\t\t// If the next node of that path is removed return null\n\t\t\t\t\t// because the node containing this position got removed.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, decrement index on that path.\n\t\t\t\t\ttransformed.path[ i ] -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if insertion was in a different root.\n\t\tif ( this.root != insertPosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are inserted in the node that is pointed by this position...\n\t\t\tif ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && this.stickiness != 'toPrevious' ) ) {\n\t\t\t\t// And are inserted before an offset of that position...\n\t\t\t\t// \"Push\" this positions offset.\n\t\t\t\ttransformed.offset += howMany;\n\t\t\t}\n\t\t} else if ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are inserted in a node that is on a path to this position...\n\t\t\tconst i = insertPosition.path.length - 1;\n\n\t\t\tif ( insertPosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are inserted before next node of that path...\n\t\t\t\t// \"Push\" the index on that path.\n\t\t\t\ttransformed.path[ i ] += howMany;\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n\t * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n\t * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany ) {\n\t\t// Update target position, as it could be affected by nodes removal.\n\t\ttargetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( sourcePosition.isEqual( targetPosition ) ) {\n\t\t\t// If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n\t\t\treturn Position._createAt( this );\n\t\t}\n\n\t\t// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\t\tconst transformed = this._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tconst isMoved = transformed === null ||\n\t\t\t( sourcePosition.isEqual( this ) && this.stickiness == 'toNext' ) ||\n\t\t\t( sourcePosition.getShiftedBy( howMany ).isEqual( this ) && this.stickiness == 'toPrevious' );\n\n\t\tif ( isMoved ) {\n\t\t\t// This position is inside moved range (or sticks to it).\n\t\t\t// In this case, we calculate a combination of this position, move source position and target position.\n\t\t\treturn this._getCombined( sourcePosition, targetPosition );\n\t\t} else {\n\t\t\t// This position is not inside a removed range.\n\t\t\t//\n\t\t\t// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n\t\t\treturn transformed._getTransformedByInsertion( targetPosition, howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new position that is a combination of this position and given positions.\n\t *\n\t * The combined position is a copy of this position transformed by moving a range starting at `source` position\n\t * to the `target` position. It is expected that this position is inside the moved range.\n\t *\n\t * Example:\n\t *\n\t *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n\t *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n\t *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n\t *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n\t *\n\t * Explanation:\n\t *\n\t * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n\t * was inside moved nodes and now should point to the new place. The moved nodes will be after\n\t * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n\t * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n\t * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n\t * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} source Beginning of the moved range.\n\t * @param {module:engine/model/position~Position} target Position where the range is moved.\n\t * @returns {module:engine/model/position~Position} Combined position.\n\t */\n\t_getCombined( source, target ) {\n\t\tconst i = source.path.length - 1;\n\n\t\t// The first part of a path to combined position is a path to the place where nodes were moved.\n\t\tconst combined = Position._createAt( target );\n\t\tcombined.stickiness = this.stickiness;\n\n\t\t// Then we have to update the rest of the path.\n\n\t\t// Fix the offset because this position might be after `from` position and we have to reflect that.\n\t\tcombined.offset = combined.offset + this.path[ i ] - source.offset;\n\n\t\t// Then, add the rest of the path.\n\t\t// If this position is at the same level as `from` position nothing will get added.\n\t\tcombined.path = combined.path.concat( this.path.slice( i + 1 ) );\n\n\t\treturn combined;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\troot: this.root.toJSON(),\n\t\t\tpath: Array.from( this.path ),\n\t\t\tstickiness: this.stickiness\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new position that is equal to current position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.root, this.path, this.stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/position~Position._createBefore},\n\t * * {@link module:engine/model/position~Position._createAfter}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @protected\n\t */\n\tstatic _createAt( itemOrPosition, offset, stickiness = 'toNone' ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn new Position( itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.maxOffset;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this._createBefore( node, stickiness );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this._createAfter( node, stickiness );\n\t\t\t} else if ( offset !== 0 && !offset ) {\n\t\t\t\t/**\n\t\t\t\t * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n\t\t\t\t * requires the offset to be specified when the first parameter is a model item.\n\t\t\t\t *\n\t\t\t\t * @error model-createPositionAt-offset-required\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-createPositionAt-offset-required: ' +\n\t\t\t\t\t'Model#createPositionAt() requires the offset when the first parameter is a model item.',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !node.is( 'element' ) && !node.is( 'documentFragment' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Position parent have to be a model element or model document fragment.\n\t\t\t\t *\n\t\t\t\t * @error model-position-parent-incorrect\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-position-parent-incorrect: Position parent have to be a element or document fragment.',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst path = node.getPath();\n\n\t\t\tpath.push( offset );\n\n\t\t\treturn new this( node.root, path, stickiness );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createAfter( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root element.\n\t\t\t *\n\t\t\t * @error model-position-after-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-after-root: You cannot make a position after root.',\n\t\t\t\t[ this, item ],\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.endOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createBefore( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position before a root element.\n\t\t\t *\n\t\t\t * @error model-position-before-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-before-root: You cannot make a position before root.',\n\t\t\t\titem,\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.startOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Position`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n\t * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( json.root === '$graveyard' ) {\n\t\t\tconst pos = new Position( doc.graveyard, json.path );\n\t\t\tpos.stickiness = json.stickiness;\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tif ( !doc.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create position for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error model-position-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',\n\t\t\t\tdoc,\n\t\t\t\t{ rootName: json.root }\n\t\t\t);\n\t\t}\n\n\t\treturn new Position( doc.getRoot( json.root ), json.path, json.stickiness );\n\t}\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n"]},"metadata":{},"sourceType":"module"}