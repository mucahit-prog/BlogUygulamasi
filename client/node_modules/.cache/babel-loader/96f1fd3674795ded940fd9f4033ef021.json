{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/rooteditableelement\n */\nimport EditableElement from './editableelement';\nconst rootNameSymbol = Symbol('rootName');\n/**\n * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},\n * but in both cases it is called \"an editable\". Roots can contain other {@link module:engine/view/editableelement~EditableElement\n * editable elements} making them \"nested editables\".\n *\n * @extends module:engine/view/editableelement~EditableElement\n */\n\nexport default class RootEditableElement extends EditableElement {\n  /**\n   * Creates root editable element.\n   *\n   * @param {String} name Node name.\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no\n     * other name is set, `main` name is used.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    this.rootName = 'main';\n  }\n  /**\n   * Checks whether this object is of the given.\n   *\n   *\t\trootEditableElement.is( 'rootEditableElement' ); // -> true\n   *\t\trootEditableElement.is( 'editableElement' ); // -> true\n   *\t\trootEditableElement.is( 'element' ); // -> true\n   *\t\trootEditableElement.is( 'node' ); // -> true\n   *\t\trootEditableElement.is( 'view:rootEditableElement' ); // -> true\n   *\t\trootEditableElement.is( 'view:editableElement' ); // -> true\n   *\t\trootEditableElement.is( 'view:element' ); // -> true\n   *\t\trootEditableElement.is( 'view:node' ); // -> true\n   *\n   *\t\trootEditableElement.is( 'model:element' ); // -> false\n   *\t\trootEditableElement.is( 'documentFragment' ); // -> false\n   *\n   * Assuming that the object being checked is a root editbale element, you can also check its\n   * {@link module:engine/view/rooteditableelement~RootEditableElement#name name}:\n   *\n   *\t\trootEditableElement.is( 'div' ); // -> true if this is a div root editable element\n   *\t\trootEditableElement.is( 'rootEditableElement', 'div' ); // -> same as above\n   *\t\ttext.is( 'div' ); -> false\n   *\n   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n   *\n   * @param {String} type Type to check when `name` parameter is present.\n   * Otherwise, it acts like the `name` parameter.\n   * @param {String} [name] Element name.\n   * @returns {Boolean}\n   */\n\n\n  is(type, name = null) {\n    const cutType = type.replace(/^view:/, '');\n\n    if (!name) {\n      return cutType == 'rootElement' || super.is(type);\n    } else {\n      return cutType == 'rootElement' && name == this.name || super.is(type, name);\n    }\n  }\n\n  get rootName() {\n    return this.getCustomProperty(rootNameSymbol);\n  }\n\n  set rootName(rootName) {\n    this._setCustomProperty(rootNameSymbol, rootName);\n  }\n  /**\n   * Overrides old element name and sets new one.\n   * This is needed because view roots are created before they are attached to the DOM.\n   * The name of the root element is temporary at this stage. It has to be changed when the\n   * view root element is attached to the DOM element.\n   *\n   * @protected\n   * @param {String} name The new name of element.\n   */\n\n\n  set _name(name) {\n    this.name = name;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js"],"names":["EditableElement","rootNameSymbol","Symbol","RootEditableElement","constructor","name","rootName","is","type","cutType","replace","getCustomProperty","_setCustomProperty","_name"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,eAAP,MAA4B,mBAA5B;AAEA,MAAMC,cAAc,GAAGC,MAAM,CAAE,UAAF,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,mBAAN,SAAkCH,eAAlC,CAAkD;AAChE;AACD;AACA;AACA;AACA;AACCI,EAAAA,WAAW,CAAEC,IAAF,EAAS;AACnB,UAAOA,IAAP;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,QAAL,GAAgB,MAAhB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,EAAE,CAAEC,IAAF,EAAQH,IAAI,GAAG,IAAf,EAAsB;AACvB,UAAMI,OAAO,GAAGD,IAAI,CAACE,OAAL,CAAc,QAAd,EAAwB,EAAxB,CAAhB;;AACA,QAAK,CAACL,IAAN,EAAa;AACZ,aAAOI,OAAO,IAAI,aAAX,IAA4B,MAAMF,EAAN,CAAUC,IAAV,CAAnC;AACA,KAFD,MAEO;AACN,aAASC,OAAO,IAAI,aAAX,IAA4BJ,IAAI,IAAI,KAAKA,IAA3C,IAAqD,MAAME,EAAN,CAAUC,IAAV,EAAgBH,IAAhB,CAA5D;AACA;AACD;;AAEW,MAARC,QAAQ,GAAG;AACd,WAAO,KAAKK,iBAAL,CAAwBV,cAAxB,CAAP;AACA;;AAEW,MAARK,QAAQ,CAAEA,QAAF,EAAa;AACxB,SAAKM,kBAAL,CAAyBX,cAAzB,EAAyCK,QAAzC;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACU,MAALO,KAAK,CAAER,IAAF,EAAS;AACjB,SAAKA,IAAL,GAAYA,IAAZ;AACA;;AA5E+D","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/rooteditableelement\n */\n\nimport EditableElement from './editableelement';\n\nconst rootNameSymbol = Symbol( 'rootName' );\n\n/**\n * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},\n * but in both cases it is called \"an editable\". Roots can contain other {@link module:engine/view/editableelement~EditableElement\n * editable elements} making them \"nested editables\".\n *\n * @extends module:engine/view/editableelement~EditableElement\n */\nexport default class RootEditableElement extends EditableElement {\n\t/**\n\t * Creates root editable element.\n\t *\n\t * @param {String} name Node name.\n\t */\n\tconstructor( name ) {\n\t\tsuper( name );\n\n\t\t/**\n\t\t * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no\n\t\t * other name is set, `main` name is used.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.rootName = 'main';\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\trootEditableElement.is( 'rootEditableElement' ); // -> true\n\t *\t\trootEditableElement.is( 'editableElement' ); // -> true\n\t *\t\trootEditableElement.is( 'element' ); // -> true\n\t *\t\trootEditableElement.is( 'node' ); // -> true\n\t *\t\trootEditableElement.is( 'view:rootEditableElement' ); // -> true\n\t *\t\trootEditableElement.is( 'view:editableElement' ); // -> true\n\t *\t\trootEditableElement.is( 'view:element' ); // -> true\n\t *\t\trootEditableElement.is( 'view:node' ); // -> true\n\t *\n\t *\t\trootEditableElement.is( 'model:element' ); // -> false\n\t *\t\trootEditableElement.is( 'documentFragment' ); // -> false\n\t *\n\t * Assuming that the object being checked is a root editbale element, you can also check its\n\t * {@link module:engine/view/rooteditableelement~RootEditableElement#name name}:\n\t *\n\t *\t\trootEditableElement.is( 'div' ); // -> true if this is a div root editable element\n\t *\t\trootEditableElement.is( 'rootEditableElement', 'div' ); // -> same as above\n\t *\t\ttext.is( 'div' ); -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type Type to check when `name` parameter is present.\n\t * Otherwise, it acts like the `name` parameter.\n\t * @param {String} [name] Element name.\n\t * @returns {Boolean}\n\t */\n\tis( type, name = null ) {\n\t\tconst cutType = type.replace( /^view:/, '' );\n\t\tif ( !name ) {\n\t\t\treturn cutType == 'rootElement' || super.is( type );\n\t\t} else {\n\t\t\treturn ( cutType == 'rootElement' && name == this.name ) || super.is( type, name );\n\t\t}\n\t}\n\n\tget rootName() {\n\t\treturn this.getCustomProperty( rootNameSymbol );\n\t}\n\n\tset rootName( rootName ) {\n\t\tthis._setCustomProperty( rootNameSymbol, rootName );\n\t}\n\n\t/**\n\t * Overrides old element name and sets new one.\n\t * This is needed because view roots are created before they are attached to the DOM.\n\t * The name of the root element is temporary at this stage. It has to be changed when the\n\t * view root element is attached to the DOM element.\n\t *\n\t * @protected\n\t * @param {String} name The new name of element.\n\t */\n\tset _name( name ) {\n\t\tthis.name = name;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}