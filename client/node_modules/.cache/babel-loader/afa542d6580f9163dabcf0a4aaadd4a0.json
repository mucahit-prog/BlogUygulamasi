{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/inputcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport ChangeBuffer from './utils/changebuffer';\n/**\n * The input command. Used by the {@link module:typing/input~Input input feature} to handle typing.\n *\n * @extends module:core/command~Command\n */\n\nexport default class InputCommand extends Command {\n  /**\n   * Creates an instance of the command.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {Number} undoStepSize The maximum number of atomic changes\n   * which can be contained in one batch in the command buffer.\n   */\n  constructor(editor, undoStepSize) {\n    super(editor);\n    /**\n     * Typing's change buffer used to group subsequent changes into batches.\n     *\n     * @readonly\n     * @private\n     * @member {module:typing/utils/changebuffer~ChangeBuffer} #_buffer\n     */\n\n    this._buffer = new ChangeBuffer(editor.model, undoStepSize);\n    /**\n     * Stores batches created by the input command. The batches are used to differentiate input batches from other batches using\n     * {@link module:typing/input~Input#isInput} method.\n     *\n     * @type {WeakSet<module:engine/model/batch~Batch>}\n     * @protected\n     */\n\n    this._batches = new WeakSet();\n  }\n  /**\n   * The current change buffer.\n   *\n   * @type {module:typing/utils/changebuffer~ChangeBuffer}\n   */\n\n\n  get buffer() {\n    return this._buffer;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  destroy() {\n    super.destroy();\n\n    this._buffer.destroy();\n  }\n  /**\n   * Executes the input command. It replaces the content within the given range with the given text.\n   * Replacing is a two step process, first the content within the range is removed and then the new text is inserted\n   * at the beginning of the range (which after the removal is a collapsed range).\n   *\n   * @fires execute\n   * @param {Object} [options] The command options.\n   * @param {String} [options.text=''] The text to be inserted.\n   * @param {module:engine/model/range~Range} [options.range] The range in which the text is inserted. Defaults\n   * to the first range in the current selection.\n   * @param {module:engine/model/range~Range} [options.resultRange] The range where the selection\n   * should be placed after the insertion. If not specified, the selection will be placed right after\n   * the inserted text.\n   */\n\n\n  execute(options = {}) {\n    const model = this.editor.model;\n    const doc = model.document;\n    const text = options.text || '';\n    const textInsertions = text.length;\n    const range = options.range || doc.selection.getFirstRange();\n    const resultRange = options.resultRange;\n    model.enqueueChange(this._buffer.batch, writer => {\n      const isCollapsedRange = range.isCollapsed;\n\n      this._buffer.lock();\n\n      model.deleteContent(model.createSelection(range));\n\n      if (text) {\n        model.insertContent(writer.createText(text, doc.selection.getAttributes()), range.start);\n      }\n\n      if (resultRange) {\n        writer.setSelection(resultRange);\n      } else if (isCollapsedRange) {\n        // If range was collapsed just shift the selection by the number of inserted characters.\n        writer.setSelection(range.start.getShiftedBy(textInsertions));\n      }\n\n      this._buffer.unlock();\n\n      this._buffer.input(textInsertions); // Store the batch as an 'input' batch for the Input.isInput( batch ) check.\n\n\n      this._batches.add(this._buffer.batch);\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-typing/src/inputcommand.js"],"names":["Command","ChangeBuffer","InputCommand","constructor","editor","undoStepSize","_buffer","model","_batches","WeakSet","buffer","destroy","execute","options","doc","document","text","textInsertions","length","range","selection","getFirstRange","resultRange","enqueueChange","batch","writer","isCollapsedRange","isCollapsed","lock","deleteContent","createSelection","insertContent","createText","getAttributes","start","setSelection","getShiftedBy","unlock","input","add"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,OAAP,MAAoB,sCAApB;AAEA,OAAOC,YAAP,MAAyB,sBAAzB;AAEA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,YAAN,SAA2BF,OAA3B,CAAmC;AACjD;AACD;AACA;AACA;AACA;AACA;AACA;AACCG,EAAAA,WAAW,CAAEC,MAAF,EAAUC,YAAV,EAAyB;AACnC,UAAOD,MAAP;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKE,OAAL,GAAe,IAAIL,YAAJ,CAAkBG,MAAM,CAACG,KAAzB,EAAgCF,YAAhC,CAAf;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKG,QAAL,GAAgB,IAAIC,OAAJ,EAAhB;AACA;AAED;AACD;AACA;AACA;AACA;;;AACW,MAANC,MAAM,GAAG;AACZ,WAAO,KAAKJ,OAAZ;AACA;AAED;AACD;AACA;;;AACCK,EAAAA,OAAO,GAAG;AACT,UAAMA,OAAN;;AAEA,SAAKL,OAAL,CAAaK,OAAb;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACCC,EAAAA,OAAO,CAAEC,OAAO,GAAG,EAAZ,EAAiB;AACvB,UAAMN,KAAK,GAAG,KAAKH,MAAL,CAAYG,KAA1B;AACA,UAAMO,GAAG,GAAGP,KAAK,CAACQ,QAAlB;AACA,UAAMC,IAAI,GAAGH,OAAO,CAACG,IAAR,IAAgB,EAA7B;AACA,UAAMC,cAAc,GAAGD,IAAI,CAACE,MAA5B;AACA,UAAMC,KAAK,GAAGN,OAAO,CAACM,KAAR,IAAiBL,GAAG,CAACM,SAAJ,CAAcC,aAAd,EAA/B;AACA,UAAMC,WAAW,GAAGT,OAAO,CAACS,WAA5B;AAEAf,IAAAA,KAAK,CAACgB,aAAN,CAAqB,KAAKjB,OAAL,CAAakB,KAAlC,EAAyCC,MAAM,IAAI;AAClD,YAAMC,gBAAgB,GAAGP,KAAK,CAACQ,WAA/B;;AAEA,WAAKrB,OAAL,CAAasB,IAAb;;AAEArB,MAAAA,KAAK,CAACsB,aAAN,CAAqBtB,KAAK,CAACuB,eAAN,CAAuBX,KAAvB,CAArB;;AAEA,UAAKH,IAAL,EAAY;AACXT,QAAAA,KAAK,CAACwB,aAAN,CAAqBN,MAAM,CAACO,UAAP,CAAmBhB,IAAnB,EAAyBF,GAAG,CAACM,SAAJ,CAAca,aAAd,EAAzB,CAArB,EAA+Ed,KAAK,CAACe,KAArF;AACA;;AAED,UAAKZ,WAAL,EAAmB;AAClBG,QAAAA,MAAM,CAACU,YAAP,CAAqBb,WAArB;AACA,OAFD,MAEO,IAAKI,gBAAL,EAAwB;AAC9B;AACAD,QAAAA,MAAM,CAACU,YAAP,CAAqBhB,KAAK,CAACe,KAAN,CAAYE,YAAZ,CAA0BnB,cAA1B,CAArB;AACA;;AAED,WAAKX,OAAL,CAAa+B,MAAb;;AAEA,WAAK/B,OAAL,CAAagC,KAAb,CAAoBrB,cAApB,EApBkD,CAsBlD;;;AACA,WAAKT,QAAL,CAAc+B,GAAd,CAAmB,KAAKjC,OAAL,CAAakB,KAAhC;AACA,KAxBD;AAyBA;;AA/FgD","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module typing/inputcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\nimport ChangeBuffer from './utils/changebuffer';\n\n/**\n * The input command. Used by the {@link module:typing/input~Input input feature} to handle typing.\n *\n * @extends module:core/command~Command\n */\nexport default class InputCommand extends Command {\n\t/**\n\t * Creates an instance of the command.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {Number} undoStepSize The maximum number of atomic changes\n\t * which can be contained in one batch in the command buffer.\n\t */\n\tconstructor( editor, undoStepSize ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * Typing's change buffer used to group subsequent changes into batches.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {module:typing/utils/changebuffer~ChangeBuffer} #_buffer\n\t\t */\n\t\tthis._buffer = new ChangeBuffer( editor.model, undoStepSize );\n\n\t\t/**\n\t\t * Stores batches created by the input command. The batches are used to differentiate input batches from other batches using\n\t\t * {@link module:typing/input~Input#isInput} method.\n\t\t *\n\t\t * @type {WeakSet<module:engine/model/batch~Batch>}\n\t\t * @protected\n\t\t */\n\t\tthis._batches = new WeakSet();\n\t}\n\n\t/**\n\t * The current change buffer.\n\t *\n\t * @type {module:typing/utils/changebuffer~ChangeBuffer}\n\t */\n\tget buffer() {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdestroy() {\n\t\tsuper.destroy();\n\n\t\tthis._buffer.destroy();\n\t}\n\n\t/**\n\t * Executes the input command. It replaces the content within the given range with the given text.\n\t * Replacing is a two step process, first the content within the range is removed and then the new text is inserted\n\t * at the beginning of the range (which after the removal is a collapsed range).\n\t *\n\t * @fires execute\n\t * @param {Object} [options] The command options.\n\t * @param {String} [options.text=''] The text to be inserted.\n\t * @param {module:engine/model/range~Range} [options.range] The range in which the text is inserted. Defaults\n\t * to the first range in the current selection.\n\t * @param {module:engine/model/range~Range} [options.resultRange] The range where the selection\n\t * should be placed after the insertion. If not specified, the selection will be placed right after\n\t * the inserted text.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst text = options.text || '';\n\t\tconst textInsertions = text.length;\n\t\tconst range = options.range || doc.selection.getFirstRange();\n\t\tconst resultRange = options.resultRange;\n\n\t\tmodel.enqueueChange( this._buffer.batch, writer => {\n\t\t\tconst isCollapsedRange = range.isCollapsed;\n\n\t\t\tthis._buffer.lock();\n\n\t\t\tmodel.deleteContent( model.createSelection( range ) );\n\n\t\t\tif ( text ) {\n\t\t\t\tmodel.insertContent( writer.createText( text, doc.selection.getAttributes() ), range.start );\n\t\t\t}\n\n\t\t\tif ( resultRange ) {\n\t\t\t\twriter.setSelection( resultRange );\n\t\t\t} else if ( isCollapsedRange ) {\n\t\t\t\t// If range was collapsed just shift the selection by the number of inserted characters.\n\t\t\t\twriter.setSelection( range.start.getShiftedBy( textInsertions ) );\n\t\t\t}\n\n\t\t\tthis._buffer.unlock();\n\n\t\t\tthis._buffer.input( textInsertions );\n\n\t\t\t// Store the batch as an 'input' batch for the Input.isInput( batch ) check.\n\t\t\tthis._batches.add( this._buffer.batch );\n\t\t} );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}