{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller, isBlockFiller } from './filler';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\n\nexport default class Renderer {\n  /**\n   * Creates a renderer instance.\n   *\n   * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n   * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n   */\n  constructor(domConverter, selection) {\n    /**\n     * Set of DOM Documents instances.\n     *\n     * @readonly\n     * @member {Set.<Document>}\n     */\n    this.domDocuments = new Set();\n    /**\n     * Converter instance.\n     *\n     * @readonly\n     * @member {module:engine/view/domconverter~DomConverter}\n     */\n\n    this.domConverter = domConverter;\n    /**\n     * Set of nodes which attributes changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedAttributes = new Set();\n    /**\n     * Set of elements which child lists changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedChildren = new Set();\n    /**\n     * Set of text nodes which text data changed and may need to be rendered.\n     *\n     * @readonly\n     * @member {Set.<module:engine/view/node~Node>}\n     */\n\n    this.markedTexts = new Set();\n    /**\n     * View selection. Renderer updates DOM selection based on the view selection.\n     *\n     * @readonly\n     * @member {module:engine/view/documentselection~DocumentSelection}\n     */\n\n    this.selection = selection;\n    /**\n     * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n     * this is set to `false`.\n     *\n     * @member {Boolean}\n     */\n\n    this.isFocused = false;\n    /**\n     * The text node in which the inline filler was rendered.\n     *\n     * @private\n     * @member {Text}\n     */\n\n    this._inlineFiller = null;\n    /**\n     * DOM element containing fake selection.\n     *\n     * @private\n     * @type {null|HTMLElement}\n     */\n\n    this._fakeSelectionContainer = null;\n  }\n  /**\n   * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n   *\n   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n   *\n   * @see #markedAttributes\n   * @see #markedChildren\n   * @see #markedTexts\n   *\n   * @param {module:engine/view/document~ChangeType} type Type of the change.\n   * @param {module:engine/view/node~Node} node Node to be marked.\n   */\n\n\n  markToSync(type, node) {\n    if (type === 'text') {\n      if (this.domConverter.mapViewToDom(node.parent)) {\n        this.markedTexts.add(node);\n      }\n    } else {\n      // If the node has no DOM element it is not rendered yet,\n      // its children/attributes do not need to be marked to be sync.\n      if (!this.domConverter.mapViewToDom(node)) {\n        return;\n      }\n\n      if (type === 'attributes') {\n        this.markedAttributes.add(node);\n      } else if (type === 'children') {\n        this.markedChildren.add(node);\n      } else {\n        /**\n         * Unknown type passed to Renderer.markToSync.\n         *\n         * @error renderer-unknown-type\n         */\n        throw new CKEditorError('view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.', this);\n      }\n    }\n  }\n  /**\n   * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n   * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n   *\n   * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n   * so it does as little as it is needed to update the DOM.\n   *\n   * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n   * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n   * removed as long as the selection is in the text node which needed it at first.\n   */\n\n\n  render() {\n    let inlineFillerPosition; // Refresh mappings.\n\n    for (const element of this.markedChildren) {\n      this._updateChildrenMappings(element);\n    } // There was inline filler rendered in the DOM but it's not\n    // at the selection position any more, so we can remove it\n    // (cause even if it's needed, it must be placed in another location).\n\n\n    if (this._inlineFiller && !this._isSelectionInInlineFiller()) {\n      this._removeInlineFiller();\n    } // If we've got the filler, let's try to guess its position in the view.\n\n\n    if (this._inlineFiller) {\n      inlineFillerPosition = this._getInlineFillerPosition();\n    } // Otherwise, if it's needed, create it at the selection position.\n    else if (this._needsInlineFillerAtSelection()) {\n        inlineFillerPosition = this.selection.getFirstPosition(); // Do not use `markToSync` so it will be added even if the parent is already added.\n\n        this.markedChildren.add(inlineFillerPosition.parent);\n      }\n\n    for (const element of this.markedAttributes) {\n      this._updateAttrs(element);\n    }\n\n    for (const element of this.markedChildren) {\n      this._updateChildren(element, {\n        inlineFillerPosition\n      });\n    }\n\n    for (const node of this.markedTexts) {\n      if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {\n        this._updateText(node, {\n          inlineFillerPosition\n        });\n      }\n    } // Check whether the inline filler is required and where it really is in the DOM.\n    // At this point in most cases it will be in the DOM, but there are exceptions.\n    // For example, if the inline filler was deep in the created DOM structure, it will not be created.\n    // Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n    // it will not be present.\n    // Fix those and similar scenarios.\n\n\n    if (inlineFillerPosition) {\n      const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);\n      const domDocument = fillerDomPosition.parent.ownerDocument;\n\n      if (!startsWithFiller(fillerDomPosition.parent)) {\n        // Filler has not been created at filler position. Create it now.\n        this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);\n      } else {\n        // Filler has been found, save it.\n        this._inlineFiller = fillerDomPosition.parent;\n      }\n    } else {\n      // There is no filler needed.\n      this._inlineFiller = null;\n    }\n\n    this._updateSelection();\n\n    this._updateFocus();\n\n    this.markedTexts.clear();\n    this.markedAttributes.clear();\n    this.markedChildren.clear();\n  }\n  /**\n   * Updates mappings of view element's children.\n   *\n   * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n   * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n   * Thanks to that these elements do not need to be re-rendered completely.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n   */\n\n\n  _updateChildrenMappings(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n      return;\n    }\n\n    const actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n      withChildren: false\n    }));\n\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n    const actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);\n\n    if (actions.indexOf('replace') !== -1) {\n      const counter = {\n        equal: 0,\n        insert: 0,\n        delete: 0\n      };\n\n      for (const action of actions) {\n        if (action === 'replace') {\n          const insertIndex = counter.equal + counter.insert;\n          const deleteIndex = counter.equal + counter.delete;\n          const viewChild = viewElement.getChild(insertIndex); // The 'uiElement' is a special one and its children are not stored in a view (#799),\n          // so we cannot use it with replacing flow (since it uses view children during rendering\n          // which will always result in rendering empty element).\n\n          if (viewChild && !viewChild.is('uiElement')) {\n            this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);\n          }\n\n          remove(expectedDomChildren[insertIndex]);\n          counter.equal++;\n        } else {\n          counter[action]++;\n        }\n      }\n    }\n  }\n  /**\n   * Updates mappings of a given view element.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n   * @param {Node} domElement The DOM element representing the given view element.\n   */\n\n\n  _updateElementMappings(viewElement, domElement) {\n    // Remap 'DomConverter' bindings.\n    this.domConverter.unbindDomElement(domElement);\n    this.domConverter.bindElements(domElement, viewElement); // View element may have children which needs to be updated, but are not marked, mark them to update.\n\n    this.markedChildren.add(viewElement); // Because we replace new view element mapping with the existing one, the corresponding DOM element\n    // will not be rerendered. The new view element may have different attributes than the previous one.\n    // Since its corresponding DOM element will not be rerendered, new attributes will not be added\n    // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n    // detailed case study.\n    // Also there are cases where replaced element is removed from the view structure and then has\n    // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n    // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n    // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\n    this.markedAttributes.add(viewElement);\n  }\n  /**\n   * Gets the position of the inline filler based on the current selection.\n   * Here, we assume that we know that the filler is needed and\n   * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n   * it is somewhere at the selection position.\n   *\n   * Note: The filler position cannot be restored based on the filler's DOM text node, because\n   * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n   * bindings are only dependable after rendering.\n   *\n   * @private\n   * @returns {module:engine/view/position~Position}\n   */\n\n\n  _getInlineFillerPosition() {\n    const firstPos = this.selection.getFirstPosition();\n\n    if (firstPos.parent.is('text')) {\n      return ViewPosition._createBefore(this.selection.getFirstPosition().parent);\n    } else {\n      return firstPos;\n    }\n  }\n  /**\n   * Returns `true` if the selection has not left the inline filler's text node.\n   * If it is `true`, it means that the filler had been added for a reason and the selection did not\n   * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n   */\n\n\n  _isSelectionInInlineFiller() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    } // Note, we can't check if selection's position equals position of the\n    // this._inlineFiller node, because of #663. We may not be able to calculate\n    // the filler's position in the view at this stage.\n    // Instead, we check it the other way – whether selection is anchored in\n    // that text node or next to it.\n    // Possible options are:\n    // \"FILLER{}\"\n    // \"FILLERadded-text{}\"\n\n\n    const selectionPosition = this.selection.getFirstPosition();\n    const position = this.domConverter.viewPositionToDom(selectionPosition);\n\n    if (position && isText(position.parent) && startsWithFiller(position.parent)) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Removes the inline filler.\n   *\n   * @private\n   */\n\n\n  _removeInlineFiller() {\n    const domFillerNode = this._inlineFiller; // Something weird happened and the stored node doesn't contain the filler's text.\n\n    if (!startsWithFiller(domFillerNode)) {\n      /**\n       * The inline filler node was lost. Most likely, something overwrote the filler text node\n       * in the DOM.\n       *\n       * @error view-renderer-filler-was-lost\n       */\n      throw new CKEditorError('view-renderer-filler-was-lost: The inline filler node was lost.', this);\n    }\n\n    if (isInlineFiller(domFillerNode)) {\n      domFillerNode.parentNode.removeChild(domFillerNode);\n    } else {\n      domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);\n    }\n\n    this._inlineFiller = null;\n  }\n  /**\n   * Checks if the inline {@link module:engine/view/filler filler} should be added.\n   *\n   * @private\n   * @returns {Boolean} `true` if the inline filler should be added.\n   */\n\n\n  _needsInlineFillerAtSelection() {\n    if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {\n      return false;\n    }\n\n    const selectionPosition = this.selection.getFirstPosition();\n    const selectionParent = selectionPosition.parent;\n    const selectionOffset = selectionPosition.offset; // If there is no DOM root we do not care about fillers.\n\n    if (!this.domConverter.mapViewToDom(selectionParent.root)) {\n      return false;\n    }\n\n    if (!selectionParent.is('element')) {\n      return false;\n    } // Prevent adding inline filler inside elements with contenteditable=false.\n    // https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\n\n    if (!isEditable(selectionParent)) {\n      return false;\n    } // We have block filler, we do not need inline one.\n\n\n    if (selectionOffset === selectionParent.getFillerOffset()) {\n      return false;\n    }\n\n    const nodeBefore = selectionPosition.nodeBefore;\n    const nodeAfter = selectionPosition.nodeAfter;\n\n    if (nodeBefore instanceof ViewText || nodeAfter instanceof ViewText) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Checks if text needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} viewText View text to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n\n\n  _updateText(viewText, options) {\n    const domText = this.domConverter.findCorrespondingDomText(viewText);\n    const newDomText = this.domConverter.viewToDom(viewText, domText.ownerDocument);\n    const actualText = domText.data;\n    let expectedText = newDomText.data;\n    const filler = options.inlineFillerPosition;\n\n    if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {\n      expectedText = INLINE_FILLER + expectedText;\n    }\n\n    if (actualText != expectedText) {\n      const actions = fastDiff(actualText, expectedText);\n\n      for (const action of actions) {\n        if (action.type === 'insert') {\n          domText.insertData(action.index, action.values.join(''));\n        } else {\n          // 'delete'\n          domText.deleteData(action.index, action.howMany);\n        }\n      }\n    }\n  }\n  /**\n   * Checks if attribute list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement The view element to update.\n   */\n\n\n  _updateAttrs(viewElement) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n      // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n      // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n      // in 'this._updateChildrenMappings()' so it will be processed separately.\n      return;\n    }\n\n    const domAttrKeys = Array.from(domElement.attributes).map(attr => attr.name);\n    const viewAttrKeys = viewElement.getAttributeKeys(); // Add or overwrite attributes.\n\n    for (const key of viewAttrKeys) {\n      domElement.setAttribute(key, viewElement.getAttribute(key));\n    } // Remove from DOM attributes which do not exists in the view.\n\n\n    for (const key of domAttrKeys) {\n      if (!viewElement.hasAttribute(key)) {\n        domElement.removeAttribute(key);\n      }\n    }\n  }\n  /**\n   * Checks if elements child list needs to be updated and possibly updates it.\n   *\n   * @private\n   * @param {module:engine/view/element~Element} viewElement View element to update.\n   * @param {Object} options\n   * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n   * filler should be rendered.\n   */\n\n\n  _updateChildren(viewElement, options) {\n    const domElement = this.domConverter.mapViewToDom(viewElement);\n\n    if (!domElement) {\n      // If there is no `domElement` it means that it was already removed from DOM.\n      // There is no need to process it. It will be processed when re-inserted.\n      return;\n    }\n\n    const inlineFillerPosition = options.inlineFillerPosition;\n    const actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;\n    const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {\n      bind: true,\n      inlineFillerPosition\n    })); // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n    // during diffing so text nodes could be compared correctly and also during rendering to maintain\n    // proper order and indexes while updating the DOM.\n\n    if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {\n      addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);\n    }\n\n    const diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);\n\n    let i = 0;\n    const nodesToUnbind = new Set();\n\n    for (const action of diff) {\n      if (action === 'insert') {\n        insertAt(domElement, i, expectedDomChildren[i]);\n        i++;\n      } else if (action === 'delete') {\n        nodesToUnbind.add(actualDomChildren[i]);\n        remove(actualDomChildren[i]);\n      } else {\n        // 'equal'\n        // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n        this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));\n\n        i++;\n      }\n    } // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n    // comparision with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n    // it was moved to DOM tree out of the removed node.\n\n\n    for (const node of nodesToUnbind) {\n      if (!node.parentNode) {\n        this.domConverter.unbindDomElement(node);\n      }\n    }\n  }\n  /**\n   * Shorthand for diffing two arrays or node lists of DOM nodes.\n   *\n   * @private\n   * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n   * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n   * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n   */\n\n\n  _diffNodeLists(actualDomChildren, expectedDomChildren) {\n    actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);\n    return diff(actualDomChildren, expectedDomChildren, sameNodes.bind(null, this.domConverter.blockFiller));\n  }\n  /**\n   * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n   * within one `insert`/`delete` action group, for example:\n   *\n   * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n   * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n   * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n   * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n   *\n   * @private\n   * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n   * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n   * @param {Array.<Node>} expectedDom Expected DOM children.\n   * @returns {Array.<String>} Actions array modified with the `replace` actions.\n   */\n\n\n  _findReplaceActions(actions, actualDom, expectedDom) {\n    // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n    if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {\n      return actions;\n    }\n\n    let newActions = [];\n    let actualSlice = [];\n    let expectedSlice = [];\n    const counter = {\n      equal: 0,\n      insert: 0,\n      delete: 0\n    };\n\n    for (const action of actions) {\n      if (action === 'insert') {\n        expectedSlice.push(expectedDom[counter.equal + counter.insert]);\n      } else if (action === 'delete') {\n        actualSlice.push(actualDom[counter.equal + counter.delete]);\n      } else {\n        // equal\n        newActions = newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n        newActions.push('equal'); // Reset stored elements on 'equal'.\n\n        actualSlice = [];\n        expectedSlice = [];\n      }\n\n      counter[action]++;\n    }\n\n    return newActions.concat(diff(actualSlice, expectedSlice, areSimilar).map(x => x === 'equal' ? 'replace' : x));\n  }\n  /**\n   * Marks text nodes to be synchronized.\n   *\n   * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n   *\n   * @private\n   * @param {module:engine/view/node~Node} viewNode View node to sync.\n   */\n\n\n  _markDescendantTextToSync(viewNode) {\n    if (!viewNode) {\n      return;\n    }\n\n    if (viewNode.is('text')) {\n      this.markedTexts.add(viewNode);\n    } else if (viewNode.is('element')) {\n      for (const child of viewNode.getChildren()) {\n        this._markDescendantTextToSync(child);\n      }\n    }\n  }\n  /**\n   * Checks if the selection needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n\n\n  _updateSelection() {\n    // If there is no selection - remove DOM and fake selections.\n    if (this.selection.rangeCount === 0) {\n      this._removeDomSelection();\n\n      this._removeFakeSelection();\n\n      return;\n    }\n\n    const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement); // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\n    if (!this.isFocused || !domRoot) {\n      return;\n    } // Render selection.\n\n\n    if (this.selection.isFake) {\n      this._updateFakeSelection(domRoot);\n    } else {\n      this._removeFakeSelection();\n\n      this._updateDomSelection(domRoot);\n    }\n  }\n  /**\n   * Updates the fake selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n   */\n\n\n  _updateFakeSelection(domRoot) {\n    const domDocument = domRoot.ownerDocument;\n    let container = this._fakeSelectionContainer; // Create fake selection container if one does not exist.\n\n    if (!container) {\n      this._fakeSelectionContainer = container = domDocument.createElement('div');\n      Object.assign(container.style, {\n        position: 'fixed',\n        top: 0,\n        left: '-9999px',\n        // See https://github.com/ckeditor/ckeditor5/issues/752.\n        width: '42px'\n      }); // Fill it with a text node so we can update it later.\n\n      container.textContent = '\\u00A0';\n    }\n\n    if (!container.parentElement || container.parentElement != domRoot) {\n      domRoot.appendChild(container);\n    } // Update contents.\n\n\n    container.textContent = this.selection.fakeSelectionLabel || '\\u00A0'; // Update selection.\n\n    const domSelection = domDocument.getSelection();\n    const domRange = domDocument.createRange();\n    domSelection.removeAllRanges();\n    domRange.selectNodeContents(container);\n    domSelection.addRange(domRange); // Bind fake selection container with current selection.\n\n    this.domConverter.bindFakeSelection(container, this.selection);\n  }\n  /**\n   * Updates the DOM selection.\n   *\n   * @private\n   * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n   */\n\n\n  _updateDomSelection(domRoot) {\n    const domSelection = domRoot.ownerDocument.defaultView.getSelection(); // Let's check whether DOM selection needs updating at all.\n\n    if (!this._domSelectionNeedsUpdate(domSelection)) {\n      return;\n    } // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n    // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n    // and focus of view selection.\n    // Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n    // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\n\n    const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);\n    const focus = this.domConverter.viewPositionToDom(this.selection.focus); // Focus the new editing host.\n    // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\n    domRoot.focus();\n    domSelection.collapse(anchor.parent, anchor.offset);\n    domSelection.extend(focus.parent, focus.offset); // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\n    if (env.isGecko) {\n      fixGeckoSelectionAfterBr(focus, domSelection);\n    }\n  }\n  /**\n   * Checks whether a given DOM selection needs to be updated.\n   *\n   * @private\n   * @param {Selection} domSelection The DOM selection to check.\n   * @returns {Boolean}\n   */\n\n\n  _domSelectionNeedsUpdate(domSelection) {\n    if (!this.domConverter.isDomSelectionCorrect(domSelection)) {\n      // Current DOM selection is in incorrect position. We need to update it.\n      return true;\n    }\n\n    const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);\n\n    if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {\n      return false;\n    } // If selection is not collapsed, it does not need to be updated if it is similar.\n\n\n    if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {\n      // Selection did not changed and is correct, do not update.\n      return false;\n    } // Selections are not similar.\n\n\n    return true;\n  }\n  /**\n   * Removes the DOM selection.\n   *\n   * @private\n   */\n\n\n  _removeDomSelection() {\n    for (const doc of this.domDocuments) {\n      const domSelection = doc.getSelection();\n\n      if (domSelection.rangeCount) {\n        const activeDomElement = doc.activeElement;\n        const viewElement = this.domConverter.mapDomToView(activeDomElement);\n\n        if (activeDomElement && viewElement) {\n          doc.getSelection().removeAllRanges();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the fake selection.\n   *\n   * @private\n   */\n\n\n  _removeFakeSelection() {\n    const container = this._fakeSelectionContainer;\n\n    if (container) {\n      container.remove();\n    }\n  }\n  /**\n   * Checks if focus needs to be updated and possibly updates it.\n   *\n   * @private\n   */\n\n\n  _updateFocus() {\n    if (this.isFocused) {\n      const editable = this.selection.editableElement;\n\n      if (editable) {\n        this.domConverter.focus(editable);\n      }\n    }\n  }\n\n}\nmix(Renderer, ObservableMixin); // Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\n\nfunction isEditable(element) {\n  if (element.getAttribute('contenteditable') == 'false') {\n    return false;\n  }\n\n  const parent = element.findAncestor(element => element.hasAttribute('contenteditable'));\n  return !parent || parent.getAttribute('contenteditable') == 'true';\n} // Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\n\n\nfunction addInlineFiller(domDocument, domParentOrArray, offset) {\n  const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n  const nodeAfterFiller = childNodes[offset];\n\n  if (isText(nodeAfterFiller)) {\n    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n    return nodeAfterFiller;\n  } else {\n    const fillerNode = domDocument.createTextNode(INLINE_FILLER);\n\n    if (Array.isArray(domParentOrArray)) {\n      childNodes.splice(offset, 0, fillerNode);\n    } else {\n      insertAt(domParentOrArray, offset, fillerNode);\n    }\n\n    return fillerNode;\n  }\n} // Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction areSimilar(node1, node2) {\n  return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n} // Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {Function} blockFiller Block filler creator function, see {@link module:engine/view/domconverter~DomConverter#blockFiller}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\n\n\nfunction sameNodes(blockFiller, actualDomChild, expectedDomChild) {\n  // Elements.\n  if (actualDomChild === expectedDomChild) {\n    return true;\n  } // Texts.\n  else if (isText(actualDomChild) && isText(expectedDomChild)) {\n      return actualDomChild.data === expectedDomChild.data;\n    } // Block fillers.\n    else if (isBlockFiller(actualDomChild, blockFiller) && isBlockFiller(expectedDomChild, blockFiller)) {\n        return true;\n      } // Not matching types.\n\n\n  return false;\n} // The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\n\n\nfunction fixGeckoSelectionAfterBr(focus, domSelection) {\n  const parent = focus.parent; // This fix works only when the focus point is at the very end of an element.\n  // There is no point in running it in cases unrelated to the browser bug.\n\n  if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {\n    return;\n  }\n\n  const childAtOffset = parent.childNodes[focus.offset]; // To stay on the safe side, the fix being as specific as possible, it targets only the\n  // selection which is at the very end of the element and preceded by <br />.\n\n  if (childAtOffset && childAtOffset.tagName == 'BR') {\n    domSelection.addRange(domSelection.getRangeAt(0));\n  }\n}\n\nfunction filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {\n  const childList = Array.from(domChildList);\n\n  if (childList.length == 0 || !fakeSelectionContainer) {\n    return childList;\n  }\n\n  const last = childList[childList.length - 1];\n\n  if (last == fakeSelectionContainer) {\n    childList.pop();\n  }\n\n  return childList;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js"],"names":["ViewText","ViewPosition","INLINE_FILLER","INLINE_FILLER_LENGTH","startsWithFiller","isInlineFiller","isBlockFiller","mix","diff","insertAt","remove","ObservableMixin","CKEditorError","isText","isNode","fastDiff","env","Renderer","constructor","domConverter","selection","domDocuments","Set","markedAttributes","markedChildren","markedTexts","isFocused","_inlineFiller","_fakeSelectionContainer","markToSync","type","node","mapViewToDom","parent","add","render","inlineFillerPosition","element","_updateChildrenMappings","_isSelectionInInlineFiller","_removeInlineFiller","_getInlineFillerPosition","_needsInlineFillerAtSelection","getFirstPosition","_updateAttrs","_updateChildren","has","_updateText","fillerDomPosition","viewPositionToDom","domDocument","ownerDocument","addInlineFiller","offset","_updateSelection","_updateFocus","clear","viewElement","domElement","actualDomChildren","childNodes","expectedDomChildren","Array","from","viewChildrenToDom","withChildren","_diffNodeLists","actions","_findReplaceActions","indexOf","counter","equal","insert","delete","action","insertIndex","deleteIndex","viewChild","getChild","is","_updateElementMappings","unbindDomElement","bindElements","firstPos","_createBefore","rangeCount","isCollapsed","selectionPosition","position","domFillerNode","parentNode","removeChild","data","substr","selectionParent","selectionOffset","root","isEditable","getFillerOffset","nodeBefore","nodeAfter","viewText","options","domText","findCorrespondingDomText","newDomText","viewToDom","actualText","expectedText","filler","index","insertData","values","join","deleteData","howMany","domAttrKeys","attributes","map","attr","name","viewAttrKeys","getAttributeKeys","key","setAttribute","getAttribute","hasAttribute","removeAttribute","bind","i","nodesToUnbind","_markDescendantTextToSync","domToView","filterOutFakeSelectionContainer","sameNodes","blockFiller","actualDom","expectedDom","newActions","actualSlice","expectedSlice","push","concat","areSimilar","x","viewNode","child","getChildren","_removeDomSelection","_removeFakeSelection","domRoot","editableElement","isFake","_updateFakeSelection","_updateDomSelection","container","createElement","Object","assign","style","top","left","width","textContent","parentElement","appendChild","fakeSelectionLabel","domSelection","getSelection","domRange","createRange","removeAllRanges","selectNodeContents","addRange","bindFakeSelection","defaultView","_domSelectionNeedsUpdate","anchor","focus","collapse","extend","isGecko","fixGeckoSelectionAfterBr","isDomSelectionCorrect","oldViewSelection","domSelectionToView","isEqual","isSimilar","doc","activeDomElement","activeElement","mapDomToView","editable","findAncestor","domParentOrArray","nodeAfterFiller","fillerNode","createTextNode","isArray","splice","node1","node2","tagName","toLowerCase","actualDomChild","expectedDomChild","nodeType","Node","ELEMENT_NODE","length","childAtOffset","getRangeAt","domChildList","fakeSelectionContainer","childList","last","pop"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* globals Node */\n\n/**\n * @module engine/view/renderer\n */\n\nimport ViewText from './text';\nimport ViewPosition from './position';\nimport { INLINE_FILLER, INLINE_FILLER_LENGTH, startsWithFiller, isInlineFiller, isBlockFiller } from './filler';\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport diff from '@ckeditor/ckeditor5-utils/src/diff';\nimport insertAt from '@ckeditor/ckeditor5-utils/src/dom/insertat';\nimport remove from '@ckeditor/ckeditor5-utils/src/dom/remove';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport isNode from '@ckeditor/ckeditor5-utils/src/dom/isnode';\nimport fastDiff from '@ckeditor/ckeditor5-utils/src/fastdiff';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\n/**\n * Renderer is responsible for updating the DOM structure and the DOM selection based on\n * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.\n * In other words, it renders the view to the DOM.\n *\n * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many\n * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring\n * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are\n * affected as little as possible.\n *\n * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions\n * to and from the DOM.\n */\nexport default class Renderer {\n\t/**\n\t * Creates a renderer instance.\n\t *\n\t * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.\n\t * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.\n\t */\n\tconstructor( domConverter, selection ) {\n\t\t/**\n\t\t * Set of DOM Documents instances.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<Document>}\n\t\t */\n\t\tthis.domDocuments = new Set();\n\n\t\t/**\n\t\t * Converter instance.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/domconverter~DomConverter}\n\t\t */\n\t\tthis.domConverter = domConverter;\n\n\t\t/**\n\t\t * Set of nodes which attributes changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedAttributes = new Set();\n\n\t\t/**\n\t\t * Set of elements which child lists changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedChildren = new Set();\n\n\t\t/**\n\t\t * Set of text nodes which text data changed and may need to be rendered.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set.<module:engine/view/node~Node>}\n\t\t */\n\t\tthis.markedTexts = new Set();\n\n\t\t/**\n\t\t * View selection. Renderer updates DOM selection based on the view selection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/documentselection~DocumentSelection}\n\t\t */\n\t\tthis.selection = selection;\n\n\t\t/**\n\t\t * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if\n\t\t * this is set to `false`.\n\t\t *\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.isFocused = false;\n\n\t\t/**\n\t\t * The text node in which the inline filler was rendered.\n\t\t *\n\t\t * @private\n\t\t * @member {Text}\n\t\t */\n\t\tthis._inlineFiller = null;\n\n\t\t/**\n\t\t * DOM element containing fake selection.\n\t\t *\n\t\t * @private\n\t\t * @type {null|HTMLElement}\n\t\t */\n\t\tthis._fakeSelectionContainer = null;\n\t}\n\n\t/**\n\t * Marks a view node to be updated in the DOM by {@link #render `render()`}.\n\t *\n\t * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.\n\t *\n\t * @see #markedAttributes\n\t * @see #markedChildren\n\t * @see #markedTexts\n\t *\n\t * @param {module:engine/view/document~ChangeType} type Type of the change.\n\t * @param {module:engine/view/node~Node} node Node to be marked.\n\t */\n\tmarkToSync( type, node ) {\n\t\tif ( type === 'text' ) {\n\t\t\tif ( this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis.markedTexts.add( node );\n\t\t\t}\n\t\t} else {\n\t\t\t// If the node has no DOM element it is not rendered yet,\n\t\t\t// its children/attributes do not need to be marked to be sync.\n\t\t\tif ( !this.domConverter.mapViewToDom( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( type === 'attributes' ) {\n\t\t\t\tthis.markedAttributes.add( node );\n\t\t\t} else if ( type === 'children' ) {\n\t\t\t\tthis.markedChildren.add( node );\n\t\t\t} else {\n\t\t\t\t/**\n\t\t\t\t * Unknown type passed to Renderer.markToSync.\n\t\t\t\t *\n\t\t\t\t * @error renderer-unknown-type\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError( 'view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.', this );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and\n\t * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.\n\t *\n\t * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,\n\t * so it does as little as it is needed to update the DOM.\n\t *\n\t * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed\n\t * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be\n\t * removed as long as the selection is in the text node which needed it at first.\n\t */\n\trender() {\n\t\tlet inlineFillerPosition;\n\n\t\t// Refresh mappings.\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildrenMappings( element );\n\t\t}\n\n\t\t// There was inline filler rendered in the DOM but it's not\n\t\t// at the selection position any more, so we can remove it\n\t\t// (cause even if it's needed, it must be placed in another location).\n\t\tif ( this._inlineFiller && !this._isSelectionInInlineFiller() ) {\n\t\t\tthis._removeInlineFiller();\n\t\t}\n\n\t\t// If we've got the filler, let's try to guess its position in the view.\n\t\tif ( this._inlineFiller ) {\n\t\t\tinlineFillerPosition = this._getInlineFillerPosition();\n\t\t}\n\t\t// Otherwise, if it's needed, create it at the selection position.\n\t\telse if ( this._needsInlineFillerAtSelection() ) {\n\t\t\tinlineFillerPosition = this.selection.getFirstPosition();\n\n\t\t\t// Do not use `markToSync` so it will be added even if the parent is already added.\n\t\t\tthis.markedChildren.add( inlineFillerPosition.parent );\n\t\t}\n\n\t\tfor ( const element of this.markedAttributes ) {\n\t\t\tthis._updateAttrs( element );\n\t\t}\n\n\t\tfor ( const element of this.markedChildren ) {\n\t\t\tthis._updateChildren( element, { inlineFillerPosition } );\n\t\t}\n\n\t\tfor ( const node of this.markedTexts ) {\n\t\t\tif ( !this.markedChildren.has( node.parent ) && this.domConverter.mapViewToDom( node.parent ) ) {\n\t\t\t\tthis._updateText( node, { inlineFillerPosition } );\n\t\t\t}\n\t\t}\n\n\t\t// Check whether the inline filler is required and where it really is in the DOM.\n\t\t// At this point in most cases it will be in the DOM, but there are exceptions.\n\t\t// For example, if the inline filler was deep in the created DOM structure, it will not be created.\n\t\t// Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,\n\t\t// it will not be present.\n\t\t// Fix those and similar scenarios.\n\t\tif ( inlineFillerPosition ) {\n\t\t\tconst fillerDomPosition = this.domConverter.viewPositionToDom( inlineFillerPosition );\n\t\t\tconst domDocument = fillerDomPosition.parent.ownerDocument;\n\n\t\t\tif ( !startsWithFiller( fillerDomPosition.parent ) ) {\n\t\t\t\t// Filler has not been created at filler position. Create it now.\n\t\t\t\tthis._inlineFiller = addInlineFiller( domDocument, fillerDomPosition.parent, fillerDomPosition.offset );\n\t\t\t} else {\n\t\t\t\t// Filler has been found, save it.\n\t\t\t\tthis._inlineFiller = fillerDomPosition.parent;\n\t\t\t}\n\t\t} else {\n\t\t\t// There is no filler needed.\n\t\t\tthis._inlineFiller = null;\n\t\t}\n\n\t\tthis._updateSelection();\n\t\tthis._updateFocus();\n\n\t\tthis.markedTexts.clear();\n\t\tthis.markedAttributes.clear();\n\t\tthis.markedChildren.clear();\n\t}\n\n\t/**\n\t * Updates mappings of view element's children.\n\t *\n\t * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.\n\t * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.\n\t * Thanks to that these elements do not need to be re-rendered completely.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.\n\t */\n\t_updateChildrenMappings( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.\n\t\t\treturn;\n\t\t}\n\n\t\tconst actualDomChildren = this.domConverter.mapViewToDom( viewElement ).childNodes;\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { withChildren: false } )\n\t\t);\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\t\tconst actions = this._findReplaceActions( diff, actualDomChildren, expectedDomChildren );\n\n\t\tif ( actions.indexOf( 'replace' ) !== -1 ) {\n\t\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'replace' ) {\n\t\t\t\t\tconst insertIndex = counter.equal + counter.insert;\n\t\t\t\t\tconst deleteIndex = counter.equal + counter.delete;\n\t\t\t\t\tconst viewChild = viewElement.getChild( insertIndex );\n\n\t\t\t\t\t// The 'uiElement' is a special one and its children are not stored in a view (#799),\n\t\t\t\t\t// so we cannot use it with replacing flow (since it uses view children during rendering\n\t\t\t\t\t// which will always result in rendering empty element).\n\t\t\t\t\tif ( viewChild && !viewChild.is( 'uiElement' ) ) {\n\t\t\t\t\t\tthis._updateElementMappings( viewChild, actualDomChildren[ deleteIndex ] );\n\t\t\t\t\t}\n\n\t\t\t\t\tremove( expectedDomChildren[ insertIndex ] );\n\t\t\t\t\tcounter.equal++;\n\t\t\t\t} else {\n\t\t\t\t\tcounter[ action ]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates mappings of a given view element.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.\n\t * @param {Node} domElement The DOM element representing the given view element.\n\t */\n\t_updateElementMappings( viewElement, domElement ) {\n\t\t// Remap 'DomConverter' bindings.\n\t\tthis.domConverter.unbindDomElement( domElement );\n\t\tthis.domConverter.bindElements( domElement, viewElement );\n\n\t\t// View element may have children which needs to be updated, but are not marked, mark them to update.\n\t\tthis.markedChildren.add( viewElement );\n\n\t\t// Because we replace new view element mapping with the existing one, the corresponding DOM element\n\t\t// will not be rerendered. The new view element may have different attributes than the previous one.\n\t\t// Since its corresponding DOM element will not be rerendered, new attributes will not be added\n\t\t// to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more\n\t\t// detailed case study.\n\t\t// Also there are cases where replaced element is removed from the view structure and then has\n\t\t// its attributes changed or removed. In such cases the element will not be present in `markedAttributes`\n\t\t// and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.\n\t\t// To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).\n\t\tthis.markedAttributes.add( viewElement );\n\t}\n\n\t/**\n\t * Gets the position of the inline filler based on the current selection.\n\t * Here, we assume that we know that the filler is needed and\n\t * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,\n\t * it is somewhere at the selection position.\n\t *\n\t * Note: The filler position cannot be restored based on the filler's DOM text node, because\n\t * when this method is called (before rendering), the bindings will often be broken. View-to-DOM\n\t * bindings are only dependable after rendering.\n\t *\n\t * @private\n\t * @returns {module:engine/view/position~Position}\n\t */\n\t_getInlineFillerPosition() {\n\t\tconst firstPos = this.selection.getFirstPosition();\n\n\t\tif ( firstPos.parent.is( 'text' ) ) {\n\t\t\treturn ViewPosition._createBefore( this.selection.getFirstPosition().parent );\n\t\t} else {\n\t\t\treturn firstPos;\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` if the selection has not left the inline filler's text node.\n\t * If it is `true`, it means that the filler had been added for a reason and the selection did not\n\t * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler and selection are in the same place.\n\t */\n\t_isSelectionInInlineFiller() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Note, we can't check if selection's position equals position of the\n\t\t// this._inlineFiller node, because of #663. We may not be able to calculate\n\t\t// the filler's position in the view at this stage.\n\t\t// Instead, we check it the other way – whether selection is anchored in\n\t\t// that text node or next to it.\n\n\t\t// Possible options are:\n\t\t// \"FILLER{}\"\n\t\t// \"FILLERadded-text{}\"\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst position = this.domConverter.viewPositionToDom( selectionPosition );\n\n\t\tif ( position && isText( position.parent ) && startsWithFiller( position.parent ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Removes the inline filler.\n\t *\n\t * @private\n\t */\n\t_removeInlineFiller() {\n\t\tconst domFillerNode = this._inlineFiller;\n\n\t\t// Something weird happened and the stored node doesn't contain the filler's text.\n\t\tif ( !startsWithFiller( domFillerNode ) ) {\n\t\t\t/**\n\t\t\t * The inline filler node was lost. Most likely, something overwrote the filler text node\n\t\t\t * in the DOM.\n\t\t\t *\n\t\t\t * @error view-renderer-filler-was-lost\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-renderer-filler-was-lost: The inline filler node was lost.', this );\n\t\t}\n\n\t\tif ( isInlineFiller( domFillerNode ) ) {\n\t\t\tdomFillerNode.parentNode.removeChild( domFillerNode );\n\t\t} else {\n\t\t\tdomFillerNode.data = domFillerNode.data.substr( INLINE_FILLER_LENGTH );\n\t\t}\n\n\t\tthis._inlineFiller = null;\n\t}\n\n\t/**\n\t * Checks if the inline {@link module:engine/view/filler filler} should be added.\n\t *\n\t * @private\n\t * @returns {Boolean} `true` if the inline filler should be added.\n\t */\n\t_needsInlineFillerAtSelection() {\n\t\tif ( this.selection.rangeCount != 1 || !this.selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst selectionPosition = this.selection.getFirstPosition();\n\t\tconst selectionParent = selectionPosition.parent;\n\t\tconst selectionOffset = selectionPosition.offset;\n\n\t\t// If there is no DOM root we do not care about fillers.\n\t\tif ( !this.domConverter.mapViewToDom( selectionParent.root ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !( selectionParent.is( 'element' ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Prevent adding inline filler inside elements with contenteditable=false.\n\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/1170\n\t\tif ( !isEditable( selectionParent ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We have block filler, we do not need inline one.\n\t\tif ( selectionOffset === selectionParent.getFillerOffset() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst nodeBefore = selectionPosition.nodeBefore;\n\t\tconst nodeAfter = selectionPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText || nodeAfter instanceof ViewText ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if text needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} viewText View text to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateText( viewText, options ) {\n\t\tconst domText = this.domConverter.findCorrespondingDomText( viewText );\n\t\tconst newDomText = this.domConverter.viewToDom( viewText, domText.ownerDocument );\n\n\t\tconst actualText = domText.data;\n\t\tlet expectedText = newDomText.data;\n\n\t\tconst filler = options.inlineFillerPosition;\n\n\t\tif ( filler && filler.parent == viewText.parent && filler.offset == viewText.index ) {\n\t\t\texpectedText = INLINE_FILLER + expectedText;\n\t\t}\n\n\t\tif ( actualText != expectedText ) {\n\t\t\tconst actions = fastDiff( actualText, expectedText );\n\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action.type === 'insert' ) {\n\t\t\t\t\tdomText.insertData( action.index, action.values.join( '' ) );\n\t\t\t\t} else { // 'delete'\n\t\t\t\t\tdomText.deleteData( action.index, action.howMany );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if attribute list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement The view element to update.\n\t */\n\t_updateAttrs( viewElement ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated\n\t\t\t// in 'this._updateChildrenMappings()'. There is no need to process it as new view element which\n\t\t\t// replaced old 'viewElement' mapping was also added to 'this.markedAttributes'\n\t\t\t// in 'this._updateChildrenMappings()' so it will be processed separately.\n\t\t\treturn;\n\t\t}\n\n\t\tconst domAttrKeys = Array.from( domElement.attributes ).map( attr => attr.name );\n\t\tconst viewAttrKeys = viewElement.getAttributeKeys();\n\n\t\t// Add or overwrite attributes.\n\t\tfor ( const key of viewAttrKeys ) {\n\t\t\tdomElement.setAttribute( key, viewElement.getAttribute( key ) );\n\t\t}\n\n\t\t// Remove from DOM attributes which do not exists in the view.\n\t\tfor ( const key of domAttrKeys ) {\n\t\t\tif ( !viewElement.hasAttribute( key ) ) {\n\t\t\t\tdomElement.removeAttribute( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if elements child list needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewElement View element to update.\n\t * @param {Object} options\n\t * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline\n\t * filler should be rendered.\n\t */\n\t_updateChildren( viewElement, options ) {\n\t\tconst domElement = this.domConverter.mapViewToDom( viewElement );\n\n\t\tif ( !domElement ) {\n\t\t\t// If there is no `domElement` it means that it was already removed from DOM.\n\t\t\t// There is no need to process it. It will be processed when re-inserted.\n\t\t\treturn;\n\t\t}\n\n\t\tconst inlineFillerPosition = options.inlineFillerPosition;\n\t\tconst actualDomChildren = this.domConverter.mapViewToDom( viewElement ).childNodes;\n\t\tconst expectedDomChildren = Array.from(\n\t\t\tthis.domConverter.viewChildrenToDom( viewElement, domElement.ownerDocument, { bind: true, inlineFillerPosition } )\n\t\t);\n\n\t\t// Inline filler element has to be created as it is present in the DOM, but not in the view. It is required\n\t\t// during diffing so text nodes could be compared correctly and also during rendering to maintain\n\t\t// proper order and indexes while updating the DOM.\n\t\tif ( inlineFillerPosition && inlineFillerPosition.parent === viewElement ) {\n\t\t\taddInlineFiller( domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset );\n\t\t}\n\n\t\tconst diff = this._diffNodeLists( actualDomChildren, expectedDomChildren );\n\n\t\tlet i = 0;\n\t\tconst nodesToUnbind = new Set();\n\n\t\tfor ( const action of diff ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\tinsertAt( domElement, i, expectedDomChildren[ i ] );\n\t\t\t\ti++;\n\t\t\t} else if ( action === 'delete' ) {\n\t\t\t\tnodesToUnbind.add( actualDomChildren[ i ] );\n\t\t\t\tremove( actualDomChildren[ i ] );\n\t\t\t} else { // 'equal'\n\t\t\t\t// Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).\n\t\t\t\tthis._markDescendantTextToSync( this.domConverter.domToView( expectedDomChildren[ i ] ) );\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t// Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during\n\t\t// comparision with the expected DOM. We don't need to check child nodes, because if child node was reinserted,\n\t\t// it was moved to DOM tree out of the removed node.\n\t\tfor ( const node of nodesToUnbind ) {\n\t\t\tif ( !node.parentNode ) {\n\t\t\t\tthis.domConverter.unbindDomElement( node );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Shorthand for diffing two arrays or node lists of DOM nodes.\n\t *\n\t * @private\n\t * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children\n\t * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.\n\t * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.\n\t */\n\t_diffNodeLists( actualDomChildren, expectedDomChildren ) {\n\t\tactualDomChildren = filterOutFakeSelectionContainer( actualDomChildren, this._fakeSelectionContainer );\n\n\t\treturn diff( actualDomChildren, expectedDomChildren, sameNodes.bind( null, this.domConverter.blockFiller ) );\n\t}\n\n\t/**\n\t * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared\n\t * within one `insert`/`delete` action group, for example:\n\t *\n\t * \t\tActual DOM:\t\t<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>\n\t * \t\tExpected DOM:\t<p>Bar<b>123</b><i>Baz</i><b>456</b></p>\n\t * \t\tInput actions:\t[ insert, insert, delete, delete, equal, insert, delete ]\n\t * \t\tOutput actions:\t[ insert, replace, delete, equal, replace ]\n\t *\n\t * @private\n\t * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.\n\t * @param {Array.<Node>|NodeList} actualDom Actual DOM children\n\t * @param {Array.<Node>} expectedDom Expected DOM children.\n\t * @returns {Array.<String>} Actions array modified with the `replace` actions.\n\t */\n\t_findReplaceActions( actions, actualDom, expectedDom ) {\n\t\t// If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.\n\t\tif ( actions.indexOf( 'insert' ) === -1 || actions.indexOf( 'delete' ) === -1 ) {\n\t\t\treturn actions;\n\t\t}\n\n\t\tlet newActions = [];\n\t\tlet actualSlice = [];\n\t\tlet expectedSlice = [];\n\n\t\tconst counter = { equal: 0, insert: 0, delete: 0 };\n\n\t\tfor ( const action of actions ) {\n\t\t\tif ( action === 'insert' ) {\n\t\t\t\texpectedSlice.push( expectedDom[ counter.equal + counter.insert ] );\n\t\t\t} else if ( action === 'delete' ) {\n\t\t\t\tactualSlice.push( actualDom[ counter.equal + counter.delete ] );\n\t\t\t} else { // equal\n\t\t\t\tnewActions = newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t\t\t\tnewActions.push( 'equal' );\n\t\t\t\t// Reset stored elements on 'equal'.\n\t\t\t\tactualSlice = [];\n\t\t\t\texpectedSlice = [];\n\t\t\t}\n\t\t\tcounter[ action ]++;\n\t\t}\n\n\t\treturn newActions.concat( diff( actualSlice, expectedSlice, areSimilar ).map( x => x === 'equal' ? 'replace' : x ) );\n\t}\n\n\t/**\n\t * Marks text nodes to be synchronized.\n\t *\n\t * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.\n\t *\n\t * @private\n\t * @param {module:engine/view/node~Node} viewNode View node to sync.\n\t */\n\t_markDescendantTextToSync( viewNode ) {\n\t\tif ( !viewNode ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tthis.markedTexts.add( viewNode );\n\t\t} else if ( viewNode.is( 'element' ) ) {\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tthis._markDescendantTextToSync( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the selection needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateSelection() {\n\t\t// If there is no selection - remove DOM and fake selections.\n\t\tif ( this.selection.rangeCount === 0 ) {\n\t\t\tthis._removeDomSelection();\n\t\t\tthis._removeFakeSelection();\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst domRoot = this.domConverter.mapViewToDom( this.selection.editableElement );\n\n\t\t// Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.\n\t\tif ( !this.isFocused || !domRoot ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Render selection.\n\t\tif ( this.selection.isFake ) {\n\t\t\tthis._updateFakeSelection( domRoot );\n\t\t} else {\n\t\t\tthis._removeFakeSelection();\n\t\t\tthis._updateDomSelection( domRoot );\n\t\t}\n\t}\n\n\t/**\n\t * Updates the fake selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.\n\t */\n\t_updateFakeSelection( domRoot ) {\n\t\tconst domDocument = domRoot.ownerDocument;\n\t\tlet container = this._fakeSelectionContainer;\n\n\t\t// Create fake selection container if one does not exist.\n\t\tif ( !container ) {\n\t\t\tthis._fakeSelectionContainer = container = domDocument.createElement( 'div' );\n\n\t\t\tObject.assign( container.style, {\n\t\t\t\tposition: 'fixed',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: '-9999px',\n\t\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/752.\n\t\t\t\twidth: '42px'\n\t\t\t} );\n\n\t\t\t// Fill it with a text node so we can update it later.\n\t\t\tcontainer.textContent = '\\u00A0';\n\t\t}\n\n\t\tif ( !container.parentElement || container.parentElement != domRoot ) {\n\t\t\tdomRoot.appendChild( container );\n\t\t}\n\n\t\t// Update contents.\n\t\tcontainer.textContent = this.selection.fakeSelectionLabel || '\\u00A0';\n\n\t\t// Update selection.\n\t\tconst domSelection = domDocument.getSelection();\n\t\tconst domRange = domDocument.createRange();\n\n\t\tdomSelection.removeAllRanges();\n\t\tdomRange.selectNodeContents( container );\n\t\tdomSelection.addRange( domRange );\n\n\t\t// Bind fake selection container with current selection.\n\t\tthis.domConverter.bindFakeSelection( container, this.selection );\n\t}\n\n\t/**\n\t * Updates the DOM selection.\n\t *\n\t * @private\n\t * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.\n\t */\n\t_updateDomSelection( domRoot ) {\n\t\tconst domSelection = domRoot.ownerDocument.defaultView.getSelection();\n\n\t\t// Let's check whether DOM selection needs updating at all.\n\t\tif ( !this._domSelectionNeedsUpdate( domSelection ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Multi-range selection is not available in most browsers, and, at least in Chrome, trying to\n\t\t// set such selection, that is not continuous, throws an error. Because of that, we will just use anchor\n\t\t// and focus of view selection.\n\t\t// Since we are not supporting multi-range selection, we also do not need to check if proper editable is\n\t\t// selected. If there is any editable selected, it is okay (editable is taken from selection anchor).\n\t\tconst anchor = this.domConverter.viewPositionToDom( this.selection.anchor );\n\t\tconst focus = this.domConverter.viewPositionToDom( this.selection.focus );\n\n\t\t// Focus the new editing host.\n\t\t// Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).\n\t\tdomRoot.focus();\n\n\t\tdomSelection.collapse( anchor.parent, anchor.offset );\n\t\tdomSelection.extend( focus.parent, focus.offset );\n\n\t\t// Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n\t\tif ( env.isGecko ) {\n\t\t\tfixGeckoSelectionAfterBr( focus, domSelection );\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether a given DOM selection needs to be updated.\n\t *\n\t * @private\n\t * @param {Selection} domSelection The DOM selection to check.\n\t * @returns {Boolean}\n\t */\n\t_domSelectionNeedsUpdate( domSelection ) {\n\t\tif ( !this.domConverter.isDomSelectionCorrect( domSelection ) ) {\n\t\t\t// Current DOM selection is in incorrect position. We need to update it.\n\t\t\treturn true;\n\t\t}\n\n\t\tconst oldViewSelection = domSelection && this.domConverter.domSelectionToView( domSelection );\n\n\t\tif ( oldViewSelection && this.selection.isEqual( oldViewSelection ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If selection is not collapsed, it does not need to be updated if it is similar.\n\t\tif ( !this.selection.isCollapsed && this.selection.isSimilar( oldViewSelection ) ) {\n\t\t\t// Selection did not changed and is correct, do not update.\n\t\t\treturn false;\n\t\t}\n\n\t\t// Selections are not similar.\n\t\treturn true;\n\t}\n\n\t/**\n\t * Removes the DOM selection.\n\t *\n\t * @private\n\t */\n\t_removeDomSelection() {\n\t\tfor ( const doc of this.domDocuments ) {\n\t\t\tconst domSelection = doc.getSelection();\n\n\t\t\tif ( domSelection.rangeCount ) {\n\t\t\t\tconst activeDomElement = doc.activeElement;\n\t\t\t\tconst viewElement = this.domConverter.mapDomToView( activeDomElement );\n\n\t\t\t\tif ( activeDomElement && viewElement ) {\n\t\t\t\t\tdoc.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Removes the fake selection.\n\t *\n\t * @private\n\t */\n\t_removeFakeSelection() {\n\t\tconst container = this._fakeSelectionContainer;\n\n\t\tif ( container ) {\n\t\t\tcontainer.remove();\n\t\t}\n\t}\n\n\t/**\n\t * Checks if focus needs to be updated and possibly updates it.\n\t *\n\t * @private\n\t */\n\t_updateFocus() {\n\t\tif ( this.isFocused ) {\n\t\t\tconst editable = this.selection.editableElement;\n\n\t\t\tif ( editable ) {\n\t\t\t\tthis.domConverter.focus( editable );\n\t\t\t}\n\t\t}\n\t}\n}\n\nmix( Renderer, ObservableMixin );\n\n// Checks if provided element is editable.\n//\n// @private\n// @param {module:engine/view/element~Element} element\n// @returns {Boolean}\nfunction isEditable( element ) {\n\tif ( element.getAttribute( 'contenteditable' ) == 'false' ) {\n\t\treturn false;\n\t}\n\n\tconst parent = element.findAncestor( element => element.hasAttribute( 'contenteditable' ) );\n\n\treturn !parent || parent.getAttribute( 'contenteditable' ) == 'true';\n}\n\n// Adds inline filler at a given position.\n//\n// The position can be given as an array of DOM nodes and an offset in that array,\n// or a DOM parent element and an offset in that element.\n//\n// @private\n// @param {Document} domDocument\n// @param {Element|Array.<Node>} domParentOrArray\n// @param {Number} offset\n// @returns {Text} The DOM text node that contains an inline filler.\nfunction addInlineFiller( domDocument, domParentOrArray, offset ) {\n\tconst childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;\n\tconst nodeAfterFiller = childNodes[ offset ];\n\n\tif ( isText( nodeAfterFiller ) ) {\n\t\tnodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;\n\n\t\treturn nodeAfterFiller;\n\t} else {\n\t\tconst fillerNode = domDocument.createTextNode( INLINE_FILLER );\n\n\t\tif ( Array.isArray( domParentOrArray ) ) {\n\t\t\tchildNodes.splice( offset, 0, fillerNode );\n\t\t} else {\n\t\t\tinsertAt( domParentOrArray, offset, fillerNode );\n\t\t}\n\n\t\treturn fillerNode;\n\t}\n}\n\n// Whether two DOM nodes should be considered as similar.\n// Nodes are considered similar if they have the same tag name.\n//\n// @private\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction areSimilar( node1, node2 ) {\n\treturn isNode( node1 ) && isNode( node2 ) &&\n\t\t!isText( node1 ) && !isText( node2 ) &&\n\t\tnode1.tagName.toLowerCase() === node2.tagName.toLowerCase();\n}\n\n// Whether two dom nodes should be considered as the same.\n// Two nodes which are considered the same are:\n//\n//\t\t* Text nodes with the same text.\n//\t\t* Element nodes represented by the same object.\n//\t\t* Two block filler elements.\n//\n// @private\n// @param {Function} blockFiller Block filler creator function, see {@link module:engine/view/domconverter~DomConverter#blockFiller}.\n// @param {Node} node1\n// @param {Node} node2\n// @returns {Boolean}\nfunction sameNodes( blockFiller, actualDomChild, expectedDomChild ) {\n\t// Elements.\n\tif ( actualDomChild === expectedDomChild ) {\n\t\treturn true;\n\t}\n\t// Texts.\n\telse if ( isText( actualDomChild ) && isText( expectedDomChild ) ) {\n\t\treturn actualDomChild.data === expectedDomChild.data;\n\t}\n\t// Block fillers.\n\telse if ( isBlockFiller( actualDomChild, blockFiller ) &&\n\t\tisBlockFiller( expectedDomChild, blockFiller ) ) {\n\t\treturn true;\n\t}\n\n\t// Not matching types.\n\treturn false;\n}\n\n// The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).\n// When the native DOM selection is at the end of the block and preceded by <br /> e.g.\n//\n//\t\t<p>foo<br/>[]</p>\n//\n// which happens a lot when using the soft line break, the browser fails to (visually) move the\n// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.\nfunction fixGeckoSelectionAfterBr( focus, domSelection ) {\n\tconst parent = focus.parent;\n\n\t// This fix works only when the focus point is at the very end of an element.\n\t// There is no point in running it in cases unrelated to the browser bug.\n\tif ( parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1 ) {\n\t\treturn;\n\t}\n\n\tconst childAtOffset = parent.childNodes[ focus.offset ];\n\n\t// To stay on the safe side, the fix being as specific as possible, it targets only the\n\t// selection which is at the very end of the element and preceded by <br />.\n\tif ( childAtOffset && childAtOffset.tagName == 'BR' ) {\n\t\tdomSelection.addRange( domSelection.getRangeAt( 0 ) );\n\t}\n}\n\nfunction filterOutFakeSelectionContainer( domChildList, fakeSelectionContainer ) {\n\tconst childList = Array.from( domChildList );\n\n\tif ( childList.length == 0 || !fakeSelectionContainer ) {\n\t\treturn childList;\n\t}\n\n\tconst last = childList[ childList.length - 1 ];\n\n\tif ( last == fakeSelectionContainer ) {\n\t\tchildList.pop();\n\t}\n\n\treturn childList;\n}\n"]},"metadata":{},"sourceType":"module"}