{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widget\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\nimport { getCode, keyCodes, parseKeystroke } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport '../theme/widget.css';\nconst selectAllKeystrokeCode = parseKeystroke('Ctrl+A');\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class Widget extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'Widget';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const view = this.editor.editing.view;\n    const viewDocument = view.document;\n    /**\n     * Holds previously selected widgets.\n     *\n     * @private\n     * @type {Set.<module:engine/view/element~Element>}\n     */\n\n    this._previouslySelected = new Set(); // Model to view selection converter.\n    // Converts selection placed over widget element to fake selection\n\n    this.editor.editing.downcastDispatcher.on('selection', (evt, data, conversionApi) => {\n      // Remove selected class from previously selected widgets.\n      this._clearPreviouslySelectedWidgets(conversionApi.writer);\n\n      const viewWriter = conversionApi.writer;\n      const viewSelection = viewWriter.document.selection;\n      const selectedElement = viewSelection.getSelectedElement();\n      let lastMarked = null;\n\n      for (const range of viewSelection.getRanges()) {\n        for (const value of range) {\n          const node = value.item; // Do not mark nested widgets in selected one. See: #57.\n\n          if (isWidget(node) && !isChild(node, lastMarked)) {\n            viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);\n\n            this._previouslySelected.add(node);\n\n            lastMarked = node; // Check if widget is a single element selected.\n\n            if (node == selectedElement) {\n              viewWriter.setSelection(viewSelection.getRanges(), {\n                fake: true,\n                label: getLabel(selectedElement)\n              });\n            }\n          }\n        }\n      }\n    }, {\n      priority: 'low'\n    }); // If mouse down is pressed on widget - create selection over whole widget.\n\n    view.addObserver(MouseObserver);\n    this.listenTo(viewDocument, 'mousedown', (...args) => this._onMousedown(...args)); // Handle custom keydown behaviour.\n\n    this.listenTo(viewDocument, 'keydown', (...args) => this._onKeydown(...args), {\n      priority: 'high'\n    }); // Handle custom delete behaviour.\n\n    this.listenTo(viewDocument, 'delete', (evt, data) => {\n      if (this._handleDelete(data.direction == 'forward')) {\n        data.preventDefault();\n        evt.stop();\n      }\n    }, {\n      priority: 'high'\n    });\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n\n\n  _onMousedown(eventInfo, domEventData) {\n    const editor = this.editor;\n    const view = editor.editing.view;\n    const viewDocument = view.document;\n    let element = domEventData.target; // Do nothing for single or double click inside nested editable.\n\n    if (isInsideNestedEditable(element)) {\n      // But at least triple click inside nested editable causes broken selection in Safari.\n      // For such event, we select the entire nested editable element.\n      // See: https://github.com/ckeditor/ckeditor5/issues/1463.\n      if (env.isSafari && domEventData.domEvent.detail >= 3) {\n        const mapper = editor.editing.mapper;\n        const modelElement = mapper.toModelElement(element);\n        this.editor.model.change(writer => {\n          domEventData.preventDefault();\n          writer.setSelection(modelElement, 'in');\n        });\n      }\n\n      return;\n    } // If target is not a widget element - check if one of the ancestors is.\n\n\n    if (!isWidget(element)) {\n      element = element.findAncestor(isWidget);\n\n      if (!element) {\n        return;\n      }\n    }\n\n    domEventData.preventDefault(); // Focus editor if is not focused already.\n\n    if (!viewDocument.isFocused) {\n      view.focus();\n    } // Create model selection over widget.\n\n\n    const modelElement = editor.editing.mapper.toModelElement(element);\n\n    this._setSelectionOverElement(modelElement);\n  }\n  /**\n   * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.\n   *\n   * @private\n   * @param {module:utils/eventinfo~EventInfo} eventInfo\n   * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n   */\n\n\n  _onKeydown(eventInfo, domEventData) {\n    const keyCode = domEventData.keyCode;\n    const isForward = keyCode == keyCodes.arrowdown || keyCode == keyCodes.arrowright;\n    let wasHandled = false; // Checks if the keys were handled and then prevents the default event behaviour and stops\n    // the propagation.\n\n    if (isArrowKeyCode(keyCode)) {\n      wasHandled = this._handleArrowKeys(isForward);\n    } else if (isSelectAllKeyCode(domEventData)) {\n      wasHandled = this._selectAllNestedEditableContent() || this._selectAllContent();\n    } else if (keyCode === keyCodes.enter) {\n      wasHandled = this._handleEnterKey(domEventData.shiftKey);\n    }\n\n    if (wasHandled) {\n      domEventData.preventDefault();\n      eventInfo.stop();\n    }\n  }\n  /**\n   * Handles delete keys: backspace and delete.\n   *\n   * @private\n   * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n   * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n   */\n\n\n  _handleDelete(isForward) {\n    // Do nothing when the read only mode is enabled.\n    if (this.editor.isReadOnly) {\n      return;\n    }\n\n    const modelDocument = this.editor.model.document;\n    const modelSelection = modelDocument.selection; // Do nothing on non-collapsed selection.\n\n    if (!modelSelection.isCollapsed) {\n      return;\n    }\n\n    const objectElement = this._getObjectElementNextToSelection(isForward);\n\n    if (objectElement) {\n      this.editor.model.change(writer => {\n        let previousNode = modelSelection.anchor.parent; // Remove previous element if empty.\n\n        while (previousNode.isEmpty) {\n          const nodeToRemove = previousNode;\n          previousNode = nodeToRemove.parent;\n          writer.remove(nodeToRemove);\n        }\n\n        this._setSelectionOverElement(objectElement);\n      });\n      return true;\n    }\n  }\n  /**\n   * Handles arrow keys.\n   *\n   * @private\n   * @param {Boolean} isForward Set to true if arrow key should be handled in forward direction.\n   * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n   */\n\n\n  _handleArrowKeys(isForward) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const modelDocument = model.document;\n    const modelSelection = modelDocument.selection;\n    const objectElement = modelSelection.getSelectedElement(); // If object element is selected.\n\n    if (objectElement && schema.isObject(objectElement)) {\n      const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n      const newRange = schema.getNearestSelectionRange(position, isForward ? 'forward' : 'backward');\n\n      if (newRange) {\n        model.change(writer => {\n          writer.setSelection(newRange);\n        });\n      }\n\n      return true;\n    } // If selection is next to object element.\n    // Return if not collapsed.\n\n\n    if (!modelSelection.isCollapsed) {\n      return;\n    }\n\n    const objectElement2 = this._getObjectElementNextToSelection(isForward);\n\n    if (!!objectElement2 && schema.isObject(objectElement2)) {\n      this._setSelectionOverElement(objectElement2);\n\n      return true;\n    }\n  }\n  /**\n   * Handles the enter key, giving users and access to positions in the editable directly before\n   * (<kbd>Shift</kbd>+<kbd>Enter</kbd>) or after (<kbd>Enter</kbd>) the selected widget.\n   * It improves the UX, mainly when the widget is the first or last child of the root editable\n   * and there's no other way to type after or before it.\n   *\n   * @private\n   * @param {Boolean} isBackwards Set to true if the new paragraph is to be inserted before\n   * the selected widget (<kbd>Shift</kbd>+<kbd>Enter</kbd>).\n   * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n   */\n\n\n  _handleEnterKey(isBackwards) {\n    const model = this.editor.model;\n    const modelSelection = model.document.selection;\n    const selectedElement = modelSelection.getSelectedElement();\n\n    if (shouldInsertParagraph(selectedElement, model.schema)) {\n      model.change(writer => {\n        let position = writer.createPositionAt(selectedElement, isBackwards ? 'before' : 'after');\n        const paragraph = writer.createElement('paragraph'); // Split the parent when inside a block element.\n        // https://github.com/ckeditor/ckeditor5/issues/1529\n\n        if (model.schema.isBlock(selectedElement.parent)) {\n          const paragraphLimit = model.schema.findAllowedParent(position, paragraph);\n          position = writer.split(position, paragraphLimit).position;\n        }\n\n        writer.insert(paragraph, position);\n        writer.setSelection(paragraph, 'in');\n      });\n      return true;\n    }\n  }\n  /**\n   * Extends the {@link module:engine/model/selection~Selection document's selection} to span the entire\n   * content of the nested editable if already anchored in one.\n   *\n   * See: {@link module:engine/model/schema~Schema#getLimitElement}.\n   *\n   * @private\n   */\n\n\n  _selectAllNestedEditableContent() {\n    const model = this.editor.model;\n    const documentSelection = model.document.selection;\n    const limitElement = model.schema.getLimitElement(documentSelection);\n\n    if (documentSelection.getFirstRange().root == limitElement) {\n      return false;\n    }\n\n    model.change(writer => {\n      writer.setSelection(writer.createRangeIn(limitElement));\n    });\n    return true;\n  }\n  /**\n   * Handles <kbd>CTRL + A</kbd> when widget is selected.\n   *\n   * @private\n   * @returns {Boolean} Returns true if widget was selected and selecting all was handled by this method.\n   */\n\n\n  _selectAllContent() {\n    const model = this.editor.model;\n    const editing = this.editor.editing;\n    const view = editing.view;\n    const viewDocument = view.document;\n    const viewSelection = viewDocument.selection;\n    const selectedElement = viewSelection.getSelectedElement(); // Only widget is selected.\n    // https://github.com/ckeditor/ckeditor5-widget/issues/23\n\n    if (selectedElement && isWidget(selectedElement)) {\n      const widgetParent = editing.mapper.toModelElement(selectedElement.parent);\n      model.change(writer => {\n        writer.setSelection(writer.createRangeIn(widgetParent));\n      });\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n   *\n   * @private\n   * @param {module:engine/model/element~Element} element\n   */\n\n\n  _setSelectionOverElement(element) {\n    this.editor.model.change(writer => {\n      writer.setSelection(writer.createRangeOn(element));\n    });\n  }\n  /**\n   * Checks if {@link module:engine/model/element~Element element} placed next to the current\n   * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n   * {@link module:engine/model/schema~Schema schema} as `object`.\n   *\n   * @private\n   * @param {Boolean} forward Direction of checking.\n   * @returns {module:engine/model/element~Element|null}\n   */\n\n\n  _getObjectElementNextToSelection(forward) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const modelSelection = model.document.selection; // Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n    // to its current state after undo.\n\n    const probe = model.createSelection(modelSelection);\n    model.modifySelection(probe, {\n      direction: forward ? 'forward' : 'backward'\n    });\n    const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n\n    if (!!objectElement && schema.isObject(objectElement)) {\n      return objectElement;\n    }\n\n    return null;\n  }\n  /**\n   * Removes CSS class from previously selected widgets.\n   *\n   * @private\n   * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n   */\n\n\n  _clearPreviouslySelectedWidgets(writer) {\n    for (const widget of this._previouslySelected) {\n      writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);\n    }\n\n    this._previouslySelected.clear();\n  }\n\n} // Returns 'true' if provided key code represents one of the arrow keys.\n//\n// @param {Number} keyCode\n// @returns {Boolean}\n\nfunction isArrowKeyCode(keyCode) {\n  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;\n} // Returns 'true' if provided (DOM) key event data corresponds with the Ctrl+A keystroke.\n//\n// @param {module:engine/view/observer/keyobserver~KeyEventData} domEventData\n// @returns {Boolean}\n\n\nfunction isSelectAllKeyCode(domEventData) {\n  return getCode(domEventData) == selectAllKeystrokeCode;\n} // Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\n\n\nfunction isInsideNestedEditable(element) {\n  while (element) {\n    if (element.is('editableElement') && !element.is('rootElement')) {\n      return true;\n    } // Click on nested widget should select it.\n\n\n    if (isWidget(element)) {\n      return false;\n    }\n\n    element = element.parent;\n  }\n\n  return false;\n} // Checks whether the specified `element` is a child of the `parent` element.\n//\n// @param {module:engine/view/element~Element} element An element to check.\n// @param {module:engine/view/element~Element|null} parent A parent for the element.\n// @returns {Boolean}\n\n\nfunction isChild(element, parent) {\n  if (!parent) {\n    return false;\n  }\n\n  return Array.from(element.getAncestors()).includes(parent);\n} // Checks if enter key should insert paragraph. This should be done only on elements of type object (excluding inline objects).\n//\n// @param {module:engine/model/element~Element} element And element to check.\n// @param {module:engine/model/schema~Schema} schema\n\n\nfunction shouldInsertParagraph(element, schema) {\n  return element && schema.isObject(element) && !schema.isInline(element);\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-widget/src/widget.js"],"names":["Plugin","MouseObserver","getLabel","isWidget","WIDGET_SELECTED_CLASS_NAME","getCode","keyCodes","parseKeystroke","env","selectAllKeystrokeCode","Widget","pluginName","init","view","editor","editing","viewDocument","document","_previouslySelected","Set","downcastDispatcher","on","evt","data","conversionApi","_clearPreviouslySelectedWidgets","writer","viewWriter","viewSelection","selection","selectedElement","getSelectedElement","lastMarked","range","getRanges","value","node","item","isChild","addClass","add","setSelection","fake","label","priority","addObserver","listenTo","args","_onMousedown","_onKeydown","_handleDelete","direction","preventDefault","stop","eventInfo","domEventData","element","target","isInsideNestedEditable","isSafari","domEvent","detail","mapper","modelElement","toModelElement","model","change","findAncestor","isFocused","focus","_setSelectionOverElement","keyCode","isForward","arrowdown","arrowright","wasHandled","isArrowKeyCode","_handleArrowKeys","isSelectAllKeyCode","_selectAllNestedEditableContent","_selectAllContent","enter","_handleEnterKey","shiftKey","isReadOnly","modelDocument","modelSelection","isCollapsed","objectElement","_getObjectElementNextToSelection","previousNode","anchor","parent","isEmpty","nodeToRemove","remove","schema","isObject","position","getLastPosition","getFirstPosition","newRange","getNearestSelectionRange","objectElement2","isBackwards","shouldInsertParagraph","createPositionAt","paragraph","createElement","isBlock","paragraphLimit","findAllowedParent","split","insert","documentSelection","limitElement","getLimitElement","getFirstRange","root","createRangeIn","widgetParent","createRangeOn","forward","probe","createSelection","modifySelection","nodeBefore","nodeAfter","widget","removeClass","clear","arrowleft","arrowup","is","Array","from","getAncestors","includes","isInline"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/widget\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport MouseObserver from '@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver';\nimport { getLabel, isWidget, WIDGET_SELECTED_CLASS_NAME } from './utils';\nimport { getCode, keyCodes, parseKeystroke } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\nimport '../theme/widget.css';\n\nconst selectAllKeystrokeCode = parseKeystroke( 'Ctrl+A' );\n\n/**\n * The widget plugin. It enables base support for widgets.\n *\n * See {@glink api/widget package page} for more details and documentation.\n *\n * This plugin enables multiple behaviors required by widgets:\n *\n * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).\n * If a converted selection wraps around a widget element, that selection is marked as\n * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class\n * is added to indicate that widget has been selected.\n * * The mouse and keyboard events handling on and around widget elements.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class Widget extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'Widget';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst view = this.editor.editing.view;\n\t\tconst viewDocument = view.document;\n\n\t\t/**\n\t\t * Holds previously selected widgets.\n\t\t *\n\t\t * @private\n\t\t * @type {Set.<module:engine/view/element~Element>}\n\t\t */\n\t\tthis._previouslySelected = new Set();\n\n\t\t// Model to view selection converter.\n\t\t// Converts selection placed over widget element to fake selection\n\t\tthis.editor.editing.downcastDispatcher.on( 'selection', ( evt, data, conversionApi ) => {\n\t\t\t// Remove selected class from previously selected widgets.\n\t\t\tthis._clearPreviouslySelectedWidgets( conversionApi.writer );\n\n\t\t\tconst viewWriter = conversionApi.writer;\n\t\t\tconst viewSelection = viewWriter.document.selection;\n\t\t\tconst selectedElement = viewSelection.getSelectedElement();\n\t\t\tlet lastMarked = null;\n\n\t\t\tfor ( const range of viewSelection.getRanges() ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tconst node = value.item;\n\n\t\t\t\t\t// Do not mark nested widgets in selected one. See: #57.\n\t\t\t\t\tif ( isWidget( node ) && !isChild( node, lastMarked ) ) {\n\t\t\t\t\t\tviewWriter.addClass( WIDGET_SELECTED_CLASS_NAME, node );\n\n\t\t\t\t\t\tthis._previouslySelected.add( node );\n\t\t\t\t\t\tlastMarked = node;\n\n\t\t\t\t\t\t// Check if widget is a single element selected.\n\t\t\t\t\t\tif ( node == selectedElement ) {\n\t\t\t\t\t\t\tviewWriter.setSelection( viewSelection.getRanges(), { fake: true, label: getLabel( selectedElement ) } );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, { priority: 'low' } );\n\n\t\t// If mouse down is pressed on widget - create selection over whole widget.\n\t\tview.addObserver( MouseObserver );\n\t\tthis.listenTo( viewDocument, 'mousedown', ( ...args ) => this._onMousedown( ...args ) );\n\n\t\t// Handle custom keydown behaviour.\n\t\tthis.listenTo( viewDocument, 'keydown', ( ...args ) => this._onKeydown( ...args ), { priority: 'high' } );\n\n\t\t// Handle custom delete behaviour.\n\t\tthis.listenTo( viewDocument, 'delete', ( evt, data ) => {\n\t\t\tif ( this._handleDelete( data.direction == 'forward' ) ) {\n\t\t\t\tdata.preventDefault();\n\t\t\t\tevt.stop();\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onMousedown( eventInfo, domEventData ) {\n\t\tconst editor = this.editor;\n\t\tconst view = editor.editing.view;\n\t\tconst viewDocument = view.document;\n\t\tlet element = domEventData.target;\n\n\t\t// Do nothing for single or double click inside nested editable.\n\t\tif ( isInsideNestedEditable( element ) ) {\n\t\t\t// But at least triple click inside nested editable causes broken selection in Safari.\n\t\t\t// For such event, we select the entire nested editable element.\n\t\t\t// See: https://github.com/ckeditor/ckeditor5/issues/1463.\n\t\t\tif ( env.isSafari && domEventData.domEvent.detail >= 3 ) {\n\t\t\t\tconst mapper = editor.editing.mapper;\n\t\t\t\tconst modelElement = mapper.toModelElement( element );\n\n\t\t\t\tthis.editor.model.change( writer => {\n\t\t\t\t\tdomEventData.preventDefault();\n\t\t\t\t\twriter.setSelection( modelElement, 'in' );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// If target is not a widget element - check if one of the ancestors is.\n\t\tif ( !isWidget( element ) ) {\n\t\t\telement = element.findAncestor( isWidget );\n\n\t\t\tif ( !element ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tdomEventData.preventDefault();\n\n\t\t// Focus editor if is not focused already.\n\t\tif ( !viewDocument.isFocused ) {\n\t\t\tview.focus();\n\t\t}\n\n\t\t// Create model selection over widget.\n\t\tconst modelElement = editor.editing.mapper.toModelElement( element );\n\n\t\tthis._setSelectionOverElement( modelElement );\n\t}\n\n\t/**\n\t * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.\n\t *\n\t * @private\n\t * @param {module:utils/eventinfo~EventInfo} eventInfo\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData\n\t */\n\t_onKeydown( eventInfo, domEventData ) {\n\t\tconst keyCode = domEventData.keyCode;\n\t\tconst isForward = keyCode == keyCodes.arrowdown || keyCode == keyCodes.arrowright;\n\t\tlet wasHandled = false;\n\n\t\t// Checks if the keys were handled and then prevents the default event behaviour and stops\n\t\t// the propagation.\n\t\tif ( isArrowKeyCode( keyCode ) ) {\n\t\t\twasHandled = this._handleArrowKeys( isForward );\n\t\t} else if ( isSelectAllKeyCode( domEventData ) ) {\n\t\t\twasHandled = this._selectAllNestedEditableContent() || this._selectAllContent();\n\t\t} else if ( keyCode === keyCodes.enter ) {\n\t\t\twasHandled = this._handleEnterKey( domEventData.shiftKey );\n\t\t}\n\n\t\tif ( wasHandled ) {\n\t\t\tdomEventData.preventDefault();\n\t\t\teventInfo.stop();\n\t\t}\n\t}\n\n\t/**\n\t * Handles delete keys: backspace and delete.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Set to true if delete was performed in forward direction.\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleDelete( isForward ) {\n\t\t// Do nothing when the read only mode is enabled.\n\t\tif ( this.editor.isReadOnly ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelDocument = this.editor.model.document;\n\t\tconst modelSelection = modelDocument.selection;\n\n\t\t// Do nothing on non-collapsed selection.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst objectElement = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( objectElement ) {\n\t\t\tthis.editor.model.change( writer => {\n\t\t\t\tlet previousNode = modelSelection.anchor.parent;\n\n\t\t\t\t// Remove previous element if empty.\n\t\t\t\twhile ( previousNode.isEmpty ) {\n\t\t\t\t\tconst nodeToRemove = previousNode;\n\t\t\t\t\tpreviousNode = nodeToRemove.parent;\n\n\t\t\t\t\twriter.remove( nodeToRemove );\n\t\t\t\t}\n\n\t\t\t\tthis._setSelectionOverElement( objectElement );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Handles arrow keys.\n\t *\n\t * @private\n\t * @param {Boolean} isForward Set to true if arrow key should be handled in forward direction.\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleArrowKeys( isForward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelDocument = model.document;\n\t\tconst modelSelection = modelDocument.selection;\n\t\tconst objectElement = modelSelection.getSelectedElement();\n\n\t\t// If object element is selected.\n\t\tif ( objectElement && schema.isObject( objectElement ) ) {\n\t\t\tconst position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();\n\t\t\tconst newRange = schema.getNearestSelectionRange( position, isForward ? 'forward' : 'backward' );\n\n\t\t\tif ( newRange ) {\n\t\t\t\tmodel.change( writer => {\n\t\t\t\t\twriter.setSelection( newRange );\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// If selection is next to object element.\n\t\t// Return if not collapsed.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst objectElement2 = this._getObjectElementNextToSelection( isForward );\n\n\t\tif ( !!objectElement2 && schema.isObject( objectElement2 ) ) {\n\t\t\tthis._setSelectionOverElement( objectElement2 );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Handles the enter key, giving users and access to positions in the editable directly before\n\t * (<kbd>Shift</kbd>+<kbd>Enter</kbd>) or after (<kbd>Enter</kbd>) the selected widget.\n\t * It improves the UX, mainly when the widget is the first or last child of the root editable\n\t * and there's no other way to type after or before it.\n\t *\n\t * @private\n\t * @param {Boolean} isBackwards Set to true if the new paragraph is to be inserted before\n\t * the selected widget (<kbd>Shift</kbd>+<kbd>Enter</kbd>).\n\t * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.\n\t */\n\t_handleEnterKey( isBackwards ) {\n\t\tconst model = this.editor.model;\n\t\tconst modelSelection = model.document.selection;\n\t\tconst selectedElement = modelSelection.getSelectedElement();\n\n\t\tif ( shouldInsertParagraph( selectedElement, model.schema ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\tlet position = writer.createPositionAt( selectedElement, isBackwards ? 'before' : 'after' );\n\t\t\t\tconst paragraph = writer.createElement( 'paragraph' );\n\n\t\t\t\t// Split the parent when inside a block element.\n\t\t\t\t// https://github.com/ckeditor/ckeditor5/issues/1529\n\t\t\t\tif ( model.schema.isBlock( selectedElement.parent ) ) {\n\t\t\t\t\tconst paragraphLimit = model.schema.findAllowedParent( position, paragraph );\n\n\t\t\t\t\tposition = writer.split( position, paragraphLimit ).position;\n\t\t\t\t}\n\n\t\t\t\twriter.insert( paragraph, position );\n\t\t\t\twriter.setSelection( paragraph, 'in' );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Extends the {@link module:engine/model/selection~Selection document's selection} to span the entire\n\t * content of the nested editable if already anchored in one.\n\t *\n\t * See: {@link module:engine/model/schema~Schema#getLimitElement}.\n\t *\n\t * @private\n\t */\n\t_selectAllNestedEditableContent() {\n\t\tconst model = this.editor.model;\n\t\tconst documentSelection = model.document.selection;\n\t\tconst limitElement = model.schema.getLimitElement( documentSelection );\n\n\t\tif ( documentSelection.getFirstRange().root == limitElement ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tmodel.change( writer => {\n\t\t\twriter.setSelection( writer.createRangeIn( limitElement ) );\n\t\t} );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Handles <kbd>CTRL + A</kbd> when widget is selected.\n\t *\n\t * @private\n\t * @returns {Boolean} Returns true if widget was selected and selecting all was handled by this method.\n\t */\n\t_selectAllContent() {\n\t\tconst model = this.editor.model;\n\t\tconst editing = this.editor.editing;\n\t\tconst view = editing.view;\n\t\tconst viewDocument = view.document;\n\t\tconst viewSelection = viewDocument.selection;\n\n\t\tconst selectedElement = viewSelection.getSelectedElement();\n\n\t\t// Only widget is selected.\n\t\t// https://github.com/ckeditor/ckeditor5-widget/issues/23\n\t\tif ( selectedElement && isWidget( selectedElement ) ) {\n\t\t\tconst widgetParent = editing.mapper.toModelElement( selectedElement.parent );\n\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( writer.createRangeIn( widgetParent ) );\n\t\t\t} );\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Sets {@link module:engine/model/selection~Selection document's selection} over given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_setSelectionOverElement( element ) {\n\t\tthis.editor.model.change( writer => {\n\t\t\twriter.setSelection( writer.createRangeOn( element ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks if {@link module:engine/model/element~Element element} placed next to the current\n\t * {@link module:engine/model/selection~Selection model selection} exists and is marked in\n\t * {@link module:engine/model/schema~Schema schema} as `object`.\n\t *\n\t * @private\n\t * @param {Boolean} forward Direction of checking.\n\t * @returns {module:engine/model/element~Element|null}\n\t */\n\t_getObjectElementNextToSelection( forward ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst modelSelection = model.document.selection;\n\n\t\t// Clone current selection to use it as a probe. We must leave default selection as it is so it can return\n\t\t// to its current state after undo.\n\t\tconst probe = model.createSelection( modelSelection );\n\t\tmodel.modifySelection( probe, { direction: forward ? 'forward' : 'backward' } );\n\t\tconst objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;\n\n\t\tif ( !!objectElement && schema.isObject( objectElement ) ) {\n\t\t\treturn objectElement;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes CSS class from previously selected widgets.\n\t *\n\t * @private\n\t * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\t */\n\t_clearPreviouslySelectedWidgets( writer ) {\n\t\tfor ( const widget of this._previouslySelected ) {\n\t\t\twriter.removeClass( WIDGET_SELECTED_CLASS_NAME, widget );\n\t\t}\n\n\t\tthis._previouslySelected.clear();\n\t}\n}\n\n// Returns 'true' if provided key code represents one of the arrow keys.\n//\n// @param {Number} keyCode\n// @returns {Boolean}\nfunction isArrowKeyCode( keyCode ) {\n\treturn keyCode == keyCodes.arrowright ||\n\t\tkeyCode == keyCodes.arrowleft ||\n\t\tkeyCode == keyCodes.arrowup ||\n\t\tkeyCode == keyCodes.arrowdown;\n}\n\n// Returns 'true' if provided (DOM) key event data corresponds with the Ctrl+A keystroke.\n//\n// @param {module:engine/view/observer/keyobserver~KeyEventData} domEventData\n// @returns {Boolean}\nfunction isSelectAllKeyCode( domEventData ) {\n\treturn getCode( domEventData ) == selectAllKeystrokeCode;\n}\n\n// Returns `true` when element is a nested editable or is placed inside one.\n//\n// @param {module:engine/view/element~Element}\n// @returns {Boolean}\nfunction isInsideNestedEditable( element ) {\n\twhile ( element ) {\n\t\tif ( element.is( 'editableElement' ) && !element.is( 'rootElement' ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Click on nested widget should select it.\n\t\tif ( isWidget( element ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\telement = element.parent;\n\t}\n\n\treturn false;\n}\n\n// Checks whether the specified `element` is a child of the `parent` element.\n//\n// @param {module:engine/view/element~Element} element An element to check.\n// @param {module:engine/view/element~Element|null} parent A parent for the element.\n// @returns {Boolean}\nfunction isChild( element, parent ) {\n\tif ( !parent ) {\n\t\treturn false;\n\t}\n\n\treturn Array.from( element.getAncestors() ).includes( parent );\n}\n\n// Checks if enter key should insert paragraph. This should be done only on elements of type object (excluding inline objects).\n//\n// @param {module:engine/model/element~Element} element And element to check.\n// @param {module:engine/model/schema~Schema} schema\nfunction shouldInsertParagraph( element, schema ) {\n\treturn element && schema.isObject( element ) && !schema.isInline( element );\n}\n"]},"metadata":{},"sourceType":"module"}