{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-cell-content-post-fixer\n */\n\n/**\n * Injects a table cell post-fixer into the model.\n *\n * The role of the table post-fixer is to ensure that the table cells have the correct content\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * A table cells must contains at least one block as a child. The empty table cell will have empty `<paragraph>` as a child.\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * Will be fixed to:\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph></paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableCellContentPostFixer(model) {\n  model.document.registerPostFixer(writer => tableCellContentsPostFixer(writer, model));\n} // The table cell contents post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction tableCellContentsPostFixer(writer, model) {\n  const changes = model.document.differ.getChanges();\n  let wasFixed = false;\n\n  for (const entry of changes) {\n    // Enforce paragraph in tableCell even after other feature remove its contents.\n    if (entry.type == 'remove' && entry.position.parent.is('tableCell')) {\n      wasFixed = fixTableCellContent(entry.position.parent, writer) || wasFixed;\n    } // Analyze table cells on insertion.\n\n\n    if (entry.type == 'insert') {\n      if (entry.name == 'table') {\n        wasFixed = fixTable(entry.position.nodeAfter, writer) || wasFixed;\n      }\n\n      if (entry.name == 'tableRow') {\n        wasFixed = fixTableRow(entry.position.nodeAfter, writer) || wasFixed;\n      }\n\n      if (entry.name == 'tableCell') {\n        wasFixed = fixTableCellContent(entry.position.nodeAfter, writer) || wasFixed;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Fixes all table cells in a table.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction fixTable(table, writer) {\n  let wasFixed = false;\n\n  for (const row of table.getChildren()) {\n    wasFixed = fixTableRow(row, writer) || wasFixed;\n  }\n\n  return wasFixed;\n} // Fixes all table cells in a table row.\n//\n// @param {module:engine/model/element~Element} tableRow\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction fixTableRow(tableRow, writer) {\n  let wasFixed = false;\n\n  for (const tableCell of tableRow.getChildren()) {\n    wasFixed = fixTableCellContent(tableCell, writer) || wasFixed;\n  }\n\n  return wasFixed;\n} // Fixes all table cell content by:\n// - adding paragraph to a table cell without any child.\n// - wrapping direct $text in <paragraph>.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean}\n\n\nfunction fixTableCellContent(tableCell, writer) {\n  // Insert paragraph to an empty table cell.\n  if (tableCell.childCount == 0) {\n    writer.insertElement('paragraph', tableCell);\n    return true;\n  } // Check table cell children for directly placed $text nodes.\n  // Temporary solution. See https://github.com/ckeditor/ckeditor5/issues/1464.\n\n\n  const textNodes = Array.from(tableCell.getChildren()).filter(child => child.is('text'));\n\n  for (const child of textNodes) {\n    writer.wrap(writer.createRangeOn(child), 'paragraph');\n  } // Return true when there were text nodes to fix.\n\n\n  return !!textNodes.length;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-content-post-fixer.js"],"names":["injectTableCellContentPostFixer","model","document","registerPostFixer","writer","tableCellContentsPostFixer","changes","differ","getChanges","wasFixed","entry","type","position","parent","is","fixTableCellContent","name","fixTable","nodeAfter","fixTableRow","table","row","getChildren","tableRow","tableCell","childCount","insertElement","textNodes","Array","from","filter","child","wrap","createRangeOn","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-cell-content-post-fixer\n */\n\n/**\n * Injects a table cell post-fixer into the model.\n *\n * The role of the table post-fixer is to ensure that the table cells have the correct content\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * A table cells must contains at least one block as a child. The empty table cell will have empty `<paragraph>` as a child.\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * Will be fixed to:\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph></paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableCellContentPostFixer( model ) {\n\tmodel.document.registerPostFixer( writer => tableCellContentsPostFixer( writer, model ) );\n}\n\n// The table cell contents post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction tableCellContentsPostFixer( writer, model ) {\n\tconst changes = model.document.differ.getChanges();\n\n\tlet wasFixed = false;\n\n\tfor ( const entry of changes ) {\n\t\t// Enforce paragraph in tableCell even after other feature remove its contents.\n\t\tif ( entry.type == 'remove' && entry.position.parent.is( 'tableCell' ) ) {\n\t\t\twasFixed = fixTableCellContent( entry.position.parent, writer ) || wasFixed;\n\t\t}\n\n\t\t// Analyze table cells on insertion.\n\t\tif ( entry.type == 'insert' ) {\n\t\t\tif ( entry.name == 'table' ) {\n\t\t\t\twasFixed = fixTable( entry.position.nodeAfter, writer ) || wasFixed;\n\t\t\t}\n\n\t\t\tif ( entry.name == 'tableRow' ) {\n\t\t\t\twasFixed = fixTableRow( entry.position.nodeAfter, writer ) || wasFixed;\n\t\t\t}\n\n\t\t\tif ( entry.name == 'tableCell' ) {\n\t\t\t\twasFixed = fixTableCellContent( entry.position.nodeAfter, writer ) || wasFixed;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Fixes all table cells in a table.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\nfunction fixTable( table, writer ) {\n\tlet wasFixed = false;\n\n\tfor ( const row of table.getChildren() ) {\n\t\twasFixed = fixTableRow( row, writer ) || wasFixed;\n\t}\n\n\treturn wasFixed;\n}\n\n// Fixes all table cells in a table row.\n//\n// @param {module:engine/model/element~Element} tableRow\n// @param {module:engine/model/writer~Writer} writer\nfunction fixTableRow( tableRow, writer ) {\n\tlet wasFixed = false;\n\n\tfor ( const tableCell of tableRow.getChildren() ) {\n\t\twasFixed = fixTableCellContent( tableCell, writer ) || wasFixed;\n\t}\n\n\treturn wasFixed;\n}\n\n// Fixes all table cell content by:\n// - adding paragraph to a table cell without any child.\n// - wrapping direct $text in <paragraph>.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean}\nfunction fixTableCellContent( tableCell, writer ) {\n\t// Insert paragraph to an empty table cell.\n\tif ( tableCell.childCount == 0 ) {\n\t\twriter.insertElement( 'paragraph', tableCell );\n\n\t\treturn true;\n\t}\n\n\t// Check table cell children for directly placed $text nodes.\n\t// Temporary solution. See https://github.com/ckeditor/ckeditor5/issues/1464.\n\tconst textNodes = Array.from( tableCell.getChildren() ).filter( child => child.is( 'text' ) );\n\n\tfor ( const child of textNodes ) {\n\t\twriter.wrap( writer.createRangeOn( child ), 'paragraph' );\n\t}\n\n\t// Return true when there were text nodes to fix.\n\treturn !!textNodes.length;\n}\n"]},"metadata":{},"sourceType":"module"}