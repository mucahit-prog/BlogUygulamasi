{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/downcast\n */\nimport TableWalker from './../tablewalker';\nimport { toWidgetEditable } from '@ckeditor/ckeditor5-widget/src/utils';\nimport { toTableWidget } from '../utils';\n/**\n * Model table element to view table element conversion helper.\n *\n * This conversion helper creates the whole table element with child elements.\n *\n * @param {Object} options\n * @param {Boolean} options.asWidget If set to `true`, the downcast conversion will produce a widget.\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertTable(options = {}) {\n  return dispatcher => dispatcher.on('insert:table', (evt, data, conversionApi) => {\n    const table = data.item;\n\n    if (!conversionApi.consumable.consume(table, 'insert')) {\n      return;\n    } // Consume attributes if present to not fire attribute change downcast\n\n\n    conversionApi.consumable.consume(table, 'attribute:headingRows:table');\n    conversionApi.consumable.consume(table, 'attribute:headingColumns:table');\n    const asWidget = options && options.asWidget;\n    const figureElement = conversionApi.writer.createContainerElement('figure', {\n      class: 'table'\n    });\n    const tableElement = conversionApi.writer.createContainerElement('table');\n    conversionApi.writer.insert(conversionApi.writer.createPositionAt(figureElement, 0), tableElement);\n    let tableWidget;\n\n    if (asWidget) {\n      tableWidget = toTableWidget(figureElement, conversionApi.writer);\n    }\n\n    const tableWalker = new TableWalker(table);\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    }; // Cache for created table rows.\n\n    const viewRows = new Map();\n\n    for (const tableWalkerValue of tableWalker) {\n      const {\n        row,\n        cell\n      } = tableWalkerValue;\n      const tableSection = getOrCreateTableSection(getSectionName(row, tableAttributes), tableElement, conversionApi);\n      const tableRow = table.getChild(row);\n      const trElement = viewRows.get(row) || createTr(tableRow, row, tableSection, conversionApi);\n      viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole table at once.\n\n      conversionApi.consumable.consume(cell, 'insert');\n      const insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');\n      createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options);\n    }\n\n    const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    conversionApi.mapper.bindElements(table, asWidget ? tableWidget : figureElement);\n    conversionApi.writer.insert(viewPosition, asWidget ? tableWidget : figureElement);\n  });\n}\n/**\n * Model row element to view `<tr>` element conversion helper.\n *\n * This conversion helper creates the whole `<tr>` element with child elements.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertRow(options = {}) {\n  return dispatcher => dispatcher.on('insert:tableRow', (evt, data, conversionApi) => {\n    const tableRow = data.item;\n\n    if (!conversionApi.consumable.consume(tableRow, 'insert')) {\n      return;\n    }\n\n    const table = tableRow.parent;\n    const figureElement = conversionApi.mapper.toViewElement(table);\n    const tableElement = getViewTable(figureElement);\n    const row = table.getChildIndex(tableRow);\n    const tableWalker = new TableWalker(table, {\n      startRow: row,\n      endRow: row\n    });\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    }; // Cache for created table rows.\n\n    const viewRows = new Map();\n\n    for (const tableWalkerValue of tableWalker) {\n      const tableSection = getOrCreateTableSection(getSectionName(row, tableAttributes), tableElement, conversionApi);\n      const trElement = viewRows.get(row) || createTr(tableRow, row, tableSection, conversionApi);\n      viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole row at once.\n\n      conversionApi.consumable.consume(tableWalkerValue.cell, 'insert');\n      const insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');\n      createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options);\n    }\n  });\n}\n/**\n * Model table cell element to view `<td>` or `<th>` element conversion helper.\n *\n * This conversion helper will create proper `<th>` elements for table cells that are in the heading section (heading row or column)\n * and `<td>` otherwise.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastInsertCell(options = {}) {\n  return dispatcher => dispatcher.on('insert:tableCell', (evt, data, conversionApi) => {\n    const tableCell = data.item;\n\n    if (!conversionApi.consumable.consume(tableCell, 'insert')) {\n      return;\n    }\n\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const rowIndex = table.getChildIndex(tableRow);\n    const tableWalker = new TableWalker(table, {\n      startRow: rowIndex,\n      endRow: rowIndex\n    });\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    }; // We need to iterate over a table in order to get proper row & column values from a walker\n\n    for (const tableWalkerValue of tableWalker) {\n      if (tableWalkerValue.cell === tableCell) {\n        const trElement = conversionApi.mapper.toViewElement(tableRow);\n        const insertPosition = conversionApi.writer.createPositionAt(trElement, tableRow.getChildIndex(tableCell));\n        createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options); // No need to iterate further.\n\n        return;\n      }\n    }\n  });\n}\n/**\n * Conversion helper that acts on heading rows table attribute change.\n *\n * This converter will:\n *\n * * Rename `<td>` to `<th>` elements or vice versa depending on headings.\n * * Create `<thead>` or `<tbody>` elements if needed.\n * * Remove empty `<thead>` or `<tbody>` if needed.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastTableHeadingRowsChange(options = {}) {\n  const asWidget = !!options.asWidget;\n  return dispatcher => dispatcher.on('attribute:headingRows:table', (evt, data, conversionApi) => {\n    const table = data.item;\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const figureElement = conversionApi.mapper.toViewElement(table);\n    const viewTable = getViewTable(figureElement);\n    const oldRows = data.attributeOldValue;\n    const newRows = data.attributeNewValue; // The head section has grown so move rows from <tbody> to <thead>.\n\n    if (newRows > oldRows) {\n      // Filter out only those rows that are in wrong section.\n      const rowsToMove = Array.from(table.getChildren()).filter(({\n        index\n      }) => isBetween(index, oldRows - 1, newRows));\n      const viewTableHead = getOrCreateTableSection('thead', viewTable, conversionApi);\n      moveViewRowsToTableSection(rowsToMove, viewTableHead, conversionApi, 'end'); // Rename all table cells from moved rows to 'th' as they lands in <thead>.\n\n      for (const tableRow of rowsToMove) {\n        for (const tableCell of tableRow.getChildren()) {\n          renameViewTableCell(tableCell, 'th', conversionApi, asWidget);\n        }\n      } // Cleanup: this will remove any empty section from the view which may happen when moving all rows from a table section.\n\n\n      removeTableSectionIfEmpty('tbody', viewTable, conversionApi);\n    } // The head section has shrunk so move rows from <thead> to <tbody>.\n    else {\n        // Filter out only those rows that are in wrong section.\n        const rowsToMove = Array.from(table.getChildren()).filter(({\n          index\n        }) => isBetween(index, newRows - 1, oldRows)).reverse(); // The rows will be moved from <thead> to <tbody> in reverse order at the beginning of a <tbody>.\n\n        const viewTableBody = getOrCreateTableSection('tbody', viewTable, conversionApi);\n        moveViewRowsToTableSection(rowsToMove, viewTableBody, conversionApi, 0); // Check if cells moved from <thead> to <tbody> requires renaming to <td> as this depends on current heading columns attribute.\n\n        const tableWalker = new TableWalker(table, {\n          startRow: newRows ? newRows - 1 : newRows,\n          endRow: oldRows - 1\n        });\n        const tableAttributes = {\n          headingRows: table.getAttribute('headingRows') || 0,\n          headingColumns: table.getAttribute('headingColumns') || 0\n        };\n\n        for (const tableWalkerValue of tableWalker) {\n          renameViewTableCellIfRequired(tableWalkerValue, tableAttributes, conversionApi, asWidget);\n        } // Cleanup: this will remove any empty section from the view which may happen when moving all rows from a table section.\n\n\n        removeTableSectionIfEmpty('thead', viewTable, conversionApi);\n      }\n\n    function isBetween(index, lower, upper) {\n      return index > lower && index < upper;\n    }\n  });\n}\n/**\n * Conversion helper that acts on heading columns table attribute change.\n *\n * Depending on changed attributes this converter will rename `<td` to `<th>` elements or vice versa depending of the cell column index.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastTableHeadingColumnsChange(options = {}) {\n  const asWidget = !!options.asWidget;\n  return dispatcher => dispatcher.on('attribute:headingColumns:table', (evt, data, conversionApi) => {\n    const table = data.item;\n\n    if (!conversionApi.consumable.consume(data.item, evt.name)) {\n      return;\n    }\n\n    const tableAttributes = {\n      headingRows: table.getAttribute('headingRows') || 0,\n      headingColumns: table.getAttribute('headingColumns') || 0\n    };\n    const oldColumns = data.attributeOldValue;\n    const newColumns = data.attributeNewValue;\n    const lastColumnToCheck = (oldColumns > newColumns ? oldColumns : newColumns) - 1;\n\n    for (const tableWalkerValue of new TableWalker(table)) {\n      // Skip cells that were not in heading section before and after the change.\n      if (tableWalkerValue.column > lastColumnToCheck) {\n        continue;\n      }\n\n      renameViewTableCellIfRequired(tableWalkerValue, tableAttributes, conversionApi, asWidget);\n    }\n  });\n}\n/**\n * Conversion helper that acts on a removed row.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport function downcastRemoveRow() {\n  return dispatcher => dispatcher.on('remove:tableRow', (evt, data, conversionApi) => {\n    // Prevent default remove converter.\n    evt.stop();\n    const viewWriter = conversionApi.writer;\n    const mapper = conversionApi.mapper;\n    const viewStart = mapper.toViewPosition(data.position).getLastMatchingPosition(value => !value.item.is('tr'));\n    const viewItem = viewStart.nodeAfter;\n    const tableSection = viewItem.parent; // Remove associated <tr> from the view.\n\n    const removeRange = viewWriter.createRangeOn(viewItem);\n    const removed = viewWriter.remove(removeRange);\n\n    for (const child of viewWriter.createRangeIn(removed).getItems()) {\n      mapper.unbindViewElement(child);\n    } // Check if table section has any children left - if not remove it from the view.\n\n\n    if (!tableSection.childCount) {\n      // No need to unbind anything as table section is not represented in the model.\n      viewWriter.remove(viewWriter.createRangeOn(tableSection));\n    }\n  }, {\n    priority: 'higher'\n  });\n} // Renames an existing table cell in the view to a given element name.\n//\n// **Note** This method will not do anything if a view table cell was not yet converted.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} desiredCellElementName\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Boolean} asWidget\n\nfunction renameViewTableCell(tableCell, desiredCellElementName, conversionApi, asWidget) {\n  const viewWriter = conversionApi.writer;\n  const viewCell = conversionApi.mapper.toViewElement(tableCell); // View cell might be not yet converted - skip it as it will be properly created by cell converter later on.\n\n  if (!viewCell) {\n    return;\n  }\n\n  let renamedCell;\n\n  if (asWidget) {\n    const editable = viewWriter.createEditableElement(desiredCellElementName, viewCell.getAttributes());\n    renamedCell = toWidgetEditable(editable, viewWriter);\n    viewWriter.insert(viewWriter.createPositionAfter(viewCell), renamedCell);\n    viewWriter.move(viewWriter.createRangeIn(viewCell), viewWriter.createPositionAt(renamedCell, 0));\n    viewWriter.remove(viewWriter.createRangeOn(viewCell));\n  } else {\n    renamedCell = viewWriter.rename(desiredCellElementName, viewCell);\n  }\n\n  conversionApi.mapper.bindElements(tableCell, renamedCell);\n} // Renames a table cell element in the view according to its location in the table.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Boolean} asWidget\n\n\nfunction renameViewTableCellIfRequired(tableWalkerValue, tableAttributes, conversionApi, asWidget) {\n  const {\n    cell\n  } = tableWalkerValue; // Check whether current columnIndex is overlapped by table cells from previous rows.\n\n  const desiredCellElementName = getCellElementName(tableWalkerValue, tableAttributes);\n  const viewCell = conversionApi.mapper.toViewElement(cell); // If in single change we're converting attribute changes and inserting cell the table cell might not be inserted into view\n  // because of child conversion is done after parent.\n\n  if (viewCell && viewCell.name !== desiredCellElementName) {\n    renameViewTableCell(cell, desiredCellElementName, conversionApi, asWidget);\n  }\n} // Creates a table cell element in the view.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {module:engine/view/position~Position} insertPosition\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction createViewTableCellElement(tableWalkerValue, tableAttributes, insertPosition, conversionApi, options) {\n  const asWidget = options && options.asWidget;\n  const cellElementName = getCellElementName(tableWalkerValue, tableAttributes);\n  const cellElement = asWidget ? toWidgetEditable(conversionApi.writer.createEditableElement(cellElementName), conversionApi.writer) : conversionApi.writer.createContainerElement(cellElementName);\n  const tableCell = tableWalkerValue.cell;\n  const firstChild = tableCell.getChild(0);\n  const isSingleParagraph = tableCell.childCount === 1 && firstChild.name === 'paragraph';\n  conversionApi.writer.insert(insertPosition, cellElement);\n\n  if (isSingleParagraph && !hasAnyAttribute(firstChild)) {\n    const innerParagraph = tableCell.getChild(0);\n    const paragraphInsertPosition = conversionApi.writer.createPositionAt(cellElement, 'end');\n    conversionApi.consumable.consume(innerParagraph, 'insert');\n\n    if (options.asWidget) {\n      const fakeParagraph = conversionApi.writer.createContainerElement('span');\n      conversionApi.mapper.bindElements(innerParagraph, fakeParagraph);\n      conversionApi.writer.insert(paragraphInsertPosition, fakeParagraph);\n      conversionApi.mapper.bindElements(tableCell, cellElement);\n    } else {\n      conversionApi.mapper.bindElements(tableCell, cellElement);\n      conversionApi.mapper.bindElements(innerParagraph, cellElement);\n    }\n  } else {\n    conversionApi.mapper.bindElements(tableCell, cellElement);\n  }\n} // Creates `<tr>` view element.\n//\n// @param {module:engine/view/element~Element} tableRow\n// @param {Number} rowIndex\n// @param {module:engine/view/element~Element} tableSection\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/element~Element}\n\n\nfunction createTr(tableRow, rowIndex, tableSection, conversionApi) {\n  // Will always consume since we're converting <tableRow> element from a parent <table>.\n  conversionApi.consumable.consume(tableRow, 'insert');\n  const trElement = conversionApi.writer.createContainerElement('tr');\n  conversionApi.mapper.bindElements(tableRow, trElement);\n  const headingRows = tableRow.parent.getAttribute('headingRows') || 0;\n  const offset = headingRows > 0 && rowIndex >= headingRows ? rowIndex - headingRows : rowIndex;\n  const position = conversionApi.writer.createPositionAt(tableSection, offset);\n  conversionApi.writer.insert(position, trElement);\n  return trElement;\n} // Returns `th` for heading cells and `td` for other cells for the current table walker value.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\n\n\nfunction getCellElementName(tableWalkerValue, tableAttributes) {\n  const {\n    row,\n    column\n  } = tableWalkerValue;\n  const {\n    headingColumns,\n    headingRows\n  } = tableAttributes; // Column heading are all tableCells in the first `columnHeading` rows.\n\n  const isColumnHeading = headingRows && headingRows > row; // So a whole row gets <th> element.\n\n  if (isColumnHeading) {\n    return 'th';\n  } // Row heading are tableCells which columnIndex is lower then headingColumns.\n\n\n  const isRowHeading = headingColumns && headingColumns > column;\n  return isRowHeading ? 'th' : 'td';\n} // Returns the table section name for the current table walker value.\n//\n// @param {Number} row\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\n\n\nfunction getSectionName(row, tableAttributes) {\n  return row < tableAttributes.headingRows ? 'thead' : 'tbody';\n} // Creates or returns an existing `<tbody>` or `<thead>` element witch caching.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} viewTable\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} cachedTableSection An object that stores cached elements.\n// @returns {module:engine/view/containerelement~ContainerElement}\n\n\nfunction getOrCreateTableSection(sectionName, viewTable, conversionApi) {\n  const viewTableSection = getExistingTableSectionElement(sectionName, viewTable);\n  return viewTableSection ? viewTableSection : createTableSection(sectionName, viewTable, conversionApi);\n} // Finds an existing `<tbody>` or `<thead>` element or returns undefined.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction getExistingTableSectionElement(sectionName, tableElement) {\n  for (const tableSection of tableElement.getChildren()) {\n    if (tableSection.name == sectionName) {\n      return tableSection;\n    }\n  }\n} // Creates a table section at the end of the table.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/containerelement~ContainerElement}\n\n\nfunction createTableSection(sectionName, tableElement, conversionApi) {\n  const tableChildElement = conversionApi.writer.createContainerElement(sectionName);\n  const insertPosition = conversionApi.writer.createPositionAt(tableElement, sectionName == 'tbody' ? 'end' : 0);\n  conversionApi.writer.insert(insertPosition, tableChildElement);\n  return tableChildElement;\n} // Removes an existing `<tbody>` or `<thead>` element if it is empty.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n\n\nfunction removeTableSectionIfEmpty(sectionName, tableElement, conversionApi) {\n  const tableSection = getExistingTableSectionElement(sectionName, tableElement);\n\n  if (tableSection && tableSection.childCount === 0) {\n    conversionApi.writer.remove(conversionApi.writer.createRangeOn(tableSection));\n  }\n} // Moves view table rows associated with passed model rows to the provided table section element.\n//\n// **Note** This method will skip not converted table rows.\n//\n// @param {Array.<module:engine/model/element~Element>} rowsToMove\n// @param {module:engine/view/element~Element} viewTableSection\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Number|'end'|'before'|'after'} offset Offset or one of the flags.\n\n\nfunction moveViewRowsToTableSection(rowsToMove, viewTableSection, conversionApi, offset) {\n  for (const tableRow of rowsToMove) {\n    const viewTableRow = conversionApi.mapper.toViewElement(tableRow); // View table row might be not yet converted - skip it as it will be properly created by cell converter later on.\n\n    if (viewTableRow) {\n      conversionApi.writer.move(conversionApi.writer.createRangeOn(viewTableRow), conversionApi.writer.createPositionAt(viewTableSection, offset));\n    }\n  }\n} // Properly finds '<table>' element inside `<figure>` widget.\n//\n// @param {module:engine/view/element~Element} viewFigure\n\n\nfunction getViewTable(viewFigure) {\n  for (const child of viewFigure.getChildren()) {\n    if (child.name === 'table') {\n      return child;\n    }\n  }\n} // Checks if element has any attribute set.\n//\n// @param {module:engine/model/element~Element element\n// @returns {Boolean}\n\n\nfunction hasAnyAttribute(element) {\n  return !![...element.getAttributeKeys()].length;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-table/src/converters/downcast.js"],"names":["TableWalker","toWidgetEditable","toTableWidget","downcastInsertTable","options","dispatcher","on","evt","data","conversionApi","table","item","consumable","consume","asWidget","figureElement","writer","createContainerElement","class","tableElement","insert","createPositionAt","tableWidget","tableWalker","tableAttributes","headingRows","getAttribute","headingColumns","viewRows","Map","tableWalkerValue","row","cell","tableSection","getOrCreateTableSection","getSectionName","tableRow","getChild","trElement","get","createTr","set","insertPosition","createViewTableCellElement","viewPosition","mapper","toViewPosition","range","start","bindElements","downcastInsertRow","parent","toViewElement","getViewTable","getChildIndex","startRow","endRow","downcastInsertCell","tableCell","rowIndex","downcastTableHeadingRowsChange","name","viewTable","oldRows","attributeOldValue","newRows","attributeNewValue","rowsToMove","Array","from","getChildren","filter","index","isBetween","viewTableHead","moveViewRowsToTableSection","renameViewTableCell","removeTableSectionIfEmpty","reverse","viewTableBody","renameViewTableCellIfRequired","lower","upper","downcastTableHeadingColumnsChange","oldColumns","newColumns","lastColumnToCheck","column","downcastRemoveRow","stop","viewWriter","viewStart","position","getLastMatchingPosition","value","is","viewItem","nodeAfter","removeRange","createRangeOn","removed","remove","child","createRangeIn","getItems","unbindViewElement","childCount","priority","desiredCellElementName","viewCell","renamedCell","editable","createEditableElement","getAttributes","createPositionAfter","move","rename","getCellElementName","cellElementName","cellElement","firstChild","isSingleParagraph","hasAnyAttribute","innerParagraph","paragraphInsertPosition","fakeParagraph","offset","isColumnHeading","isRowHeading","sectionName","viewTableSection","getExistingTableSectionElement","createTableSection","tableChildElement","viewTableRow","viewFigure","element","getAttributeKeys","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/downcast\n */\n\nimport TableWalker from './../tablewalker';\nimport { toWidgetEditable } from '@ckeditor/ckeditor5-widget/src/utils';\nimport { toTableWidget } from '../utils';\n\n/**\n * Model table element to view table element conversion helper.\n *\n * This conversion helper creates the whole table element with child elements.\n *\n * @param {Object} options\n * @param {Boolean} options.asWidget If set to `true`, the downcast conversion will produce a widget.\n * @returns {Function} Conversion helper.\n */\nexport function downcastInsertTable( options = {} ) {\n\treturn dispatcher => dispatcher.on( 'insert:table', ( evt, data, conversionApi ) => {\n\t\tconst table = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( table, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Consume attributes if present to not fire attribute change downcast\n\t\tconversionApi.consumable.consume( table, 'attribute:headingRows:table' );\n\t\tconversionApi.consumable.consume( table, 'attribute:headingColumns:table' );\n\n\t\tconst asWidget = options && options.asWidget;\n\n\t\tconst figureElement = conversionApi.writer.createContainerElement( 'figure', { class: 'table' } );\n\t\tconst tableElement = conversionApi.writer.createContainerElement( 'table' );\n\t\tconversionApi.writer.insert( conversionApi.writer.createPositionAt( figureElement, 0 ), tableElement );\n\n\t\tlet tableWidget;\n\n\t\tif ( asWidget ) {\n\t\t\ttableWidget = toTableWidget( figureElement, conversionApi.writer );\n\t\t}\n\n\t\tconst tableWalker = new TableWalker( table );\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\t// Cache for created table rows.\n\t\tconst viewRows = new Map();\n\n\t\tfor ( const tableWalkerValue of tableWalker ) {\n\t\t\tconst { row, cell } = tableWalkerValue;\n\n\t\t\tconst tableSection = getOrCreateTableSection( getSectionName( row, tableAttributes ), tableElement, conversionApi );\n\t\t\tconst tableRow = table.getChild( row );\n\n\t\t\tconst trElement = viewRows.get( row ) || createTr( tableRow, row, tableSection, conversionApi );\n\t\t\tviewRows.set( row, trElement );\n\n\t\t\t// Consume table cell - it will be always consumed as we convert whole table at once.\n\t\t\tconversionApi.consumable.consume( cell, 'insert' );\n\n\t\t\tconst insertPosition = conversionApi.writer.createPositionAt( trElement, 'end' );\n\n\t\t\tcreateViewTableCellElement( tableWalkerValue, tableAttributes, insertPosition, conversionApi, options );\n\t\t}\n\n\t\tconst viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconversionApi.mapper.bindElements( table, asWidget ? tableWidget : figureElement );\n\t\tconversionApi.writer.insert( viewPosition, asWidget ? tableWidget : figureElement );\n\t} );\n}\n\n/**\n * Model row element to view `<tr>` element conversion helper.\n *\n * This conversion helper creates the whole `<tr>` element with child elements.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastInsertRow( options = {} ) {\n\treturn dispatcher => dispatcher.on( 'insert:tableRow', ( evt, data, conversionApi ) => {\n\t\tconst tableRow = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( tableRow, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst table = tableRow.parent;\n\n\t\tconst figureElement = conversionApi.mapper.toViewElement( table );\n\t\tconst tableElement = getViewTable( figureElement );\n\n\t\tconst row = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { startRow: row, endRow: row } );\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\t// Cache for created table rows.\n\t\tconst viewRows = new Map();\n\n\t\tfor ( const tableWalkerValue of tableWalker ) {\n\t\t\tconst tableSection = getOrCreateTableSection( getSectionName( row, tableAttributes ), tableElement, conversionApi );\n\n\t\t\tconst trElement = viewRows.get( row ) || createTr( tableRow, row, tableSection, conversionApi );\n\t\t\tviewRows.set( row, trElement );\n\n\t\t\t// Consume table cell - it will be always consumed as we convert whole row at once.\n\t\t\tconversionApi.consumable.consume( tableWalkerValue.cell, 'insert' );\n\n\t\t\tconst insertPosition = conversionApi.writer.createPositionAt( trElement, 'end' );\n\n\t\t\tcreateViewTableCellElement( tableWalkerValue, tableAttributes, insertPosition, conversionApi, options );\n\t\t}\n\t} );\n}\n\n/**\n * Model table cell element to view `<td>` or `<th>` element conversion helper.\n *\n * This conversion helper will create proper `<th>` elements for table cells that are in the heading section (heading row or column)\n * and `<td>` otherwise.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastInsertCell( options = {} ) {\n\treturn dispatcher => dispatcher.on( 'insert:tableCell', ( evt, data, conversionApi ) => {\n\t\tconst tableCell = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( tableCell, 'insert' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\t\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { startRow: rowIndex, endRow: rowIndex } );\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\t// We need to iterate over a table in order to get proper row & column values from a walker\n\t\tfor ( const tableWalkerValue of tableWalker ) {\n\t\t\tif ( tableWalkerValue.cell === tableCell ) {\n\t\t\t\tconst trElement = conversionApi.mapper.toViewElement( tableRow );\n\t\t\t\tconst insertPosition = conversionApi.writer.createPositionAt( trElement, tableRow.getChildIndex( tableCell ) );\n\n\t\t\t\tcreateViewTableCellElement( tableWalkerValue, tableAttributes, insertPosition, conversionApi, options );\n\n\t\t\t\t// No need to iterate further.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t} );\n}\n\n/**\n * Conversion helper that acts on heading rows table attribute change.\n *\n * This converter will:\n *\n * * Rename `<td>` to `<th>` elements or vice versa depending on headings.\n * * Create `<thead>` or `<tbody>` elements if needed.\n * * Remove empty `<thead>` or `<tbody>` if needed.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastTableHeadingRowsChange( options = {} ) {\n\tconst asWidget = !!options.asWidget;\n\n\treturn dispatcher => dispatcher.on( 'attribute:headingRows:table', ( evt, data, conversionApi ) => {\n\t\tconst table = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst figureElement = conversionApi.mapper.toViewElement( table );\n\t\tconst viewTable = getViewTable( figureElement );\n\n\t\tconst oldRows = data.attributeOldValue;\n\t\tconst newRows = data.attributeNewValue;\n\n\t\t// The head section has grown so move rows from <tbody> to <thead>.\n\t\tif ( newRows > oldRows ) {\n\t\t\t// Filter out only those rows that are in wrong section.\n\t\t\tconst rowsToMove = Array.from( table.getChildren() ).filter( ( { index } ) => isBetween( index, oldRows - 1, newRows ) );\n\n\t\t\tconst viewTableHead = getOrCreateTableSection( 'thead', viewTable, conversionApi );\n\t\t\tmoveViewRowsToTableSection( rowsToMove, viewTableHead, conversionApi, 'end' );\n\n\t\t\t// Rename all table cells from moved rows to 'th' as they lands in <thead>.\n\t\t\tfor ( const tableRow of rowsToMove ) {\n\t\t\t\tfor ( const tableCell of tableRow.getChildren() ) {\n\t\t\t\t\trenameViewTableCell( tableCell, 'th', conversionApi, asWidget );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cleanup: this will remove any empty section from the view which may happen when moving all rows from a table section.\n\t\t\tremoveTableSectionIfEmpty( 'tbody', viewTable, conversionApi );\n\t\t}\n\t\t// The head section has shrunk so move rows from <thead> to <tbody>.\n\t\telse {\n\t\t\t// Filter out only those rows that are in wrong section.\n\t\t\tconst rowsToMove = Array.from( table.getChildren() )\n\t\t\t\t.filter( ( { index } ) => isBetween( index, newRows - 1, oldRows ) )\n\t\t\t\t.reverse(); // The rows will be moved from <thead> to <tbody> in reverse order at the beginning of a <tbody>.\n\n\t\t\tconst viewTableBody = getOrCreateTableSection( 'tbody', viewTable, conversionApi );\n\t\t\tmoveViewRowsToTableSection( rowsToMove, viewTableBody, conversionApi, 0 );\n\n\t\t\t// Check if cells moved from <thead> to <tbody> requires renaming to <td> as this depends on current heading columns attribute.\n\t\t\tconst tableWalker = new TableWalker( table, { startRow: newRows ? newRows - 1 : newRows, endRow: oldRows - 1 } );\n\n\t\t\tconst tableAttributes = {\n\t\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t\t};\n\n\t\t\tfor ( const tableWalkerValue of tableWalker ) {\n\t\t\t\trenameViewTableCellIfRequired( tableWalkerValue, tableAttributes, conversionApi, asWidget );\n\t\t\t}\n\n\t\t\t// Cleanup: this will remove any empty section from the view which may happen when moving all rows from a table section.\n\t\t\tremoveTableSectionIfEmpty( 'thead', viewTable, conversionApi );\n\t\t}\n\n\t\tfunction isBetween( index, lower, upper ) {\n\t\t\treturn index > lower && index < upper;\n\t\t}\n\t} );\n}\n\n/**\n * Conversion helper that acts on heading columns table attribute change.\n *\n * Depending on changed attributes this converter will rename `<td` to `<th>` elements or vice versa depending of the cell column index.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastTableHeadingColumnsChange( options = {} ) {\n\tconst asWidget = !!options.asWidget;\n\n\treturn dispatcher => dispatcher.on( 'attribute:headingColumns:table', ( evt, data, conversionApi ) => {\n\t\tconst table = data.item;\n\n\t\tif ( !conversionApi.consumable.consume( data.item, evt.name ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tableAttributes = {\n\t\t\theadingRows: table.getAttribute( 'headingRows' ) || 0,\n\t\t\theadingColumns: table.getAttribute( 'headingColumns' ) || 0\n\t\t};\n\n\t\tconst oldColumns = data.attributeOldValue;\n\t\tconst newColumns = data.attributeNewValue;\n\n\t\tconst lastColumnToCheck = ( oldColumns > newColumns ? oldColumns : newColumns ) - 1;\n\n\t\tfor ( const tableWalkerValue of new TableWalker( table ) ) {\n\t\t\t// Skip cells that were not in heading section before and after the change.\n\t\t\tif ( tableWalkerValue.column > lastColumnToCheck ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trenameViewTableCellIfRequired( tableWalkerValue, tableAttributes, conversionApi, asWidget );\n\t\t}\n\t} );\n}\n\n/**\n * Conversion helper that acts on a removed row.\n *\n * @returns {Function} Conversion helper.\n */\nexport function downcastRemoveRow() {\n\treturn dispatcher => dispatcher.on( 'remove:tableRow', ( evt, data, conversionApi ) => {\n\t\t// Prevent default remove converter.\n\t\tevt.stop();\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst mapper = conversionApi.mapper;\n\n\t\tconst viewStart = mapper.toViewPosition( data.position ).getLastMatchingPosition( value => !value.item.is( 'tr' ) );\n\t\tconst viewItem = viewStart.nodeAfter;\n\t\tconst tableSection = viewItem.parent;\n\n\t\t// Remove associated <tr> from the view.\n\t\tconst removeRange = viewWriter.createRangeOn( viewItem );\n\t\tconst removed = viewWriter.remove( removeRange );\n\n\t\tfor ( const child of viewWriter.createRangeIn( removed ).getItems() ) {\n\t\t\tmapper.unbindViewElement( child );\n\t\t}\n\n\t\t// Check if table section has any children left - if not remove it from the view.\n\t\tif ( !tableSection.childCount ) {\n\t\t\t// No need to unbind anything as table section is not represented in the model.\n\t\t\tviewWriter.remove( viewWriter.createRangeOn( tableSection ) );\n\t\t}\n\t}, { priority: 'higher' } );\n}\n\n// Renames an existing table cell in the view to a given element name.\n//\n// **Note** This method will not do anything if a view table cell was not yet converted.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} desiredCellElementName\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Boolean} asWidget\nfunction renameViewTableCell( tableCell, desiredCellElementName, conversionApi, asWidget ) {\n\tconst viewWriter = conversionApi.writer;\n\tconst viewCell = conversionApi.mapper.toViewElement( tableCell );\n\n\t// View cell might be not yet converted - skip it as it will be properly created by cell converter later on.\n\tif ( !viewCell ) {\n\t\treturn;\n\t}\n\n\tlet renamedCell;\n\n\tif ( asWidget ) {\n\t\tconst editable = viewWriter.createEditableElement( desiredCellElementName, viewCell.getAttributes() );\n\t\trenamedCell = toWidgetEditable( editable, viewWriter );\n\n\t\tviewWriter.insert( viewWriter.createPositionAfter( viewCell ), renamedCell );\n\t\tviewWriter.move( viewWriter.createRangeIn( viewCell ), viewWriter.createPositionAt( renamedCell, 0 ) );\n\t\tviewWriter.remove( viewWriter.createRangeOn( viewCell ) );\n\t} else {\n\t\trenamedCell = viewWriter.rename( desiredCellElementName, viewCell );\n\t}\n\n\tconversionApi.mapper.bindElements( tableCell, renamedCell );\n}\n\n// Renames a table cell element in the view according to its location in the table.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {{headingColumns, headingRows}} tableAttributes\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Boolean} asWidget\nfunction renameViewTableCellIfRequired( tableWalkerValue, tableAttributes, conversionApi, asWidget ) {\n\tconst { cell } = tableWalkerValue;\n\n\t// Check whether current columnIndex is overlapped by table cells from previous rows.\n\tconst desiredCellElementName = getCellElementName( tableWalkerValue, tableAttributes );\n\n\tconst viewCell = conversionApi.mapper.toViewElement( cell );\n\n\t// If in single change we're converting attribute changes and inserting cell the table cell might not be inserted into view\n\t// because of child conversion is done after parent.\n\tif ( viewCell && viewCell.name !== desiredCellElementName ) {\n\t\trenameViewTableCell( cell, desiredCellElementName, conversionApi, asWidget );\n\t}\n}\n\n// Creates a table cell element in the view.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {module:engine/view/position~Position} insertPosition\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction createViewTableCellElement( tableWalkerValue, tableAttributes, insertPosition, conversionApi, options ) {\n\tconst asWidget = options && options.asWidget;\n\tconst cellElementName = getCellElementName( tableWalkerValue, tableAttributes );\n\n\tconst cellElement = asWidget ?\n\t\ttoWidgetEditable( conversionApi.writer.createEditableElement( cellElementName ), conversionApi.writer ) :\n\t\tconversionApi.writer.createContainerElement( cellElementName );\n\n\tconst tableCell = tableWalkerValue.cell;\n\n\tconst firstChild = tableCell.getChild( 0 );\n\tconst isSingleParagraph = tableCell.childCount === 1 && firstChild.name === 'paragraph';\n\n\tconversionApi.writer.insert( insertPosition, cellElement );\n\n\tif ( isSingleParagraph && !hasAnyAttribute( firstChild ) ) {\n\t\tconst innerParagraph = tableCell.getChild( 0 );\n\t\tconst paragraphInsertPosition = conversionApi.writer.createPositionAt( cellElement, 'end' );\n\n\t\tconversionApi.consumable.consume( innerParagraph, 'insert' );\n\n\t\tif ( options.asWidget ) {\n\t\t\tconst fakeParagraph = conversionApi.writer.createContainerElement( 'span' );\n\n\t\t\tconversionApi.mapper.bindElements( innerParagraph, fakeParagraph );\n\t\t\tconversionApi.writer.insert( paragraphInsertPosition, fakeParagraph );\n\n\t\t\tconversionApi.mapper.bindElements( tableCell, cellElement );\n\t\t} else {\n\t\t\tconversionApi.mapper.bindElements( tableCell, cellElement );\n\t\t\tconversionApi.mapper.bindElements( innerParagraph, cellElement );\n\t\t}\n\t} else {\n\t\tconversionApi.mapper.bindElements( tableCell, cellElement );\n\t}\n}\n\n// Creates `<tr>` view element.\n//\n// @param {module:engine/view/element~Element} tableRow\n// @param {Number} rowIndex\n// @param {module:engine/view/element~Element} tableSection\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/element~Element}\nfunction createTr( tableRow, rowIndex, tableSection, conversionApi ) {\n\t// Will always consume since we're converting <tableRow> element from a parent <table>.\n\tconversionApi.consumable.consume( tableRow, 'insert' );\n\n\tconst trElement = conversionApi.writer.createContainerElement( 'tr' );\n\tconversionApi.mapper.bindElements( tableRow, trElement );\n\n\tconst headingRows = tableRow.parent.getAttribute( 'headingRows' ) || 0;\n\tconst offset = headingRows > 0 && rowIndex >= headingRows ? rowIndex - headingRows : rowIndex;\n\n\tconst position = conversionApi.writer.createPositionAt( tableSection, offset );\n\tconversionApi.writer.insert( position, trElement );\n\n\treturn trElement;\n}\n\n// Returns `th` for heading cells and `td` for other cells for the current table walker value.\n//\n// @param {module:table/tablewalker~TableWalkerValue} tableWalkerValue\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\nfunction getCellElementName( tableWalkerValue, tableAttributes ) {\n\tconst { row, column } = tableWalkerValue;\n\tconst { headingColumns, headingRows } = tableAttributes;\n\n\t// Column heading are all tableCells in the first `columnHeading` rows.\n\tconst isColumnHeading = headingRows && headingRows > row;\n\n\t// So a whole row gets <th> element.\n\tif ( isColumnHeading ) {\n\t\treturn 'th';\n\t}\n\n\t// Row heading are tableCells which columnIndex is lower then headingColumns.\n\tconst isRowHeading = headingColumns && headingColumns > column;\n\n\treturn isRowHeading ? 'th' : 'td';\n}\n\n// Returns the table section name for the current table walker value.\n//\n// @param {Number} row\n// @param {{headingColumns, headingRows}} tableAttributes\n// @returns {String}\nfunction getSectionName( row, tableAttributes ) {\n\treturn row < tableAttributes.headingRows ? 'thead' : 'tbody';\n}\n\n// Creates or returns an existing `<tbody>` or `<thead>` element witch caching.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} viewTable\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Object} cachedTableSection An object that stores cached elements.\n// @returns {module:engine/view/containerelement~ContainerElement}\nfunction getOrCreateTableSection( sectionName, viewTable, conversionApi ) {\n\tconst viewTableSection = getExistingTableSectionElement( sectionName, viewTable );\n\n\treturn viewTableSection ? viewTableSection : createTableSection( sectionName, viewTable, conversionApi );\n}\n\n// Finds an existing `<tbody>` or `<thead>` element or returns undefined.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction getExistingTableSectionElement( sectionName, tableElement ) {\n\tfor ( const tableSection of tableElement.getChildren() ) {\n\t\tif ( tableSection.name == sectionName ) {\n\t\t\treturn tableSection;\n\t\t}\n\t}\n}\n\n// Creates a table section at the end of the table.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @returns {module:engine/view/containerelement~ContainerElement}\nfunction createTableSection( sectionName, tableElement, conversionApi ) {\n\tconst tableChildElement = conversionApi.writer.createContainerElement( sectionName );\n\n\tconst insertPosition = conversionApi.writer.createPositionAt( tableElement, sectionName == 'tbody' ? 'end' : 0 );\n\n\tconversionApi.writer.insert( insertPosition, tableChildElement );\n\n\treturn tableChildElement;\n}\n\n// Removes an existing `<tbody>` or `<thead>` element if it is empty.\n//\n// @param {String} sectionName\n// @param {module:engine/view/element~Element} tableElement\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\nfunction removeTableSectionIfEmpty( sectionName, tableElement, conversionApi ) {\n\tconst tableSection = getExistingTableSectionElement( sectionName, tableElement );\n\n\tif ( tableSection && tableSection.childCount === 0 ) {\n\t\tconversionApi.writer.remove( conversionApi.writer.createRangeOn( tableSection ) );\n\t}\n}\n\n// Moves view table rows associated with passed model rows to the provided table section element.\n//\n// **Note** This method will skip not converted table rows.\n//\n// @param {Array.<module:engine/model/element~Element>} rowsToMove\n// @param {module:engine/view/element~Element} viewTableSection\n// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi\n// @param {Number|'end'|'before'|'after'} offset Offset or one of the flags.\nfunction moveViewRowsToTableSection( rowsToMove, viewTableSection, conversionApi, offset ) {\n\tfor ( const tableRow of rowsToMove ) {\n\t\tconst viewTableRow = conversionApi.mapper.toViewElement( tableRow );\n\n\t\t// View table row might be not yet converted - skip it as it will be properly created by cell converter later on.\n\t\tif ( viewTableRow ) {\n\t\t\tconversionApi.writer.move(\n\t\t\t\tconversionApi.writer.createRangeOn( viewTableRow ),\n\t\t\t\tconversionApi.writer.createPositionAt( viewTableSection, offset )\n\t\t\t);\n\t\t}\n\t}\n}\n\n// Properly finds '<table>' element inside `<figure>` widget.\n//\n// @param {module:engine/view/element~Element} viewFigure\nfunction getViewTable( viewFigure ) {\n\tfor ( const child of viewFigure.getChildren() ) {\n\t\tif ( child.name === 'table' ) {\n\t\t\treturn child;\n\t\t}\n\t}\n}\n\n// Checks if element has any attribute set.\n//\n// @param {module:engine/model/element~Element element\n// @returns {Boolean}\nfunction hasAnyAttribute( element ) {\n\treturn !![ ...element.getAttributeKeys() ].length;\n}\n"]},"metadata":{},"sourceType":"module"}