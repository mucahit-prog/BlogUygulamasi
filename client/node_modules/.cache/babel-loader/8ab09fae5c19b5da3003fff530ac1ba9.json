{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport TableWalker from '../tablewalker';\nimport { findAncestor, updateNumericAttribute } from './utils';\n/**\n * The merge cell command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'mergeTableCellRight'`, `'mergeTableCellLeft'`,\n * `'mergeTableCellUp'` and `'mergeTableCellDown'` editor commands.\n *\n * To merge a table cell at the current selection with another cell, execute the command corresponding with the preferred direction.\n *\n * For example, to merge with a cell to the right:\n *\n *\t\teditor.execute( 'mergeTableCellRight' );\n *\n * **Note**: If a table cell has a different [`rowspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-rowspan)\n * (for `'mergeTableCellRight'` and `'mergeTableCellLeft'`) or [`colspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-colspan)\n * (for `'mergeTableCellUp'` and `'mergeTableCellDown'`), the command will be disabled.\n *\n * @extends module:core/command~Command\n */\n\nexport default class MergeCellCommand extends Command {\n  /**\n   * Creates a new `MergeCellCommand` instance.\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.\n   * @param {Object} options\n   * @param {String} options.direction Indicates which cell to merge with the currently selected one.\n   * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.\n   */\n  constructor(editor, options) {\n    super(editor);\n    /**\n     * The direction that indicates which cell will be merged with the currently selected one.\n     *\n     * @readonly\n     * @member {String} #direction\n     */\n\n    this.direction = options.direction;\n    /**\n     * Whether the merge is horizontal (left/right) or vertical (up/down).\n     *\n     * @readonly\n     * @member {Boolean} #isHorizontal\n     */\n\n    this.isHorizontal = this.direction == 'right' || this.direction == 'left';\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    const cellToMerge = this._getMergeableCell();\n\n    this.isEnabled = !!cellToMerge; // In order to check if currently selected cell can be merged with one defined by #direction some computation are done beforehand.\n    // As such we can cache it as a command's value.\n\n    this.value = cellToMerge;\n  }\n  /**\n   * Executes the command.\n   *\n   * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.\n   *\n   * @fires execute\n   */\n\n\n  execute() {\n    const model = this.editor.model;\n    const doc = model.document;\n    const tableCell = findAncestor('tableCell', doc.selection.getFirstPosition());\n    const cellToMerge = this.value;\n    const direction = this.direction;\n    model.change(writer => {\n      const isMergeNext = direction == 'right' || direction == 'down'; // The merge mechanism is always the same so sort cells to be merged.\n\n      const cellToExpand = isMergeNext ? tableCell : cellToMerge;\n      const cellToRemove = isMergeNext ? cellToMerge : tableCell; // Cache the parent of cell to remove for later check.\n\n      const removedTableCellRow = cellToRemove.parent;\n      mergeTableCells(cellToRemove, cellToExpand, writer);\n      const spanAttribute = this.isHorizontal ? 'colspan' : 'rowspan';\n      const cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || 1);\n      const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1); // Update table cell span attribute and merge set selection on merged contents.\n\n      writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);\n      writer.setSelection(writer.createRangeIn(cellToExpand)); // Remove empty row after merging.\n\n      if (!removedTableCellRow.childCount) {\n        removeEmptyRow(removedTableCellRow, writer);\n      }\n    });\n  }\n  /**\n   * Returns a cell that can be merged with the current cell depending on the command's direction.\n   *\n   * @returns {module:engine/model/element|undefined}\n   * @private\n   */\n\n\n  _getMergeableCell() {\n    const model = this.editor.model;\n    const doc = model.document;\n    const tableCell = findAncestor('tableCell', doc.selection.getFirstPosition());\n\n    if (!tableCell) {\n      return;\n    }\n\n    const tableUtils = this.editor.plugins.get('TableUtils'); // First get the cell on proper direction.\n\n    const cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction);\n\n    if (!cellToMerge) {\n      return;\n    } // If found check if the span perpendicular to merge direction is equal on both cells.\n\n\n    const spanAttribute = this.isHorizontal ? 'rowspan' : 'colspan';\n    const span = parseInt(tableCell.getAttribute(spanAttribute) || 1);\n    const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1);\n\n    if (cellToMergeSpan === span) {\n      return cellToMerge;\n    }\n  }\n\n} // Returns the cell that can be merged horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @returns {module:engine/model/node~Node|null}\n\nfunction getHorizontalCell(tableCell, direction, tableUtils) {\n  const horizontalCell = direction == 'right' ? tableCell.nextSibling : tableCell.previousSibling;\n\n  if (!horizontalCell) {\n    return;\n  } // Sort cells:\n\n\n  const cellOnLeft = direction == 'right' ? tableCell : horizontalCell;\n  const cellOnRight = direction == 'right' ? horizontalCell : tableCell; // Get their column indexes:\n\n  const {\n    column: leftCellColumn\n  } = tableUtils.getCellLocation(cellOnLeft);\n  const {\n    column: rightCellColumn\n  } = tableUtils.getCellLocation(cellOnRight);\n  const leftCellSpan = parseInt(cellOnLeft.getAttribute('colspan') || 1); // The cell on the right must have index that is distant to the cell on the left by the left cell's width (colspan).\n\n  const cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn; // If the right cell's column index is different it means that there are rowspanned cells between them.\n\n  return cellsAreTouching ? horizontalCell : undefined;\n} // Returns the cell that can be merged vertically.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @returns {module:engine/model/node~Node|null}\n\n\nfunction getVerticalCell(tableCell, direction) {\n  const tableRow = tableCell.parent;\n  const table = tableRow.parent;\n  const rowIndex = table.getChildIndex(tableRow); // Don't search for mergeable cell if direction points out of the table.\n\n  if (direction == 'down' && rowIndex === table.childCount - 1 || direction == 'up' && rowIndex === 0) {\n    return;\n  }\n\n  const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  const headingRows = table.getAttribute('headingRows') || 0;\n  const isMergeWithBodyCell = direction == 'down' && rowIndex + rowspan === headingRows;\n  const isMergeWithHeadCell = direction == 'up' && rowIndex === headingRows; // Don't search for mergeable cell if direction points out of the current table section.\n\n  if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {\n    return;\n  }\n\n  const currentCellRowSpan = parseInt(tableCell.getAttribute('rowspan') || 1);\n  const rowOfCellToMerge = direction == 'down' ? rowIndex + currentCellRowSpan : rowIndex;\n  const tableMap = [...new TableWalker(table, {\n    endRow: rowOfCellToMerge\n  })];\n  const currentCellData = tableMap.find(value => value.cell === tableCell);\n  const mergeColumn = currentCellData.column;\n  const cellToMergeData = tableMap.find(({\n    row,\n    rowspan,\n    column\n  }) => {\n    if (column !== mergeColumn) {\n      return false;\n    }\n\n    if (direction == 'down') {\n      // If merging a cell below the mergeRow is already calculated.\n      return row === rowOfCellToMerge;\n    } else {\n      // If merging a cell above calculate if it spans to mergeRow.\n      return rowOfCellToMerge === row + rowspan;\n    }\n  });\n  return cellToMergeData && cellToMergeData.cell;\n} // Properly removes empty row from a table. Will update `rowspan` attribute of cells that overlaps removed row.\n//\n// @param {module:engine/model/element~Element} removedTableCellRow\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction removeEmptyRow(removedTableCellRow, writer) {\n  const table = removedTableCellRow.parent;\n  const removedRowIndex = table.getChildIndex(removedTableCellRow);\n\n  for (const {\n    cell,\n    row,\n    rowspan\n  } of new TableWalker(table, {\n    endRow: removedRowIndex\n  })) {\n    const overlapsRemovedRow = row + rowspan - 1 >= removedRowIndex;\n\n    if (overlapsRemovedRow) {\n      updateNumericAttribute('rowspan', rowspan - 1, cell, writer);\n    }\n  }\n\n  writer.remove(removedTableCellRow);\n} // Merges two table cells - will ensure that after merging cells with empty paragraph the result table cell will only have one paragraph.\n// If one of the merged table cell is empty the merged table cell will have contents of the non-empty table cell.\n// If both are empty the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellToRemove\n// @param {module:engine/model/element~Element} cellToExpand\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction mergeTableCells(cellToRemove, cellToExpand, writer) {\n  if (!isEmpty(cellToRemove)) {\n    if (isEmpty(cellToExpand)) {\n      writer.remove(writer.createRangeIn(cellToExpand));\n    }\n\n    writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, 'end'));\n  } // Remove merged table cell.\n\n\n  writer.remove(cellToRemove);\n} // Checks if passed table cell contains empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\n\n\nfunction isEmpty(tableCell) {\n  return tableCell.childCount == 1 && tableCell.getChild(0).is('paragraph') && tableCell.getChild(0).isEmpty;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellcommand.js"],"names":["Command","TableWalker","findAncestor","updateNumericAttribute","MergeCellCommand","constructor","editor","options","direction","isHorizontal","refresh","cellToMerge","_getMergeableCell","isEnabled","value","execute","model","doc","document","tableCell","selection","getFirstPosition","change","writer","isMergeNext","cellToExpand","cellToRemove","removedTableCellRow","parent","mergeTableCells","spanAttribute","cellSpan","parseInt","getAttribute","cellToMergeSpan","setAttribute","setSelection","createRangeIn","childCount","removeEmptyRow","tableUtils","plugins","get","getHorizontalCell","getVerticalCell","span","horizontalCell","nextSibling","previousSibling","cellOnLeft","cellOnRight","column","leftCellColumn","getCellLocation","rightCellColumn","leftCellSpan","cellsAreTouching","undefined","tableRow","table","rowIndex","getChildIndex","rowspan","headingRows","isMergeWithBodyCell","isMergeWithHeadCell","currentCellRowSpan","rowOfCellToMerge","tableMap","endRow","currentCellData","find","cell","mergeColumn","cellToMergeData","row","removedRowIndex","overlapsRemovedRow","remove","isEmpty","move","createPositionAt","getChild","is"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,OAAP,MAAoB,sCAApB;AACA,OAAOC,WAAP,MAAwB,gBAAxB;AACA,SAASC,YAAT,EAAuBC,sBAAvB,QAAqD,SAArD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,SAA+BJ,OAA/B,CAAuC;AACrD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACCK,EAAAA,WAAW,CAAEC,MAAF,EAAUC,OAAV,EAAoB;AAC9B,UAAOD,MAAP;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKE,SAAL,GAAiBD,OAAO,CAACC,SAAzB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,YAAL,GAAoB,KAAKD,SAAL,IAAkB,OAAlB,IAA6B,KAAKA,SAAL,IAAkB,MAAnE;AACA;AAED;AACD;AACA;;;AACCE,EAAAA,OAAO,GAAG;AACT,UAAMC,WAAW,GAAG,KAAKC,iBAAL,EAApB;;AAEA,SAAKC,SAAL,GAAiB,CAAC,CAACF,WAAnB,CAHS,CAIT;AACA;;AACA,SAAKG,KAAL,GAAaH,WAAb;AACA;AAED;AACD;AACA;AACA;AACA;AACA;AACA;;;AACCI,EAAAA,OAAO,GAAG;AACT,UAAMC,KAAK,GAAG,KAAKV,MAAL,CAAYU,KAA1B;AACA,UAAMC,GAAG,GAAGD,KAAK,CAACE,QAAlB;AACA,UAAMC,SAAS,GAAGjB,YAAY,CAAE,WAAF,EAAee,GAAG,CAACG,SAAJ,CAAcC,gBAAd,EAAf,CAA9B;AACA,UAAMV,WAAW,GAAG,KAAKG,KAAzB;AACA,UAAMN,SAAS,GAAG,KAAKA,SAAvB;AAEAQ,IAAAA,KAAK,CAACM,MAAN,CAAcC,MAAM,IAAI;AACvB,YAAMC,WAAW,GAAGhB,SAAS,IAAI,OAAb,IAAwBA,SAAS,IAAI,MAAzD,CADuB,CAGvB;;AACA,YAAMiB,YAAY,GAAGD,WAAW,GAAGL,SAAH,GAAeR,WAA/C;AACA,YAAMe,YAAY,GAAGF,WAAW,GAAGb,WAAH,GAAiBQ,SAAjD,CALuB,CAOvB;;AACA,YAAMQ,mBAAmB,GAAGD,YAAY,CAACE,MAAzC;AAEAC,MAAAA,eAAe,CAAEH,YAAF,EAAgBD,YAAhB,EAA8BF,MAA9B,CAAf;AAEA,YAAMO,aAAa,GAAG,KAAKrB,YAAL,GAAoB,SAApB,GAAgC,SAAtD;AACA,YAAMsB,QAAQ,GAAGC,QAAQ,CAAEb,SAAS,CAACc,YAAV,CAAwBH,aAAxB,KAA2C,CAA7C,CAAzB;AACA,YAAMI,eAAe,GAAGF,QAAQ,CAAErB,WAAW,CAACsB,YAAZ,CAA0BH,aAA1B,KAA6C,CAA/C,CAAhC,CAduB,CAgBvB;;AACAP,MAAAA,MAAM,CAACY,YAAP,CAAqBL,aAArB,EAAoCC,QAAQ,GAAGG,eAA/C,EAAgET,YAAhE;AACAF,MAAAA,MAAM,CAACa,YAAP,CAAqBb,MAAM,CAACc,aAAP,CAAsBZ,YAAtB,CAArB,EAlBuB,CAoBvB;;AACA,UAAK,CAACE,mBAAmB,CAACW,UAA1B,EAAuC;AACtCC,QAAAA,cAAc,CAAEZ,mBAAF,EAAuBJ,MAAvB,CAAd;AACA;AACD,KAxBD;AAyBA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACCX,EAAAA,iBAAiB,GAAG;AACnB,UAAMI,KAAK,GAAG,KAAKV,MAAL,CAAYU,KAA1B;AACA,UAAMC,GAAG,GAAGD,KAAK,CAACE,QAAlB;AACA,UAAMC,SAAS,GAAGjB,YAAY,CAAE,WAAF,EAAee,GAAG,CAACG,SAAJ,CAAcC,gBAAd,EAAf,CAA9B;;AAEA,QAAK,CAACF,SAAN,EAAkB;AACjB;AACA;;AAED,UAAMqB,UAAU,GAAG,KAAKlC,MAAL,CAAYmC,OAAZ,CAAoBC,GAApB,CAAyB,YAAzB,CAAnB,CATmB,CAWnB;;AACA,UAAM/B,WAAW,GAAG,KAAKF,YAAL,GACnBkC,iBAAiB,CAAExB,SAAF,EAAa,KAAKX,SAAlB,EAA6BgC,UAA7B,CADE,GAEnBI,eAAe,CAAEzB,SAAF,EAAa,KAAKX,SAAlB,CAFhB;;AAIA,QAAK,CAACG,WAAN,EAAoB;AACnB;AACA,KAlBkB,CAoBnB;;;AACA,UAAMmB,aAAa,GAAG,KAAKrB,YAAL,GAAoB,SAApB,GAAgC,SAAtD;AACA,UAAMoC,IAAI,GAAGb,QAAQ,CAAEb,SAAS,CAACc,YAAV,CAAwBH,aAAxB,KAA2C,CAA7C,CAArB;AAEA,UAAMI,eAAe,GAAGF,QAAQ,CAAErB,WAAW,CAACsB,YAAZ,CAA0BH,aAA1B,KAA6C,CAA/C,CAAhC;;AAEA,QAAKI,eAAe,KAAKW,IAAzB,EAAgC;AAC/B,aAAOlC,WAAP;AACA;AACD;;AArHoD,C,CAwHtD;AACA;AACA;AACA;AACA;;AACA,SAASgC,iBAAT,CAA4BxB,SAA5B,EAAuCX,SAAvC,EAAkDgC,UAAlD,EAA+D;AAC9D,QAAMM,cAAc,GAAGtC,SAAS,IAAI,OAAb,GAAuBW,SAAS,CAAC4B,WAAjC,GAA+C5B,SAAS,CAAC6B,eAAhF;;AAEA,MAAK,CAACF,cAAN,EAAuB;AACtB;AACA,GAL6D,CAO9D;;;AACA,QAAMG,UAAU,GAAGzC,SAAS,IAAI,OAAb,GAAuBW,SAAvB,GAAmC2B,cAAtD;AACA,QAAMI,WAAW,GAAG1C,SAAS,IAAI,OAAb,GAAuBsC,cAAvB,GAAwC3B,SAA5D,CAT8D,CAW9D;;AACA,QAAM;AAAEgC,IAAAA,MAAM,EAAEC;AAAV,MAA6BZ,UAAU,CAACa,eAAX,CAA4BJ,UAA5B,CAAnC;AACA,QAAM;AAAEE,IAAAA,MAAM,EAAEG;AAAV,MAA8Bd,UAAU,CAACa,eAAX,CAA4BH,WAA5B,CAApC;AAEA,QAAMK,YAAY,GAAGvB,QAAQ,CAAEiB,UAAU,CAAChB,YAAX,CAAyB,SAAzB,KAAwC,CAA1C,CAA7B,CAf8D,CAiB9D;;AACA,QAAMuB,gBAAgB,GAAGJ,cAAc,GAAGG,YAAjB,KAAkCD,eAA3D,CAlB8D,CAoB9D;;AACA,SAAOE,gBAAgB,GAAGV,cAAH,GAAoBW,SAA3C;AACA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASb,eAAT,CAA0BzB,SAA1B,EAAqCX,SAArC,EAAiD;AAChD,QAAMkD,QAAQ,GAAGvC,SAAS,CAACS,MAA3B;AACA,QAAM+B,KAAK,GAAGD,QAAQ,CAAC9B,MAAvB;AAEA,QAAMgC,QAAQ,GAAGD,KAAK,CAACE,aAAN,CAAqBH,QAArB,CAAjB,CAJgD,CAMhD;;AACA,MAAOlD,SAAS,IAAI,MAAb,IAAuBoD,QAAQ,KAAKD,KAAK,CAACrB,UAAN,GAAmB,CAAzD,IAAkE9B,SAAS,IAAI,IAAb,IAAqBoD,QAAQ,KAAK,CAAzG,EAA+G;AAC9G;AACA;;AAED,QAAME,OAAO,GAAG9B,QAAQ,CAAEb,SAAS,CAACc,YAAV,CAAwB,SAAxB,KAAuC,CAAzC,CAAxB;AACA,QAAM8B,WAAW,GAAGJ,KAAK,CAAC1B,YAAN,CAAoB,aAApB,KAAuC,CAA3D;AAEA,QAAM+B,mBAAmB,GAAGxD,SAAS,IAAI,MAAb,IAAyBoD,QAAQ,GAAGE,OAAb,KAA2BC,WAA9E;AACA,QAAME,mBAAmB,GAAGzD,SAAS,IAAI,IAAb,IAAqBoD,QAAQ,KAAKG,WAA9D,CAfgD,CAiBhD;;AACA,MAAKA,WAAW,KAAMC,mBAAmB,IAAIC,mBAA7B,CAAhB,EAAqE;AACpE;AACA;;AAED,QAAMC,kBAAkB,GAAGlC,QAAQ,CAAEb,SAAS,CAACc,YAAV,CAAwB,SAAxB,KAAuC,CAAzC,CAAnC;AACA,QAAMkC,gBAAgB,GAAG3D,SAAS,IAAI,MAAb,GAAsBoD,QAAQ,GAAGM,kBAAjC,GAAsDN,QAA/E;AAEA,QAAMQ,QAAQ,GAAG,CAAE,GAAG,IAAInE,WAAJ,CAAiB0D,KAAjB,EAAwB;AAAEU,IAAAA,MAAM,EAAEF;AAAV,GAAxB,CAAL,CAAjB;AAEA,QAAMG,eAAe,GAAGF,QAAQ,CAACG,IAAT,CAAezD,KAAK,IAAIA,KAAK,CAAC0D,IAAN,KAAerD,SAAvC,CAAxB;AACA,QAAMsD,WAAW,GAAGH,eAAe,CAACnB,MAApC;AAEA,QAAMuB,eAAe,GAAGN,QAAQ,CAACG,IAAT,CAAe,CAAE;AAAEI,IAAAA,GAAF;AAAOb,IAAAA,OAAP;AAAgBX,IAAAA;AAAhB,GAAF,KAAgC;AACtE,QAAKA,MAAM,KAAKsB,WAAhB,EAA8B;AAC7B,aAAO,KAAP;AACA;;AAED,QAAKjE,SAAS,IAAI,MAAlB,EAA2B;AAC1B;AACA,aAAOmE,GAAG,KAAKR,gBAAf;AACA,KAHD,MAGO;AACN;AACA,aAAOA,gBAAgB,KAAKQ,GAAG,GAAGb,OAAlC;AACA;AACD,GAZuB,CAAxB;AAcA,SAAOY,eAAe,IAAIA,eAAe,CAACF,IAA1C;AACA,C,CAED;AACA;AACA;AACA;;;AACA,SAASjC,cAAT,CAAyBZ,mBAAzB,EAA8CJ,MAA9C,EAAuD;AACtD,QAAMoC,KAAK,GAAGhC,mBAAmB,CAACC,MAAlC;AAEA,QAAMgD,eAAe,GAAGjB,KAAK,CAACE,aAAN,CAAqBlC,mBAArB,CAAxB;;AAEA,OAAM,MAAM;AAAE6C,IAAAA,IAAF;AAAQG,IAAAA,GAAR;AAAab,IAAAA;AAAb,GAAZ,IAAsC,IAAI7D,WAAJ,CAAiB0D,KAAjB,EAAwB;AAAEU,IAAAA,MAAM,EAAEO;AAAV,GAAxB,CAAtC,EAA8F;AAC7F,UAAMC,kBAAkB,GAAGF,GAAG,GAAGb,OAAN,GAAgB,CAAhB,IAAqBc,eAAhD;;AAEA,QAAKC,kBAAL,EAA0B;AACzB1E,MAAAA,sBAAsB,CAAE,SAAF,EAAa2D,OAAO,GAAG,CAAvB,EAA0BU,IAA1B,EAAgCjD,MAAhC,CAAtB;AACA;AACD;;AAEDA,EAAAA,MAAM,CAACuD,MAAP,CAAenD,mBAAf;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,eAAT,CAA0BH,YAA1B,EAAwCD,YAAxC,EAAsDF,MAAtD,EAA+D;AAC9D,MAAK,CAACwD,OAAO,CAAErD,YAAF,CAAb,EAAgC;AAC/B,QAAKqD,OAAO,CAAEtD,YAAF,CAAZ,EAA+B;AAC9BF,MAAAA,MAAM,CAACuD,MAAP,CAAevD,MAAM,CAACc,aAAP,CAAsBZ,YAAtB,CAAf;AACA;;AAEDF,IAAAA,MAAM,CAACyD,IAAP,CAAazD,MAAM,CAACc,aAAP,CAAsBX,YAAtB,CAAb,EAAmDH,MAAM,CAAC0D,gBAAP,CAAyBxD,YAAzB,EAAuC,KAAvC,CAAnD;AACA,GAP6D,CAS9D;;;AACAF,EAAAA,MAAM,CAACuD,MAAP,CAAepD,YAAf;AACA,C,CAED;AACA;AACA;AACA;;;AACA,SAASqD,OAAT,CAAkB5D,SAAlB,EAA8B;AAC7B,SAAOA,SAAS,CAACmB,UAAV,IAAwB,CAAxB,IAA6BnB,SAAS,CAAC+D,QAAV,CAAoB,CAApB,EAAwBC,EAAxB,CAA4B,WAA5B,CAA7B,IAA0EhE,SAAS,CAAC+D,QAAV,CAAoB,CAApB,EAAwBH,OAAzG;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/mergecellcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport TableWalker from '../tablewalker';\nimport { findAncestor, updateNumericAttribute } from './utils';\n\n/**\n * The merge cell command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'mergeTableCellRight'`, `'mergeTableCellLeft'`,\n * `'mergeTableCellUp'` and `'mergeTableCellDown'` editor commands.\n *\n * To merge a table cell at the current selection with another cell, execute the command corresponding with the preferred direction.\n *\n * For example, to merge with a cell to the right:\n *\n *\t\teditor.execute( 'mergeTableCellRight' );\n *\n * **Note**: If a table cell has a different [`rowspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-rowspan)\n * (for `'mergeTableCellRight'` and `'mergeTableCellLeft'`) or [`colspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-colspan)\n * (for `'mergeTableCellUp'` and `'mergeTableCellDown'`), the command will be disabled.\n *\n * @extends module:core/command~Command\n */\nexport default class MergeCellCommand extends Command {\n\t/**\n\t * Creates a new `MergeCellCommand` instance.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.\n\t * @param {Object} options\n\t * @param {String} options.direction Indicates which cell to merge with the currently selected one.\n\t * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.\n\t */\n\tconstructor( editor, options ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * The direction that indicates which cell will be merged with the currently selected one.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String} #direction\n\t\t */\n\t\tthis.direction = options.direction;\n\n\t\t/**\n\t\t * Whether the merge is horizontal (left/right) or vertical (up/down).\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean} #isHorizontal\n\t\t */\n\t\tthis.isHorizontal = this.direction == 'right' || this.direction == 'left';\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst cellToMerge = this._getMergeableCell();\n\n\t\tthis.isEnabled = !!cellToMerge;\n\t\t// In order to check if currently selected cell can be merged with one defined by #direction some computation are done beforehand.\n\t\t// As such we can cache it as a command's value.\n\t\tthis.value = cellToMerge;\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.\n\t *\n\t * @fires execute\n\t */\n\texecute() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst tableCell = findAncestor( 'tableCell', doc.selection.getFirstPosition() );\n\t\tconst cellToMerge = this.value;\n\t\tconst direction = this.direction;\n\n\t\tmodel.change( writer => {\n\t\t\tconst isMergeNext = direction == 'right' || direction == 'down';\n\n\t\t\t// The merge mechanism is always the same so sort cells to be merged.\n\t\t\tconst cellToExpand = isMergeNext ? tableCell : cellToMerge;\n\t\t\tconst cellToRemove = isMergeNext ? cellToMerge : tableCell;\n\n\t\t\t// Cache the parent of cell to remove for later check.\n\t\t\tconst removedTableCellRow = cellToRemove.parent;\n\n\t\t\tmergeTableCells( cellToRemove, cellToExpand, writer );\n\n\t\t\tconst spanAttribute = this.isHorizontal ? 'colspan' : 'rowspan';\n\t\t\tconst cellSpan = parseInt( tableCell.getAttribute( spanAttribute ) || 1 );\n\t\t\tconst cellToMergeSpan = parseInt( cellToMerge.getAttribute( spanAttribute ) || 1 );\n\n\t\t\t// Update table cell span attribute and merge set selection on merged contents.\n\t\t\twriter.setAttribute( spanAttribute, cellSpan + cellToMergeSpan, cellToExpand );\n\t\t\twriter.setSelection( writer.createRangeIn( cellToExpand ) );\n\n\t\t\t// Remove empty row after merging.\n\t\t\tif ( !removedTableCellRow.childCount ) {\n\t\t\t\tremoveEmptyRow( removedTableCellRow, writer );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns a cell that can be merged with the current cell depending on the command's direction.\n\t *\n\t * @returns {module:engine/model/element|undefined}\n\t * @private\n\t */\n\t_getMergeableCell() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst tableCell = findAncestor( 'tableCell', doc.selection.getFirstPosition() );\n\n\t\tif ( !tableCell ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst tableUtils = this.editor.plugins.get( 'TableUtils' );\n\n\t\t// First get the cell on proper direction.\n\t\tconst cellToMerge = this.isHorizontal ?\n\t\t\tgetHorizontalCell( tableCell, this.direction, tableUtils ) :\n\t\t\tgetVerticalCell( tableCell, this.direction );\n\n\t\tif ( !cellToMerge ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If found check if the span perpendicular to merge direction is equal on both cells.\n\t\tconst spanAttribute = this.isHorizontal ? 'rowspan' : 'colspan';\n\t\tconst span = parseInt( tableCell.getAttribute( spanAttribute ) || 1 );\n\n\t\tconst cellToMergeSpan = parseInt( cellToMerge.getAttribute( spanAttribute ) || 1 );\n\n\t\tif ( cellToMergeSpan === span ) {\n\t\t\treturn cellToMerge;\n\t\t}\n\t}\n}\n\n// Returns the cell that can be merged horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @returns {module:engine/model/node~Node|null}\nfunction getHorizontalCell( tableCell, direction, tableUtils ) {\n\tconst horizontalCell = direction == 'right' ? tableCell.nextSibling : tableCell.previousSibling;\n\n\tif ( !horizontalCell ) {\n\t\treturn;\n\t}\n\n\t// Sort cells:\n\tconst cellOnLeft = direction == 'right' ? tableCell : horizontalCell;\n\tconst cellOnRight = direction == 'right' ? horizontalCell : tableCell;\n\n\t// Get their column indexes:\n\tconst { column: leftCellColumn } = tableUtils.getCellLocation( cellOnLeft );\n\tconst { column: rightCellColumn } = tableUtils.getCellLocation( cellOnRight );\n\n\tconst leftCellSpan = parseInt( cellOnLeft.getAttribute( 'colspan' ) || 1 );\n\n\t// The cell on the right must have index that is distant to the cell on the left by the left cell's width (colspan).\n\tconst cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn;\n\n\t// If the right cell's column index is different it means that there are rowspanned cells between them.\n\treturn cellsAreTouching ? horizontalCell : undefined;\n}\n\n// Returns the cell that can be merged vertically.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {String} direction\n// @returns {module:engine/model/node~Node|null}\nfunction getVerticalCell( tableCell, direction ) {\n\tconst tableRow = tableCell.parent;\n\tconst table = tableRow.parent;\n\n\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t// Don't search for mergeable cell if direction points out of the table.\n\tif ( ( direction == 'down' && rowIndex === table.childCount - 1 ) || ( direction == 'up' && rowIndex === 0 ) ) {\n\t\treturn;\n\t}\n\n\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\tconst isMergeWithBodyCell = direction == 'down' && ( rowIndex + rowspan ) === headingRows;\n\tconst isMergeWithHeadCell = direction == 'up' && rowIndex === headingRows;\n\n\t// Don't search for mergeable cell if direction points out of the current table section.\n\tif ( headingRows && ( isMergeWithBodyCell || isMergeWithHeadCell ) ) {\n\t\treturn;\n\t}\n\n\tconst currentCellRowSpan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\tconst rowOfCellToMerge = direction == 'down' ? rowIndex + currentCellRowSpan : rowIndex;\n\n\tconst tableMap = [ ...new TableWalker( table, { endRow: rowOfCellToMerge } ) ];\n\n\tconst currentCellData = tableMap.find( value => value.cell === tableCell );\n\tconst mergeColumn = currentCellData.column;\n\n\tconst cellToMergeData = tableMap.find( ( { row, rowspan, column } ) => {\n\t\tif ( column !== mergeColumn ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( direction == 'down' ) {\n\t\t\t// If merging a cell below the mergeRow is already calculated.\n\t\t\treturn row === rowOfCellToMerge;\n\t\t} else {\n\t\t\t// If merging a cell above calculate if it spans to mergeRow.\n\t\t\treturn rowOfCellToMerge === row + rowspan;\n\t\t}\n\t} );\n\n\treturn cellToMergeData && cellToMergeData.cell;\n}\n\n// Properly removes empty row from a table. Will update `rowspan` attribute of cells that overlaps removed row.\n//\n// @param {module:engine/model/element~Element} removedTableCellRow\n// @param {module:engine/model/writer~Writer} writer\nfunction removeEmptyRow( removedTableCellRow, writer ) {\n\tconst table = removedTableCellRow.parent;\n\n\tconst removedRowIndex = table.getChildIndex( removedTableCellRow );\n\n\tfor ( const { cell, row, rowspan } of new TableWalker( table, { endRow: removedRowIndex } ) ) {\n\t\tconst overlapsRemovedRow = row + rowspan - 1 >= removedRowIndex;\n\n\t\tif ( overlapsRemovedRow ) {\n\t\t\tupdateNumericAttribute( 'rowspan', rowspan - 1, cell, writer );\n\t\t}\n\t}\n\n\twriter.remove( removedTableCellRow );\n}\n\n// Merges two table cells - will ensure that after merging cells with empty paragraph the result table cell will only have one paragraph.\n// If one of the merged table cell is empty the merged table cell will have contents of the non-empty table cell.\n// If both are empty the merged table cell will have only one empty paragraph.\n//\n// @param {module:engine/model/element~Element} cellToRemove\n// @param {module:engine/model/element~Element} cellToExpand\n// @param {module:engine/model/writer~Writer} writer\nfunction mergeTableCells( cellToRemove, cellToExpand, writer ) {\n\tif ( !isEmpty( cellToRemove ) ) {\n\t\tif ( isEmpty( cellToExpand ) ) {\n\t\t\twriter.remove( writer.createRangeIn( cellToExpand ) );\n\t\t}\n\n\t\twriter.move( writer.createRangeIn( cellToRemove ), writer.createPositionAt( cellToExpand, 'end' ) );\n\t}\n\n\t// Remove merged table cell.\n\twriter.remove( cellToRemove );\n}\n\n// Checks if passed table cell contains empty paragraph.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @returns {Boolean}\nfunction isEmpty( tableCell ) {\n\treturn tableCell.childCount == 1 && tableCell.getChild( 0 ).is( 'paragraph' ) && tableCell.getChild( 0 ).isEmpty;\n}\n"]},"metadata":{},"sourceType":"module"}