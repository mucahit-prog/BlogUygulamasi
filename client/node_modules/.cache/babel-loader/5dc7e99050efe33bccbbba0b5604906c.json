{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/utils/bindtwostepcarettoattribute\n */\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\n/**\n * This helper enables the two-step caret (phantom) movement behavior for the given {@link module:engine/model/model~Model}\n * attribute on arrow right (<kbd>→</kbd>) and left (<kbd>←</kbd>) key press.\n *\n * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the\n * beginning/end of an attribute.\n *\n * **Note:** This helper support right–to–left (Arabic, Hebrew, etc.) content by mirroring its behavior\n * but for the sake of simplicity examples showcase only left–to–right use–cases.\n *\n * # Forward movement\n *\n * ## \"Entering\" an attribute:\n *\n * When this behavior is enabled for the `a` attribute and the selection is right before it\n * (at the attribute boundary), pressing the right arrow key will not move the selection but update its\n * attributes accordingly:\n *\n * * When enabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *    <kbd>→</kbd>\n *\n *   \t\tfoo<$text a=\"true\">{}bar</$text>\n *\n * * When disabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *   <kbd>→</kbd>\n *\n *   \t\tfoo<$text a=\"true\">b{}ar</$text>\n *\n *\n * ## \"Leaving\" an attribute:\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *    <kbd>→</kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *   <kbd>→</kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>b{}az\n *\n * # Backward movement\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *    <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *   <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">ba{}r</$text>b{}az\n *\n * @param {Object} options Helper options.\n * @param {module:engine/view/view~View} options.view View controller instance.\n * @param {module:engine/model/model~Model} options.model Data model instance.\n * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior should be added\n * (e.g. a plugin instance).\n * @param {String} options.attribute Attribute for which this behavior will be added.\n * @param {module:utils/locale~Locale} options.locale The {@link module:core/editor/editor~Editor#locale} instance.\n */\n\nexport default function bindTwoStepCaretToAttribute({\n  view,\n  model,\n  emitter,\n  attribute,\n  locale\n}) {\n  const twoStepCaretHandler = new TwoStepCaretHandler(model, emitter, attribute);\n  const modelSelection = model.document.selection; // Listen to keyboard events and handle the caret movement according to the 2-step caret logic.\n  //\n  // Note: This listener has the \"high+1\" priority:\n  // * \"high\" because of the filler logic implemented in the renderer which also engages on #keydown.\n  // When the gravity is overridden the attributes of the (model) selection attributes are reset.\n  // It may end up with the filler kicking in and breaking the selection.\n  // * \"+1\" because we would like to avoid collisions with other features (like Widgets), which\n  // take over the keydown events with the \"high\" priority. Two-step caret movement takes precedence\n  // over Widgets in that matter.\n  //\n  // Find out more in https://github.com/ckeditor/ckeditor5-engine/issues/1301.\n\n  emitter.listenTo(view.document, 'keydown', (evt, data) => {\n    // This implementation works only for collapsed selection.\n    if (!modelSelection.isCollapsed) {\n      return;\n    } // When user tries to expand the selection or jump over the whole word or to the beginning/end then\n    // two-steps movement is not necessary.\n\n\n    if (data.shiftKey || data.altKey || data.ctrlKey) {\n      return;\n    }\n\n    const arrowRightPressed = data.keyCode == keyCodes.arrowright;\n    const arrowLeftPressed = data.keyCode == keyCodes.arrowleft; // When neither left or right arrow has been pressed then do noting.\n\n    if (!arrowRightPressed && !arrowLeftPressed) {\n      return;\n    }\n\n    const position = modelSelection.getFirstPosition();\n    const contentDirection = locale.contentLanguageDirection;\n    let isMovementHandled;\n\n    if (contentDirection === 'ltr' && arrowRightPressed || contentDirection === 'rtl' && arrowLeftPressed) {\n      isMovementHandled = twoStepCaretHandler.handleForwardMovement(position, data);\n    } else {\n      isMovementHandled = twoStepCaretHandler.handleBackwardMovement(position, data);\n    } // Stop the keydown event if the two-step caret movement handled it. Avoid collisions\n    // with other features which may also take over the caret movement (e.g. Widget).\n\n\n    if (isMovementHandled) {\n      evt.stop();\n    }\n  }, {\n    priority: priorities.get('high') + 1\n  });\n}\n/**\n * This is a protected helper–class for {@link module:engine/utils/bindtwostepcarettoattribute}.\n * It handles the state of the 2-step caret movement for a single {@link module:engine/model/model~Model}\n * attribute upon the `keypress` in the {@link module:engine/view/view~View}.\n *\n * @protected\n */\n\nexport class TwoStepCaretHandler {\n  /*\n   * Creates two step handler instance.\n   *\n   * @param {module:engine/model/model~Model} model Data model instance.\n   * @param {module:utils/dom/emittermixin~Emitter} emitter The emitter to which this behavior should be added\n   * (e.g. a plugin instance).\n   * @param {String} attribute Attribute for which the behavior will be added.\n   */\n  constructor(model, emitter, attribute) {\n    /**\n     * The model instance this class instance operates on.\n     *\n     * @readonly\n     * @member {module:engine/model/model~Model#schema}\n     */\n    this.model = model;\n    /**\n     * The Attribute this class instance operates on.\n     *\n     * @readonly\n     * @member {String}\n     */\n\n    this.attribute = attribute;\n    /**\n     * A reference to the document selection.\n     *\n     * @private\n     * @member {module:engine/model/selection~Selection}\n     */\n\n    this._modelSelection = model.document.selection;\n    /**\n     * The current UID of the overridden gravity, as returned by\n     * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._overrideUid = null;\n    /**\n     * A flag indicating that the automatic gravity restoration for this attribute\n     * should not happen upon the next\n     * {@link module:engine/model/selection~Selection#event:change:range} event.\n     *\n     * @private\n     * @member {String}\n     */\n\n    this._isNextGravityRestorationSkipped = false; // The automatic gravity restoration logic.\n\n    emitter.listenTo(this._modelSelection, 'change:range', (evt, data) => {\n      // Skipping the automatic restoration is needed if the selection should change\n      // but the gravity must remain overridden afterwards. See the #handleBackwardMovement\n      // to learn more.\n      if (this._isNextGravityRestorationSkipped) {\n        this._isNextGravityRestorationSkipped = false;\n        return;\n      } // Skip automatic restore when the gravity is not overridden — simply, there's nothing to restore\n      // at this moment.\n\n\n      if (!this._isGravityOverridden) {\n        return;\n      } // Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.\n      // It means that e.g. if the change was external (collaboration) and the user had their\n      // selection around the link, its gravity should remain intact in this change:range event.\n\n\n      if (!data.directChange && isAtBoundary(this._modelSelection.getFirstPosition(), attribute)) {\n        return;\n      }\n\n      this._restoreGravity();\n    });\n  }\n  /**\n   * Updates the document selection and the view according to the two–step caret movement state\n   * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n   *\n   * @param {module:engine/model/position~Position} position The model position at the moment of the key press.\n   * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n   * @returns {Boolean} `true` when the handler prevented caret movement\n   */\n\n\n  handleForwardMovement(position, data) {\n    const attribute = this.attribute; // DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered\n    //\n    // \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n    //\n    // or left the attribute\n    //\n    // \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n    //\n    // and the gravity will be restored automatically.\n\n    if (this._isGravityOverridden) {\n      return;\n    } // DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the\n    // attribute:\n    // * when the selection was initially set there using the mouse,\n    // * when the editor has just started\n    //\n    //\t\t<paragraph><$text attribute>{}bar</$text>baz</paragraph>\n    //\n\n\n    if (position.isAtStart && this._hasSelectionAttribute) {\n      return;\n    } // ENGAGE 2-SCM when about to leave one attribute value and enter another:\n    //\n    // \t\t<paragraph><$text attribute=\"1\">foo{}</$text><$text attribute=\"2\">bar</$text></paragraph>\n    //\n    // but DON'T when already in between of them (no attribute selection):\n    //\n    // \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n    //\n\n\n    if (isBetweenDifferentValues(position, attribute) && this._hasSelectionAttribute) {\n      this._preventCaretMovement(data);\n\n      this._removeSelectionAttribute();\n\n      return true;\n    } // ENGAGE 2-SCM when entering an attribute:\n    //\n    // \t\t<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>\n    //\n\n\n    if (isAtStartBoundary(position, attribute)) {\n      this._preventCaretMovement(data);\n\n      this._overrideGravity();\n\n      return true;\n    } // ENGAGE 2-SCM when leaving an attribute:\n    //\n    //\t\t<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>\n    //\n\n\n    if (isAtEndBoundary(position, attribute) && this._hasSelectionAttribute) {\n      this._preventCaretMovement(data);\n\n      this._overrideGravity();\n\n      return true;\n    }\n  }\n  /**\n   * Updates the document selection and the view according to the two–step caret movement state\n   * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n   *\n   * @param {module:engine/model/position~Position} position The model position at the moment of the key press.\n   * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n   * @returns {Boolean} `true` when the handler prevented caret movement\n   */\n\n\n  handleBackwardMovement(position, data) {\n    const attribute = this.attribute; // When the gravity is already overridden...\n\n    if (this._isGravityOverridden) {\n      // ENGAGE 2-SCM & REMOVE SELECTION ATTRIBUTE\n      // when about to leave one attribute value and enter another:\n      //\n      // \t\t<paragraph><$text attribute=\"1\">foo</$text><$text attribute=\"2\">{}bar</$text></paragraph>\n      //\n      // but DON'T when already in between of them (no attribute selection):\n      //\n      // \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n      //\n      if (isBetweenDifferentValues(position, attribute) && this._hasSelectionAttribute) {\n        this._preventCaretMovement(data);\n\n        this._restoreGravity();\n\n        this._removeSelectionAttribute();\n\n        return true;\n      } // ENGAGE 2-SCM when at any boundary of the attribute:\n      //\n      // \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n      // \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n      //\n      else {\n          this._preventCaretMovement(data);\n\n          this._restoreGravity(); // REMOVE SELECTION ATRIBUTE at the beginning of the block.\n          // It's like restoring gravity but towards a non-existent content when\n          // the gravity is overridden:\n          //\n          // \t\t<paragraph><$text attribute>{}bar</$text></paragraph>\n          //\n          // becomes:\n          //\n          // \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n          //\n\n\n          if (position.isAtStart) {\n            this._removeSelectionAttribute();\n          }\n\n          return true;\n        }\n    } else {\n      // ENGAGE 2-SCM when between two different attribute values but selection has no attribute:\n      //\n      // \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n      //\n      if (isBetweenDifferentValues(position, attribute) && !this._hasSelectionAttribute) {\n        this._preventCaretMovement(data);\n\n        this._setSelectionAttributeFromTheNodeBefore(position);\n\n        return true;\n      } // End of block boundary cases:\n      //\n      // \t\t<paragraph><$text attribute>bar{}</$text></paragraph>\n      // \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n      //\n\n\n      if (position.isAtEnd && isAtEndBoundary(position, attribute)) {\n        // DON'T ENGAGE 2-SCM if the selection has the attribute already.\n        // This is a common selection if set using the mouse.\n        //\n        // \t\t<paragraph><$text attribute>bar{}</$text></paragraph>\n        //\n        if (this._hasSelectionAttribute) {\n          // DON'T ENGAGE 2-SCM if the attribute at the end of the block which has length == 1.\n          // Make sure the selection will not the attribute after it moves backwards.\n          //\n          // \t\t<paragraph>foo<$text attribute>b{}</$text></paragraph>\n          //\n          if (isStepAfterTheAttributeBoundary(position, attribute)) {\n            // Skip the automatic gravity restore upon the next selection#change:range event.\n            // If not skipped, it would automatically restore the gravity, which should remain\n            // overridden.\n            this._skipNextAutomaticGravityRestoration();\n\n            this._overrideGravity(); // Don't return \"true\" here because we didn't call _preventCaretMovement.\n            // Returning here will destabilize the filler logic, which also listens to\n            // keydown (and the event would be stopped).\n\n          }\n\n          return;\n        } // ENGAGE 2-SCM if the selection has no attribute. This may happen when the user\n        // left the attribute using a FORWARD 2-SCM.\n        //\n        // \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n        //\n        else {\n            this._preventCaretMovement(data);\n\n            this._setSelectionAttributeFromTheNodeBefore(position);\n\n            return true;\n          }\n      } // REMOVE SELECTION ATRIBUTE when restoring gravity towards a non-existent content at the\n      // beginning of the block.\n      //\n      // \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n      //\n\n\n      if (position.isAtStart) {\n        if (this._hasSelectionAttribute) {\n          this._removeSelectionAttribute();\n\n          this._preventCaretMovement(data);\n\n          return true;\n        }\n\n        return;\n      } // DON'T ENGAGE 2-SCM when about to enter of leave an attribute.\n      // We need to check if the caret is a one position before the attribute boundary:\n      //\n      // \t\t<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>\n      // \t\t<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>\n      //\n\n\n      if (isStepAfterTheAttributeBoundary(position, attribute)) {\n        // Skip the automatic gravity restore upon the next selection#change:range event.\n        // If not skipped, it would automatically restore the gravity, which should remain\n        // overridden.\n        this._skipNextAutomaticGravityRestoration();\n\n        this._overrideGravity(); // Don't return \"true\" here because we didn't call _preventCaretMovement.\n        // Returning here will destabilize the filler logic, which also listens to\n        // keydown (and the event would be stopped).\n\n      }\n    }\n  }\n  /**\n   * `true` when the gravity is overridden for the {@link #attribute}.\n   *\n   * @readonly\n   * @private\n   * @type {Boolean}\n   */\n\n\n  get _isGravityOverridden() {\n    return !!this._overrideUid;\n  }\n  /**\n   * `true` when the {@link module:engine/model/selection~Selection} has the {@link #attribute}.\n   *\n   * @readonly\n   * @private\n   * @type {Boolean}\n   */\n\n\n  get _hasSelectionAttribute() {\n    return this._modelSelection.hasAttribute(this.attribute);\n  }\n  /**\n   * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}\n   * and stores the information about this fact in the {@link #_overrideUid}.\n   *\n   * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n   *\n   * @private\n   */\n\n\n  _overrideGravity() {\n    this._overrideUid = this.model.change(writer => writer.overrideSelectionGravity());\n  }\n  /**\n   * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.\n   *\n   * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.\n   *\n   * @private\n   */\n\n\n  _restoreGravity() {\n    this.model.change(writer => {\n      writer.restoreSelectionGravity(this._overrideUid);\n      this._overrideUid = null;\n    });\n  }\n  /**\n   * Prevents the caret movement in the view by calling `preventDefault` on the event data.\n   *\n   * @private\n   */\n\n\n  _preventCaretMovement(data) {\n    data.preventDefault();\n  }\n  /**\n   * Removes the {@link #attribute} from the selection using using the\n   * {@link module:engine/model/writer~Writer model writer}.\n   *\n   * @private\n   */\n\n\n  _removeSelectionAttribute() {\n    this.model.change(writer => {\n      writer.removeSelectionAttribute(this.attribute);\n    });\n  }\n  /**\n   * Applies the {@link #attribute} to the current selection using using the\n   * value from the node before the current position. Uses\n   * the {@link module:engine/model/writer~Writer model writer}.\n   *\n   * @private\n   * @param {module:engine/model/position~Position} position\n   */\n\n\n  _setSelectionAttributeFromTheNodeBefore(position) {\n    const attribute = this.attribute;\n    this.model.change(writer => {\n      writer.setSelectionAttribute(this.attribute, position.nodeBefore.getAttribute(attribute));\n    });\n  }\n  /**\n   * Skips the next automatic selection gravity restoration upon the\n   * {@link module:engine/model/selection~Selection#event:change:range} event.\n   *\n   * See {@link #_isNextGravityRestorationSkipped}.\n   *\n   * @private\n   */\n\n\n  _skipNextAutomaticGravityRestoration() {\n    this._isNextGravityRestorationSkipped = true;\n  }\n\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n// @returns {Boolean} `true` when position between the nodes sticks to the bound of text with given attribute.\n\nfunction isAtBoundary(position, attribute) {\n  return isAtStartBoundary(position, attribute) || isAtEndBoundary(position, attribute);\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isAtStartBoundary(position, attribute) {\n  const {\n    nodeBefore,\n    nodeAfter\n  } = position;\n  const isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;\n  const isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;\n  return isAttrAfter && (!isAttrBefore || nodeBefore.getAttribute(attribute) !== nodeAfter.getAttribute(attribute));\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isAtEndBoundary(position, attribute) {\n  const {\n    nodeBefore,\n    nodeAfter\n  } = position;\n  const isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;\n  const isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;\n  return isAttrBefore && (!isAttrAfter || nodeBefore.getAttribute(attribute) !== nodeAfter.getAttribute(attribute));\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isBetweenDifferentValues(position, attribute) {\n  const {\n    nodeBefore,\n    nodeAfter\n  } = position;\n  const isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;\n  const isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;\n\n  if (!isAttrAfter || !isAttrBefore) {\n    return;\n  }\n\n  return nodeAfter.getAttribute(attribute) !== nodeBefore.getAttribute(attribute);\n} // @param {module:engine/model/position~Position} position\n// @param {String} attribute\n\n\nfunction isStepAfterTheAttributeBoundary(position, attribute) {\n  return isAtBoundary(position.getShiftedBy(-1), attribute);\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-engine/src/utils/bindtwostepcarettoattribute.js"],"names":["keyCodes","priorities","bindTwoStepCaretToAttribute","view","model","emitter","attribute","locale","twoStepCaretHandler","TwoStepCaretHandler","modelSelection","document","selection","listenTo","evt","data","isCollapsed","shiftKey","altKey","ctrlKey","arrowRightPressed","keyCode","arrowright","arrowLeftPressed","arrowleft","position","getFirstPosition","contentDirection","contentLanguageDirection","isMovementHandled","handleForwardMovement","handleBackwardMovement","stop","priority","get","constructor","_modelSelection","_overrideUid","_isNextGravityRestorationSkipped","_isGravityOverridden","directChange","isAtBoundary","_restoreGravity","isAtStart","_hasSelectionAttribute","isBetweenDifferentValues","_preventCaretMovement","_removeSelectionAttribute","isAtStartBoundary","_overrideGravity","isAtEndBoundary","_setSelectionAttributeFromTheNodeBefore","isAtEnd","isStepAfterTheAttributeBoundary","_skipNextAutomaticGravityRestoration","hasAttribute","change","writer","overrideSelectionGravity","restoreSelectionGravity","preventDefault","removeSelectionAttribute","setSelectionAttribute","nodeBefore","getAttribute","nodeAfter","isAttrBefore","isAttrAfter","getShiftedBy"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,QAAT,QAAyB,wCAAzB;AACA,OAAOC,UAAP,MAAuB,0CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,2BAAT,CAAsC;AAAEC,EAAAA,IAAF;AAAQC,EAAAA,KAAR;AAAeC,EAAAA,OAAf;AAAwBC,EAAAA,SAAxB;AAAmCC,EAAAA;AAAnC,CAAtC,EAAoF;AAClG,QAAMC,mBAAmB,GAAG,IAAIC,mBAAJ,CAAyBL,KAAzB,EAAgCC,OAAhC,EAAyCC,SAAzC,CAA5B;AACA,QAAMI,cAAc,GAAGN,KAAK,CAACO,QAAN,CAAeC,SAAtC,CAFkG,CAIlG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAP,EAAAA,OAAO,CAACQ,QAAR,CAAkBV,IAAI,CAACQ,QAAvB,EAAiC,SAAjC,EAA4C,CAAEG,GAAF,EAAOC,IAAP,KAAiB;AAC5D;AACA,QAAK,CAACL,cAAc,CAACM,WAArB,EAAmC;AAClC;AACA,KAJ2D,CAM5D;AACA;;;AACA,QAAKD,IAAI,CAACE,QAAL,IAAiBF,IAAI,CAACG,MAAtB,IAAgCH,IAAI,CAACI,OAA1C,EAAoD;AACnD;AACA;;AAED,UAAMC,iBAAiB,GAAGL,IAAI,CAACM,OAAL,IAAgBrB,QAAQ,CAACsB,UAAnD;AACA,UAAMC,gBAAgB,GAAGR,IAAI,CAACM,OAAL,IAAgBrB,QAAQ,CA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/utils/bindtwostepcarettoattribute\n */\n\nimport { keyCodes } from '@ckeditor/ckeditor5-utils/src/keyboard';\nimport priorities from '@ckeditor/ckeditor5-utils/src/priorities';\n\n/**\n * This helper enables the two-step caret (phantom) movement behavior for the given {@link module:engine/model/model~Model}\n * attribute on arrow right (<kbd>→</kbd>) and left (<kbd>←</kbd>) key press.\n *\n * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the\n * beginning/end of an attribute.\n *\n * **Note:** This helper support right–to–left (Arabic, Hebrew, etc.) content by mirroring its behavior\n * but for the sake of simplicity examples showcase only left–to–right use–cases.\n *\n * # Forward movement\n *\n * ## \"Entering\" an attribute:\n *\n * When this behavior is enabled for the `a` attribute and the selection is right before it\n * (at the attribute boundary), pressing the right arrow key will not move the selection but update its\n * attributes accordingly:\n *\n * * When enabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *    <kbd>→</kbd>\n *\n *   \t\tfoo<$text a=\"true\">{}bar</$text>\n *\n * * When disabled:\n *\n *   \t\tfoo{}<$text a=\"true\">bar</$text>\n *\n *   <kbd>→</kbd>\n *\n *   \t\tfoo<$text a=\"true\">b{}ar</$text>\n *\n *\n * ## \"Leaving\" an attribute:\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *    <kbd>→</kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n *   <kbd>→</kbd>\n *\n *   \t\t<$text a=\"true\">bar</$text>b{}az\n *\n * # Backward movement\n *\n * * When enabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *    <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">bar{}</$text>baz\n *\n * * When disabled:\n *\n *   \t\t<$text a=\"true\">bar</$text>{}baz\n *\n *   <kbd>←</kbd>\n *\n *   \t\t<$text a=\"true\">ba{}r</$text>b{}az\n *\n * @param {Object} options Helper options.\n * @param {module:engine/view/view~View} options.view View controller instance.\n * @param {module:engine/model/model~Model} options.model Data model instance.\n * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior should be added\n * (e.g. a plugin instance).\n * @param {String} options.attribute Attribute for which this behavior will be added.\n * @param {module:utils/locale~Locale} options.locale The {@link module:core/editor/editor~Editor#locale} instance.\n */\nexport default function bindTwoStepCaretToAttribute( { view, model, emitter, attribute, locale } ) {\n\tconst twoStepCaretHandler = new TwoStepCaretHandler( model, emitter, attribute );\n\tconst modelSelection = model.document.selection;\n\n\t// Listen to keyboard events and handle the caret movement according to the 2-step caret logic.\n\t//\n\t// Note: This listener has the \"high+1\" priority:\n\t// * \"high\" because of the filler logic implemented in the renderer which also engages on #keydown.\n\t// When the gravity is overridden the attributes of the (model) selection attributes are reset.\n\t// It may end up with the filler kicking in and breaking the selection.\n\t// * \"+1\" because we would like to avoid collisions with other features (like Widgets), which\n\t// take over the keydown events with the \"high\" priority. Two-step caret movement takes precedence\n\t// over Widgets in that matter.\n\t//\n\t// Find out more in https://github.com/ckeditor/ckeditor5-engine/issues/1301.\n\temitter.listenTo( view.document, 'keydown', ( evt, data ) => {\n\t\t// This implementation works only for collapsed selection.\n\t\tif ( !modelSelection.isCollapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When user tries to expand the selection or jump over the whole word or to the beginning/end then\n\t\t// two-steps movement is not necessary.\n\t\tif ( data.shiftKey || data.altKey || data.ctrlKey ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst arrowRightPressed = data.keyCode == keyCodes.arrowright;\n\t\tconst arrowLeftPressed = data.keyCode == keyCodes.arrowleft;\n\n\t\t// When neither left or right arrow has been pressed then do noting.\n\t\tif ( !arrowRightPressed && !arrowLeftPressed ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst position = modelSelection.getFirstPosition();\n\t\tconst contentDirection = locale.contentLanguageDirection;\n\t\tlet isMovementHandled;\n\n\t\tif ( ( contentDirection === 'ltr' && arrowRightPressed ) || ( contentDirection === 'rtl' && arrowLeftPressed ) ) {\n\t\t\tisMovementHandled = twoStepCaretHandler.handleForwardMovement( position, data );\n\t\t} else {\n\t\t\tisMovementHandled = twoStepCaretHandler.handleBackwardMovement( position, data );\n\t\t}\n\n\t\t// Stop the keydown event if the two-step caret movement handled it. Avoid collisions\n\t\t// with other features which may also take over the caret movement (e.g. Widget).\n\t\tif ( isMovementHandled ) {\n\t\t\tevt.stop();\n\t\t}\n\t}, { priority: priorities.get( 'high' ) + 1 } );\n}\n\n/**\n * This is a protected helper–class for {@link module:engine/utils/bindtwostepcarettoattribute}.\n * It handles the state of the 2-step caret movement for a single {@link module:engine/model/model~Model}\n * attribute upon the `keypress` in the {@link module:engine/view/view~View}.\n *\n * @protected\n */\nexport class TwoStepCaretHandler {\n\t/*\n\t * Creates two step handler instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model instance.\n\t * @param {module:utils/dom/emittermixin~Emitter} emitter The emitter to which this behavior should be added\n\t * (e.g. a plugin instance).\n\t * @param {String} attribute Attribute for which the behavior will be added.\n\t */\n\tconstructor( model, emitter, attribute ) {\n\t\t/**\n\t\t * The model instance this class instance operates on.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model#schema}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * The Attribute this class instance operates on.\n\t\t *\n\t\t * @readonly\n\t\t * @member {String}\n\t\t */\n\t\tthis.attribute = attribute;\n\n\t\t/**\n\t\t * A reference to the document selection.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/selection~Selection}\n\t\t */\n\t\tthis._modelSelection = model.document.selection;\n\n\t\t/**\n\t\t * The current UID of the overridden gravity, as returned by\n\t\t * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._overrideUid = null;\n\n\t\t/**\n\t\t * A flag indicating that the automatic gravity restoration for this attribute\n\t\t * should not happen upon the next\n\t\t * {@link module:engine/model/selection~Selection#event:change:range} event.\n\t\t *\n\t\t * @private\n\t\t * @member {String}\n\t\t */\n\t\tthis._isNextGravityRestorationSkipped = false;\n\n\t\t// The automatic gravity restoration logic.\n\t\temitter.listenTo( this._modelSelection, 'change:range', ( evt, data ) => {\n\t\t\t// Skipping the automatic restoration is needed if the selection should change\n\t\t\t// but the gravity must remain overridden afterwards. See the #handleBackwardMovement\n\t\t\t// to learn more.\n\t\t\tif ( this._isNextGravityRestorationSkipped ) {\n\t\t\t\tthis._isNextGravityRestorationSkipped = false;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip automatic restore when the gravity is not overridden — simply, there's nothing to restore\n\t\t\t// at this moment.\n\t\t\tif ( !this._isGravityOverridden ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.\n\t\t\t// It means that e.g. if the change was external (collaboration) and the user had their\n\t\t\t// selection around the link, its gravity should remain intact in this change:range event.\n\t\t\tif ( !data.directChange && isAtBoundary( this._modelSelection.getFirstPosition(), attribute ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._restoreGravity();\n\t\t} );\n\t}\n\n\t/**\n\t * Updates the document selection and the view according to the two–step caret movement state\n\t * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n\t *\n\t * @param {module:engine/model/position~Position} position The model position at the moment of the key press.\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n\t * @returns {Boolean} `true` when the handler prevented caret movement\n\t */\n\thandleForwardMovement( position, data ) {\n\t\tconst attribute = this.attribute;\n\n\t\t// DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered\n\t\t//\n\t\t// \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n\t\t//\n\t\t// or left the attribute\n\t\t//\n\t\t// \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n\t\t//\n\t\t// and the gravity will be restored automatically.\n\t\tif ( this._isGravityOverridden ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the\n\t\t// attribute:\n\t\t// * when the selection was initially set there using the mouse,\n\t\t// * when the editor has just started\n\t\t//\n\t\t//\t\t<paragraph><$text attribute>{}bar</$text>baz</paragraph>\n\t\t//\n\t\tif ( position.isAtStart && this._hasSelectionAttribute ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// ENGAGE 2-SCM when about to leave one attribute value and enter another:\n\t\t//\n\t\t// \t\t<paragraph><$text attribute=\"1\">foo{}</$text><$text attribute=\"2\">bar</$text></paragraph>\n\t\t//\n\t\t// but DON'T when already in between of them (no attribute selection):\n\t\t//\n\t\t// \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n\t\t//\n\t\tif ( isBetweenDifferentValues( position, attribute ) && this._hasSelectionAttribute ) {\n\t\t\tthis._preventCaretMovement( data );\n\t\t\tthis._removeSelectionAttribute();\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// ENGAGE 2-SCM when entering an attribute:\n\t\t//\n\t\t// \t\t<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>\n\t\t//\n\t\tif ( isAtStartBoundary( position, attribute ) ) {\n\t\t\tthis._preventCaretMovement( data );\n\t\t\tthis._overrideGravity();\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// ENGAGE 2-SCM when leaving an attribute:\n\t\t//\n\t\t//\t\t<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>\n\t\t//\n\t\tif ( isAtEndBoundary( position, attribute ) && this._hasSelectionAttribute ) {\n\t\t\tthis._preventCaretMovement( data );\n\t\t\tthis._overrideGravity();\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Updates the document selection and the view according to the two–step caret movement state\n\t * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.\n\t *\n\t * @param {module:engine/model/position~Position} position The model position at the moment of the key press.\n\t * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.\n\t * @returns {Boolean} `true` when the handler prevented caret movement\n\t */\n\thandleBackwardMovement( position, data ) {\n\t\tconst attribute = this.attribute;\n\n\t\t// When the gravity is already overridden...\n\t\tif ( this._isGravityOverridden ) {\n\t\t\t// ENGAGE 2-SCM & REMOVE SELECTION ATTRIBUTE\n\t\t\t// when about to leave one attribute value and enter another:\n\t\t\t//\n\t\t\t// \t\t<paragraph><$text attribute=\"1\">foo</$text><$text attribute=\"2\">{}bar</$text></paragraph>\n\t\t\t//\n\t\t\t// but DON'T when already in between of them (no attribute selection):\n\t\t\t//\n\t\t\t// \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n\t\t\t//\n\t\t\tif ( isBetweenDifferentValues( position, attribute ) && this._hasSelectionAttribute ) {\n\t\t\t\tthis._preventCaretMovement( data );\n\t\t\t\tthis._restoreGravity();\n\t\t\t\tthis._removeSelectionAttribute();\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// ENGAGE 2-SCM when at any boundary of the attribute:\n\t\t\t//\n\t\t\t// \t\t<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>\n\t\t\t// \t\t<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>\n\t\t\t//\n\t\t\telse {\n\t\t\t\tthis._preventCaretMovement( data );\n\t\t\t\tthis._restoreGravity();\n\n\t\t\t\t// REMOVE SELECTION ATRIBUTE at the beginning of the block.\n\t\t\t\t// It's like restoring gravity but towards a non-existent content when\n\t\t\t\t// the gravity is overridden:\n\t\t\t\t//\n\t\t\t\t// \t\t<paragraph><$text attribute>{}bar</$text></paragraph>\n\t\t\t\t//\n\t\t\t\t// becomes:\n\t\t\t\t//\n\t\t\t\t// \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n\t\t\t\t//\n\t\t\t\tif ( position.isAtStart ) {\n\t\t\t\t\tthis._removeSelectionAttribute();\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\t// ENGAGE 2-SCM when between two different attribute values but selection has no attribute:\n\t\t\t//\n\t\t\t// \t\t<paragraph><$text attribute=\"1\">foo</$text>{}<$text attribute=\"2\">bar</$text></paragraph>\n\t\t\t//\n\t\t\tif ( isBetweenDifferentValues( position, attribute ) && !this._hasSelectionAttribute ) {\n\t\t\t\tthis._preventCaretMovement( data );\n\t\t\t\tthis._setSelectionAttributeFromTheNodeBefore( position );\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// End of block boundary cases:\n\t\t\t//\n\t\t\t// \t\t<paragraph><$text attribute>bar{}</$text></paragraph>\n\t\t\t// \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n\t\t\t//\n\t\t\tif ( position.isAtEnd && isAtEndBoundary( position, attribute ) ) {\n\t\t\t\t// DON'T ENGAGE 2-SCM if the selection has the attribute already.\n\t\t\t\t// This is a common selection if set using the mouse.\n\t\t\t\t//\n\t\t\t\t// \t\t<paragraph><$text attribute>bar{}</$text></paragraph>\n\t\t\t\t//\n\t\t\t\tif ( this._hasSelectionAttribute ) {\n\t\t\t\t\t// DON'T ENGAGE 2-SCM if the attribute at the end of the block which has length == 1.\n\t\t\t\t\t// Make sure the selection will not the attribute after it moves backwards.\n\t\t\t\t\t//\n\t\t\t\t\t// \t\t<paragraph>foo<$text attribute>b{}</$text></paragraph>\n\t\t\t\t\t//\n\t\t\t\t\tif ( isStepAfterTheAttributeBoundary( position, attribute ) ) {\n\t\t\t\t\t\t// Skip the automatic gravity restore upon the next selection#change:range event.\n\t\t\t\t\t\t// If not skipped, it would automatically restore the gravity, which should remain\n\t\t\t\t\t\t// overridden.\n\t\t\t\t\t\tthis._skipNextAutomaticGravityRestoration();\n\t\t\t\t\t\tthis._overrideGravity();\n\n\t\t\t\t\t\t// Don't return \"true\" here because we didn't call _preventCaretMovement.\n\t\t\t\t\t\t// Returning here will destabilize the filler logic, which also listens to\n\t\t\t\t\t\t// keydown (and the event would be stopped).\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// ENGAGE 2-SCM if the selection has no attribute. This may happen when the user\n\t\t\t\t// left the attribute using a FORWARD 2-SCM.\n\t\t\t\t//\n\t\t\t\t// \t\t<paragraph><$text attribute>bar</$text>{}</paragraph>\n\t\t\t\t//\n\t\t\t\telse {\n\t\t\t\t\tthis._preventCaretMovement( data );\n\t\t\t\t\tthis._setSelectionAttributeFromTheNodeBefore( position );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// REMOVE SELECTION ATRIBUTE when restoring gravity towards a non-existent content at the\n\t\t\t// beginning of the block.\n\t\t\t//\n\t\t\t// \t\t<paragraph>{}<$text attribute>bar</$text></paragraph>\n\t\t\t//\n\t\t\tif ( position.isAtStart ) {\n\t\t\t\tif ( this._hasSelectionAttribute ) {\n\t\t\t\t\tthis._removeSelectionAttribute();\n\t\t\t\t\tthis._preventCaretMovement( data );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// DON'T ENGAGE 2-SCM when about to enter of leave an attribute.\n\t\t\t// We need to check if the caret is a one position before the attribute boundary:\n\t\t\t//\n\t\t\t// \t\t<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>\n\t\t\t// \t\t<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>\n\t\t\t//\n\t\t\tif ( isStepAfterTheAttributeBoundary( position, attribute ) ) {\n\t\t\t\t// Skip the automatic gravity restore upon the next selection#change:range event.\n\t\t\t\t// If not skipped, it would automatically restore the gravity, which should remain\n\t\t\t\t// overridden.\n\t\t\t\tthis._skipNextAutomaticGravityRestoration();\n\t\t\t\tthis._overrideGravity();\n\n\t\t\t\t// Don't return \"true\" here because we didn't call _preventCaretMovement.\n\t\t\t\t// Returning here will destabilize the filler logic, which also listens to\n\t\t\t\t// keydown (and the event would be stopped).\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * `true` when the gravity is overridden for the {@link #attribute}.\n\t *\n\t * @readonly\n\t * @private\n\t * @type {Boolean}\n\t */\n\tget _isGravityOverridden() {\n\t\treturn !!this._overrideUid;\n\t}\n\n\t/**\n\t * `true` when the {@link module:engine/model/selection~Selection} has the {@link #attribute}.\n\t *\n\t * @readonly\n\t * @private\n\t * @type {Boolean}\n\t */\n\tget _hasSelectionAttribute() {\n\t\treturn this._modelSelection.hasAttribute( this.attribute );\n\t}\n\n\t/**\n\t * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}\n\t * and stores the information about this fact in the {@link #_overrideUid}.\n\t *\n\t * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.\n\t *\n\t * @private\n\t */\n\t_overrideGravity() {\n\t\tthis._overrideUid = this.model.change( writer => writer.overrideSelectionGravity() );\n\t}\n\n\t/**\n\t * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.\n\t *\n\t * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.\n\t *\n\t * @private\n\t */\n\t_restoreGravity() {\n\t\tthis.model.change( writer => {\n\t\t\twriter.restoreSelectionGravity( this._overrideUid );\n\t\t\tthis._overrideUid = null;\n\t\t} );\n\t}\n\n\t/**\n\t * Prevents the caret movement in the view by calling `preventDefault` on the event data.\n\t *\n\t * @private\n\t */\n\t_preventCaretMovement( data ) {\n\t\tdata.preventDefault();\n\t}\n\n\t/**\n\t * Removes the {@link #attribute} from the selection using using the\n\t * {@link module:engine/model/writer~Writer model writer}.\n\t *\n\t * @private\n\t */\n\t_removeSelectionAttribute() {\n\t\tthis.model.change( writer => {\n\t\t\twriter.removeSelectionAttribute( this.attribute );\n\t\t} );\n\t}\n\n\t/**\n\t * Applies the {@link #attribute} to the current selection using using the\n\t * value from the node before the current position. Uses\n\t * the {@link module:engine/model/writer~Writer model writer}.\n\t *\n\t * @private\n\t * @param {module:engine/model/position~Position} position\n\t */\n\t_setSelectionAttributeFromTheNodeBefore( position ) {\n\t\tconst attribute = this.attribute;\n\n\t\tthis.model.change( writer => {\n\t\t\twriter.setSelectionAttribute( this.attribute, position.nodeBefore.getAttribute( attribute ) );\n\t\t} );\n\t}\n\n\t/**\n\t * Skips the next automatic selection gravity restoration upon the\n\t * {@link module:engine/model/selection~Selection#event:change:range} event.\n\t *\n\t * See {@link #_isNextGravityRestorationSkipped}.\n\t *\n\t * @private\n\t */\n\t_skipNextAutomaticGravityRestoration() {\n\t\tthis._isNextGravityRestorationSkipped = true;\n\t}\n}\n\n// @param {module:engine/model/position~Position} position\n// @param {String} attribute\n// @returns {Boolean} `true` when position between the nodes sticks to the bound of text with given attribute.\nfunction isAtBoundary( position, attribute ) {\n\treturn isAtStartBoundary( position, attribute ) || isAtEndBoundary( position, attribute );\n}\n\n// @param {module:engine/model/position~Position} position\n// @param {String} attribute\nfunction isAtStartBoundary( position, attribute ) {\n\tconst { nodeBefore, nodeAfter } = position;\n\tconst isAttrBefore = nodeBefore ? nodeBefore.hasAttribute( attribute ) : false;\n\tconst isAttrAfter = nodeAfter ? nodeAfter.hasAttribute( attribute ) : false;\n\n\treturn isAttrAfter && ( !isAttrBefore || nodeBefore.getAttribute( attribute ) !== nodeAfter.getAttribute( attribute ) );\n}\n\n// @param {module:engine/model/position~Position} position\n// @param {String} attribute\nfunction isAtEndBoundary( position, attribute ) {\n\tconst { nodeBefore, nodeAfter } = position;\n\tconst isAttrBefore = nodeBefore ? nodeBefore.hasAttribute( attribute ) : false;\n\tconst isAttrAfter = nodeAfter ? nodeAfter.hasAttribute( attribute ) : false;\n\n\treturn isAttrBefore && ( !isAttrAfter || nodeBefore.getAttribute( attribute ) !== nodeAfter.getAttribute( attribute ) );\n}\n\n// @param {module:engine/model/position~Position} position\n// @param {String} attribute\nfunction isBetweenDifferentValues( position, attribute ) {\n\tconst { nodeBefore, nodeAfter } = position;\n\tconst isAttrBefore = nodeBefore ? nodeBefore.hasAttribute( attribute ) : false;\n\tconst isAttrAfter = nodeAfter ? nodeAfter.hasAttribute( attribute ) : false;\n\n\tif ( !isAttrAfter || !isAttrBefore ) {\n\t\treturn;\n\t}\n\n\treturn nodeAfter.getAttribute( attribute ) !== nodeBefore.getAttribute( attribute );\n}\n\n// @param {module:engine/model/position~Position} position\n// @param {String} attribute\nfunction isStepAfterTheAttributeBoundary( position, attribute ) {\n\treturn isAtBoundary( position.getShiftedBy( -1 ), attribute );\n}\n"]},"metadata":{},"sourceType":"module"}