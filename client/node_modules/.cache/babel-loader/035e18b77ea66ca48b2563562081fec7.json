{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/blockautoformatediting\n */\nimport LiveRange from '@ckeditor/ckeditor5-engine/src/model/liverange';\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\n\nexport default class BlockAutoformatEditing {\n  /**\n   * Creates a listener triggered on `change` event in the document.\n   * Calls the callback when inserted text matches the regular expression or the command name\n   * if provided instead of the callback.\n   *\n   * Examples of usage:\n   *\n   * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:\n   *\n   *\t\tnew BlockAutoformatEditing( editor, /^\\- $/, 'heading1' );\n   *\n   * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:\n   *\n   *\t\tnew BlockAutoformatEditing( editor, /^\\- $/, ( context ) => {\n   *\t\t\tconst { match } = context;\n   *\t\t\tconst headingLevel = match[ 1 ].length;\n   *\n   *\t\t\teditor.execute( 'heading', {\n   *\t\t\t\tformatId: `heading${ headingLevel }`\n   *\t\t\t} );\n   * \t\t} );\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   * @param {RegExp} pattern The regular expression to execute on just inserted text.\n   * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.\n   * In case of providing the callback, it receives the following parameter:\n   * * {Object} match RegExp.exec() result of matching the pattern to inserted text.\n   */\n  constructor(editor, pattern, callbackOrCommand) {\n    let callback;\n    let command = null;\n\n    if (typeof callbackOrCommand == 'function') {\n      callback = callbackOrCommand;\n    } else {\n      // We assume that the actual command name was provided.\n      command = editor.commands.get(callbackOrCommand);\n\n      callback = () => {\n        editor.execute(callbackOrCommand);\n      };\n    }\n\n    editor.model.document.on('change', (evt, batch) => {\n      if (command && !command.isEnabled) {\n        return;\n      }\n\n      if (batch.type == 'transparent') {\n        return;\n      }\n\n      const changes = Array.from(editor.model.document.differ.getChanges());\n      const entry = changes[0]; // Typing is represented by only a single change.\n\n      if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n        return;\n      }\n\n      const item = entry.position.textNode || entry.position.nodeAfter;\n\n      if (!item.parent.is('paragraph')) {\n        return;\n      }\n\n      const match = pattern.exec(item.data);\n\n      if (!match) {\n        return;\n      } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\n\n      editor.model.enqueueChange(writer => {\n        // Matched range.\n        const start = writer.createPositionAt(item.parent, 0);\n        const end = writer.createPositionAt(item.parent, match[0].length);\n        const range = new LiveRange(start, end);\n        const wasChanged = callback({\n          match\n        }); // Remove matched text.\n\n        if (wasChanged !== false) {\n          writer.remove(range);\n        }\n\n        range.detach();\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js"],"names":["LiveRange","BlockAutoformatEditing","constructor","editor","pattern","callbackOrCommand","callback","command","commands","get","execute","model","document","on","evt","batch","isEnabled","type","changes","Array","from","differ","getChanges","entry","length","name","item","position","textNode","nodeAfter","parent","is","match","exec","data","enqueueChange","writer","start","createPositionAt","end","range","wasChanged","remove","detach"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,SAAP,MAAsB,gDAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAMC,sBAAN,CAA6B;AAC3C;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,MAAF,EAAUC,OAAV,EAAmBC,iBAAnB,EAAuC;AACjD,QAAIC,QAAJ;AACA,QAAIC,OAAO,GAAG,IAAd;;AAEA,QAAK,OAAOF,iBAAP,IAA4B,UAAjC,EAA8C;AAC7CC,MAAAA,QAAQ,GAAGD,iBAAX;AACA,KAFD,MAEO;AACN;AACAE,MAAAA,OAAO,GAAGJ,MAAM,CAACK,QAAP,CAAgBC,GAAhB,CAAqBJ,iBAArB,CAAV;;AAEAC,MAAAA,QAAQ,GAAG,MAAM;AAChBH,QAAAA,MAAM,CAACO,OAAP,CAAgBL,iBAAhB;AACA,OAFD;AAGA;;AAEDF,IAAAA,MAAM,CAACQ,KAAP,CAAaC,QAAb,CAAsBC,EAAtB,CAA0B,QAA1B,EAAoC,CAAEC,GAAF,EAAOC,KAAP,KAAkB;AACrD,UAAKR,OAAO,IAAI,CAACA,OAAO,CAACS,SAAzB,EAAqC;AACpC;AACA;;AAED,UAAKD,KAAK,CAACE,IAAN,IAAc,aAAnB,EAAmC;AAClC;AACA;;AAED,YAAMC,OAAO,GAAGC,KAAK,CAACC,IAAN,CAAYjB,MAAM,CAACQ,KAAP,CAAaC,QAAb,CAAsBS,MAAtB,CAA6BC,UAA7B,EAAZ,CAAhB;AACA,YAAMC,KAAK,GAAGL,OAAO,CAAE,CAAF,CAArB,CAVqD,CAYrD;;AACA,UAAKA,OAAO,CAACM,MAAR,IAAkB,CAAlB,IAAuBD,KAAK,CAACN,IAAN,KAAe,QAAtC,IAAkDM,KAAK,CAACE,IAAN,IAAc,OAAhE,IAA2EF,KAAK,CAACC,MAAN,IAAgB,CAAhG,EAAoG;AACnG;AACA;;AAED,YAAME,IAAI,GAAGH,KAAK,CAACI,QAAN,CAAeC,QAAf,IAA2BL,KAAK,CAACI,QAAN,CAAeE,SAAvD;;AAEA,UAAK,CAACH,IAAI,CAACI,MAAL,CAAYC,EAAZ,CAAgB,WAAhB,CAAN,EAAsC;AACrC;AACA;;AAED,YAAMC,KAAK,GAAG5B,OAAO,CAAC6B,IAAR,CAAcP,IAAI,CAACQ,IAAnB,CAAd;;AAEA,UAAK,CAACF,KAAN,EAAc;AACb;AACA,OA3BoD,CA6BrD;;;AACA7B,MAAAA,MAAM,CAACQ,KAAP,CAAawB,aAAb,CAA4BC,MAAM,IAAI;AACrC;AACA,cAAMC,KAAK,GAAGD,MAAM,CAACE,gBAAP,CAAyBZ,IAAI,CAACI,MAA9B,EAAsC,CAAtC,CAAd;AACA,cAAMS,GAAG,GAAGH,MAAM,CAACE,gBAAP,CAAyBZ,IAAI,CAACI,MAA9B,EAAsCE,KAAK,CAAE,CAAF,CAAL,CAAWR,MAAjD,CAAZ;AACA,cAAMgB,KAAK,GAAG,IAAIxC,SAAJ,CAAeqC,KAAf,EAAsBE,GAAtB,CAAd;AAEA,cAAME,UAAU,GAAGnC,QAAQ,CAAE;AAAE0B,UAAAA;AAAF,SAAF,CAA3B,CANqC,CAQrC;;AACA,YAAKS,UAAU,KAAK,KAApB,EAA4B;AAC3BL,UAAAA,MAAM,CAACM,MAAP,CAAeF,KAAf;AACA;;AAEDA,QAAAA,KAAK,CAACG,MAAN;AACA,OAdD;AAeA,KA7CD;AA8CA;;AA1F0C","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/blockautoformatediting\n */\n\nimport LiveRange from '@ckeditor/ckeditor5-engine/src/model/liverange';\n\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\nexport default class BlockAutoformatEditing {\n\t/**\n\t * Creates a listener triggered on `change` event in the document.\n\t * Calls the callback when inserted text matches the regular expression or the command name\n\t * if provided instead of the callback.\n\t *\n\t * Examples of usage:\n\t *\n\t * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:\n\t *\n\t *\t\tnew BlockAutoformatEditing( editor, /^\\- $/, 'heading1' );\n\t *\n\t * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:\n\t *\n\t *\t\tnew BlockAutoformatEditing( editor, /^\\- $/, ( context ) => {\n\t *\t\t\tconst { match } = context;\n\t *\t\t\tconst headingLevel = match[ 1 ].length;\n\t *\n\t *\t\t\teditor.execute( 'heading', {\n\t *\t\t\t\tformatId: `heading${ headingLevel }`\n\t *\t\t\t} );\n\t * \t\t} );\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t * @param {RegExp} pattern The regular expression to execute on just inserted text.\n\t * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.\n\t * In case of providing the callback, it receives the following parameter:\n\t * * {Object} match RegExp.exec() result of matching the pattern to inserted text.\n\t */\n\tconstructor( editor, pattern, callbackOrCommand ) {\n\t\tlet callback;\n\t\tlet command = null;\n\n\t\tif ( typeof callbackOrCommand == 'function' ) {\n\t\t\tcallback = callbackOrCommand;\n\t\t} else {\n\t\t\t// We assume that the actual command name was provided.\n\t\t\tcommand = editor.commands.get( callbackOrCommand );\n\n\t\t\tcallback = () => {\n\t\t\t\teditor.execute( callbackOrCommand );\n\t\t\t};\n\t\t}\n\n\t\teditor.model.document.on( 'change', ( evt, batch ) => {\n\t\t\tif ( command && !command.isEnabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( batch.type == 'transparent' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst changes = Array.from( editor.model.document.differ.getChanges() );\n\t\t\tconst entry = changes[ 0 ];\n\n\t\t\t// Typing is represented by only a single change.\n\t\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst item = entry.position.textNode || entry.position.nodeAfter;\n\n\t\t\tif ( !item.parent.is( 'paragraph' ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst match = pattern.exec( item.data );\n\n\t\t\tif ( !match ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\t\teditor.model.enqueueChange( writer => {\n\t\t\t\t// Matched range.\n\t\t\t\tconst start = writer.createPositionAt( item.parent, 0 );\n\t\t\t\tconst end = writer.createPositionAt( item.parent, match[ 0 ].length );\n\t\t\t\tconst range = new LiveRange( start, end );\n\n\t\t\t\tconst wasChanged = callback( { match } );\n\n\t\t\t\t// Remove matched text.\n\t\t\t\tif ( wasChanged !== false ) {\n\t\t\t\t\twriter.remove( range );\n\t\t\t\t}\n\n\t\t\t\trange.detach();\n\t\t\t} );\n\t\t} );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}