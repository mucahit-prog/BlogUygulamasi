{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/converters\n */\nimport { generateLiInUl, injectViewList, mergeViewLists, getSiblingListItem, positionAfterUiElements } from './utils';\nimport TreeWalker from '@ckeditor/ckeditor5-engine/src/model/treewalker';\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewInsertion(model) {\n  return (evt, data, conversionApi) => {\n    const consumable = conversionApi.consumable;\n\n    if (!consumable.test(data.item, 'insert') || !consumable.test(data.item, 'attribute:listType') || !consumable.test(data.item, 'attribute:listIndent')) {\n      return;\n    }\n\n    consumable.consume(data.item, 'insert');\n    consumable.consume(data.item, 'attribute:listType');\n    consumable.consume(data.item, 'attribute:listIndent');\n    const modelItem = data.item;\n    const viewItem = generateLiInUl(modelItem, conversionApi);\n    injectViewList(modelItem, viewItem, conversionApi, model);\n  };\n}\n/**\n * A model-to-view converter for the `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewRemove(model) {\n  return (evt, data, conversionApi) => {\n    const viewStart = conversionApi.mapper.toViewPosition(data.position).getLastMatchingPosition(value => !value.item.is('li'));\n    const viewItem = viewStart.nodeAfter;\n    const viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n    // This will create a view list with one view list item - the one to remove.\n\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Remove the list with the item to remove.\n\n    const viewList = viewItem.parent;\n    const viewListPrev = viewList.previousSibling;\n    const removeRange = viewWriter.createRangeOn(viewList);\n    const removed = viewWriter.remove(removeRange); // 3. Merge the whole created by breaking and removing the list.\n\n    if (viewListPrev && viewListPrev.nextSibling) {\n      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n    } // 4. Bring back nested list that was in the removed <li>.\n\n\n    const modelItem = conversionApi.mapper.toModelElement(viewItem);\n    hoistNestedLists(modelItem.getAttribute('listIndent') + 1, data.position, removeRange.start, viewItem, conversionApi, model); // 5. Unbind removed view item and all children.\n\n    for (const child of viewWriter.createRangeIn(removed).getItems()) {\n      conversionApi.mapper.unbindViewElement(child);\n    }\n\n    evt.stop();\n  };\n}\n/**\n * A model-to-view converter for the `type` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements and changing their name. The next {@link module:list/converters~modelViewMergeAfterChangeType}\n * converter will attempt to merge split nodes.\n *\n * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.\n * Check {@link module:list/todolistconverters~modelViewChangeType} to see an example of it.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewChangeType(evt, data, conversionApi) {\n  if (!conversionApi.consumable.consume(data.item, 'attribute:listType')) {\n    return;\n  }\n\n  const viewItem = conversionApi.mapper.toViewElement(data.item);\n  const viewWriter = conversionApi.writer; // Break the container after and before the list item.\n  // This will create a view list with one view list item -- the one that changed type.\n\n  viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n  viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // Change name of the view list that holds the changed view item.\n  // We cannot just change name property, because that would not render properly.\n\n  const viewList = viewItem.parent;\n  const listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n  viewWriter.rename(listName, viewList);\n}\n/**\n * A model-to-view converter that attempts to merge nodes split by {@link module:list/converters~modelViewChangeType}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewMergeAfterChangeType(evt, data, conversionApi) {\n  const viewItem = conversionApi.mapper.toViewElement(data.item);\n  const viewList = viewItem.parent;\n  const viewWriter = conversionApi.writer; // Merge the changed view list with other lists, if possible.\n\n  mergeViewLists(viewWriter, viewList, viewList.nextSibling);\n  mergeViewLists(viewWriter, viewList.previousSibling, viewList); // Consumable insertion of children inside the item. They are already handled by re-building the item in view.\n\n  for (const child of data.item.getChildren()) {\n    conversionApi.consumable.consume(child, 'insert');\n  }\n}\n/**\n * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function modelViewChangeIndent(model) {\n  return (evt, data, conversionApi) => {\n    if (!conversionApi.consumable.consume(data.item, 'attribute:listIndent')) {\n      return;\n    }\n\n    const viewItem = conversionApi.mapper.toViewElement(data.item);\n    const viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.\n    // This will create a view list with one view list item -- the one that changed type.\n\n    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));\n    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n\n    const viewList = viewItem.parent;\n    const viewListPrev = viewList.previousSibling;\n    const removeRange = viewWriter.createRangeOn(viewList);\n    viewWriter.remove(removeRange);\n\n    if (viewListPrev && viewListPrev.nextSibling) {\n      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);\n    } // 3. Bring back nested list that was in the removed <li>.\n\n\n    hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model); // 4. Inject view list like it is newly inserted.\n\n    injectViewList(data.item, viewItem, conversionApi, model); // 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n\n    for (const child of data.item.getChildren()) {\n      conversionApi.consumable.consume(child, 'insert');\n    }\n  };\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n *\t\t<paragraph>xxx</paragraph>       // Instead of this wrong view state:\n *\t\t<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewSplitOnInsert(evt, data, conversionApi) {\n  if (data.item.name != 'listItem') {\n    let viewPosition = conversionApi.mapper.toViewPosition(data.range.start);\n    const viewWriter = conversionApi.writer;\n    const lists = []; // Break multiple ULs/OLs if there are.\n    //\n    // Imagine following list:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //     1.1.2 --------\n    //     1.1.3 --------\n    //       1.1.3.1 --------\n    //   1.2 --------\n    //     1.2.1 --------\n    // 2 --------\n    //\n    // Insert paragraph after item 1.1.1:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //\n    // Lorem ipsum.\n    //\n    //     1.1.2 --------\n    //     1.1.3 --------\n    //       1.1.3.1 --------\n    //   1.2 --------\n    //     1.2.1 --------\n    // 2 --------\n    //\n    // In this case 1.1.2 has to become beginning of a new list.\n    // We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n    // Then we need to move those broken pieces one after another and merge:\n    //\n    // 1 --------\n    //   1.1 --------\n    //     1.1.1 --------\n    //\n    // Lorem ipsum.\n    //\n    // 1.1.2 --------\n    //   1.1.3 --------\n    //     1.1.3.1 --------\n    // 1.2 --------\n    //   1.2.1 --------\n    // 2 --------\n    //\n\n    while (viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol') {\n      viewPosition = viewWriter.breakContainer(viewPosition);\n\n      if (viewPosition.parent.name != 'li') {\n        break;\n      } // Remove lists that are after inserted element.\n      // They will be brought back later, below the inserted element.\n\n\n      const removeStart = viewPosition;\n      const removeEnd = viewWriter.createPositionAt(viewPosition.parent, 'end'); // Don't remove if there is nothing to remove.\n\n      if (!removeStart.isEqual(removeEnd)) {\n        const removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));\n        lists.push(removed);\n      }\n\n      viewPosition = viewWriter.createPositionAfter(viewPosition.parent);\n    } // Bring back removed lists.\n\n\n    if (lists.length > 0) {\n      for (let i = 0; i < lists.length; i++) {\n        const previousList = viewPosition.nodeBefore;\n        const insertedRange = viewWriter.insert(viewPosition, lists[i]);\n        viewPosition = insertedRange.end; // Don't merge first list! We want a split in that place (this is why this converter is introduced).\n\n        if (i > 0) {\n          const mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling); // If `mergePos` is in `previousList` it means that the lists got merged.\n          // In this case, we need to fix insert position.\n\n          if (mergePos && mergePos.parent == previousList) {\n            viewPosition.offset--;\n          }\n        }\n      } // Merge last inserted list with element after it.\n\n\n      mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);\n    }\n  }\n}\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul>\n *\t\t<paragraph>xxx</paragraph>       <p>xxx</p>\n *\t\t<listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\n\nexport function modelViewMergeAfter(evt, data, conversionApi) {\n  const viewPosition = conversionApi.mapper.toViewPosition(data.position);\n  const viewItemPrev = viewPosition.nodeBefore;\n  const viewItemNext = viewPosition.nodeAfter; // Merge lists if something (remove, move) was done from inside of list.\n  // Merging will be done only if both items are view lists of the same type.\n  // The check is done inside the helper function.\n\n  mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);\n}\n/**\n * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function viewModelConverter(evt, data, conversionApi) {\n  if (conversionApi.consumable.consume(data.viewItem, {\n    name: true\n  })) {\n    const writer = conversionApi.writer;\n    const conversionStore = this.conversionApi.store; // 1. Create `listItem` model element.\n\n    const listItem = writer.createElement('listItem'); // 2. Handle `listItem` model element attributes.\n\n    conversionStore.indent = conversionStore.indent || 0;\n    writer.setAttribute('listIndent', conversionStore.indent, listItem); // Set 'bulleted' as default. If this item is pasted into a context,\n\n    const type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n    writer.setAttribute('listType', type, listItem); // `listItem`s created recursively should have bigger indent.\n\n    conversionStore.indent++; // Try to find allowed parent for list item.\n\n    const splitResult = conversionApi.splitToAllowedParent(listItem, data.modelCursor); // When there is no allowed parent it means that list item cannot be converted at current model position\n    // and in any of position ancestors.\n\n    if (!splitResult) {\n      return;\n    }\n\n    writer.insert(listItem, splitResult.position);\n    const nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi);\n    conversionStore.indent--; // Result range starts before the first item and ends after the last.\n\n    data.modelRange = writer.createRange(data.modelCursor, nextPosition); // When `data.modelCursor` parent had to be split to insert list item...\n\n    if (splitResult.cursorParent) {\n      // Continue conversion in the split element.\n      data.modelCursor = writer.createPositionAt(splitResult.cursorParent, 0);\n    } else {\n      // Otherwise continue conversion after the last list item.\n      data.modelCursor = data.modelRange.end;\n    }\n  }\n}\n/**\n * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function cleanList(evt, data, conversionApi) {\n  if (conversionApi.consumable.test(data.viewItem, {\n    name: true\n  })) {\n    // Caching children because when we start removing them iterating fails.\n    const children = Array.from(data.viewItem.getChildren());\n\n    for (const child of children) {\n      if (!child.is('li')) {\n        child._remove();\n      }\n    }\n  }\n}\n/**\n * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\n\nexport function cleanListItem(evt, data, conversionApi) {\n  if (conversionApi.consumable.test(data.viewItem, {\n    name: true\n  })) {\n    if (data.viewItem.childCount === 0) {\n      return;\n    }\n\n    const children = [...data.viewItem.getChildren()];\n    let foundList = false;\n    let firstNode = true;\n\n    for (const child of children) {\n      if (foundList && !child.is('ul') && !child.is('ol')) {\n        child._remove();\n      }\n\n      if (child.is('text')) {\n        // If this is the first node and it's a text node, left-trim it.\n        if (firstNode) {\n          child._data = child.data.replace(/^\\s+/, '');\n        } // If this is the last text node before <ul> or <ol>, right-trim it.\n\n\n        if (!child.nextSibling || child.nextSibling.is('ul') || child.nextSibling.is('ol')) {\n          child._data = child.data.replace(/\\s+$/, '');\n        }\n      } else if (child.is('ul') || child.is('ol')) {\n        // If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n        foundList = true;\n      }\n\n      firstNode = false;\n    }\n  }\n}\n/**\n * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition\n * @param {module:engine/view/view~View} view A view instance.\n * @returns {Function}\n */\n\nexport function modelToViewPosition(view) {\n  return (evt, data) => {\n    if (data.isPhantom) {\n      return;\n    }\n\n    const modelItem = data.modelPosition.nodeBefore;\n\n    if (modelItem && modelItem.is('listItem')) {\n      const viewItem = data.mapper.toViewElement(modelItem);\n      const topmostViewList = viewItem.getAncestors().find(element => element.is('ul') || element.is('ol'));\n      const walker = view.createPositionAt(viewItem, 0).getWalker();\n\n      for (const value of walker) {\n        if (value.type == 'elementStart' && value.item.is('li')) {\n          data.viewPosition = value.previousPosition;\n          break;\n        } else if (value.type == 'elementEnd' && value.item == topmostViewList) {\n          data.viewPosition = value.nextPosition;\n          break;\n        }\n      }\n    }\n  };\n}\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\n\nexport function viewToModelPosition(model) {\n  return (evt, data) => {\n    const viewPos = data.viewPosition;\n    const viewParent = viewPos.parent;\n    const mapper = data.mapper;\n\n    if (viewParent.name == 'ul' || viewParent.name == 'ol') {\n      // Position is directly in <ul> or <ol>.\n      if (!viewPos.isAtEnd) {\n        // If position is not at the end, it must be before <li>.\n        // Get that <li>, map it to `listItem` and set model position before that `listItem`.\n        const modelNode = mapper.toModelElement(viewPos.nodeAfter);\n        data.modelPosition = model.createPositionBefore(modelNode);\n      } else {\n        // Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n        // There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n        // because that <li> may contain nested items.\n        // We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n        const modelNode = mapper.toModelElement(viewPos.nodeBefore);\n        const modelLength = mapper.getModelLength(viewPos.nodeBefore); // Then we get model position before mapped `listItem` and shift it accordingly.\n\n        data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);\n      }\n\n      evt.stop();\n    } else if (viewParent.name == 'li' && viewPos.nodeBefore && (viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol')) {\n      // In most cases when view position is in <li> it is in text and this is a correct position.\n      // However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n      const modelNode = mapper.toModelElement(viewParent); // Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n      // Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n\n      let modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n\n      let viewList = viewPos.nodeBefore;\n\n      while (viewList && (viewList.is('ul') || viewList.is('ol'))) {\n        modelLength += mapper.getModelLength(viewList);\n        viewList = viewList.previousSibling;\n      }\n\n      data.modelPosition = model.createPositionBefore(modelNode).getShiftedBy(modelLength);\n      evt.stop();\n    }\n  };\n}\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * The list structure after the middle element is removed:\n *\n * \t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n *\n * @param {module:engine/model/model~Model} model The data model.\n * @param {module:engine/model/writer~Writer} writer The writer to do changes with.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\n\nexport function modelChangePostFixer(model, writer) {\n  const changes = model.document.differ.getChanges();\n  const itemToListHead = new Map();\n  let applied = false;\n\n  for (const entry of changes) {\n    if (entry.type == 'insert' && entry.name == 'listItem') {\n      _addListToFix(entry.position);\n    } else if (entry.type == 'insert' && entry.name != 'listItem') {\n      if (entry.name != '$text') {\n        // In case of renamed element.\n        const item = entry.position.nodeAfter;\n\n        if (item.hasAttribute('listIndent')) {\n          writer.removeAttribute('listIndent', item);\n          applied = true;\n        }\n\n        if (item.hasAttribute('listType')) {\n          writer.removeAttribute('listType', item);\n          applied = true;\n        }\n      }\n\n      const posAfter = entry.position.getShiftedBy(entry.length);\n\n      _addListToFix(posAfter);\n    } else if (entry.type == 'remove' && entry.name == 'listItem') {\n      _addListToFix(entry.position);\n    } else if (entry.type == 'attribute' && entry.attributeKey == 'listIndent') {\n      _addListToFix(entry.range.start);\n    } else if (entry.type == 'attribute' && entry.attributeKey == 'listType') {\n      _addListToFix(entry.range.start);\n    }\n  }\n\n  for (const listHead of itemToListHead.values()) {\n    _fixListIndents(listHead);\n\n    _fixListTypes(listHead);\n  }\n\n  return applied;\n\n  function _addListToFix(position) {\n    const prev = position.nodeBefore;\n\n    if (!prev || !prev.is('listItem')) {\n      const item = position.nodeAfter;\n\n      if (item && item.is('listItem')) {\n        itemToListHead.set(item, item);\n      }\n    } else {\n      let listHead = prev;\n\n      if (itemToListHead.has(listHead)) {\n        return;\n      }\n\n      while (listHead.previousSibling && listHead.previousSibling.is('listItem')) {\n        listHead = listHead.previousSibling;\n\n        if (itemToListHead.has(listHead)) {\n          return;\n        }\n      }\n\n      itemToListHead.set(position.nodeBefore, listHead);\n    }\n  }\n\n  function _fixListIndents(item) {\n    let maxIndent = 0;\n    let fixBy = null;\n\n    while (item && item.is('listItem')) {\n      const itemIndent = item.getAttribute('listIndent');\n\n      if (itemIndent > maxIndent) {\n        let newIndent;\n\n        if (fixBy === null) {\n          fixBy = itemIndent - maxIndent;\n          newIndent = maxIndent;\n        } else {\n          if (fixBy > itemIndent) {\n            fixBy = itemIndent;\n          }\n\n          newIndent = itemIndent - fixBy;\n        }\n\n        writer.setAttribute('listIndent', newIndent, item);\n        applied = true;\n      } else {\n        fixBy = null;\n        maxIndent = item.getAttribute('listIndent') + 1;\n      }\n\n      item = item.nextSibling;\n    }\n  }\n\n  function _fixListTypes(item) {\n    let typesStack = [];\n    let prev = null;\n\n    while (item && item.is('listItem')) {\n      const itemIndent = item.getAttribute('listIndent');\n\n      if (prev && prev.getAttribute('listIndent') > itemIndent) {\n        typesStack = typesStack.slice(0, itemIndent + 1);\n      }\n\n      if (itemIndent != 0) {\n        if (typesStack[itemIndent]) {\n          const type = typesStack[itemIndent];\n\n          if (item.getAttribute('listType') != type) {\n            writer.setAttribute('listType', type, item);\n            applied = true;\n          }\n        } else {\n          typesStack[itemIndent] = item.getAttribute('listType');\n        }\n      }\n\n      prev = item;\n      item = item.nextSibling;\n    }\n  }\n}\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n *\t\t// At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n *\t\t//              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.\n */\n\nexport function modelIndentPasteFixer(evt, [content, selectable]) {\n  // Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n  // elements before it and there is no need to fix indents, because even if we insert that content into a list,\n  // that list will be broken.\n  // Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n  // would create incorrect model.\n  let item = content.is('documentFragment') ? content.getChild(0) : content;\n  let selection;\n\n  if (!selectable) {\n    selection = this.document.selection;\n  } else {\n    selection = this.createSelection(selectable);\n  }\n\n  if (item && item.is('listItem')) {\n    // Get a reference list item. Inserted list items will be fixed according to that item.\n    const pos = selection.getFirstPosition();\n    let refItem = null;\n\n    if (pos.parent.is('listItem')) {\n      refItem = pos.parent;\n    } else if (pos.nodeBefore && pos.nodeBefore.is('listItem')) {\n      refItem = pos.nodeBefore;\n    } // If there is `refItem` it means that we do insert list items into an existing list.\n\n\n    if (refItem) {\n      // First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n      // to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n      // Indent of all those items has to be adjusted to reference item.\n      const indentChange = refItem.getAttribute('listIndent'); // Fix only if there is anything to fix.\n\n      if (indentChange > 0) {\n        // Adjust indent of all \"first\" list items in inserted data.\n        while (item && item.is('listItem')) {\n          item._setAttribute('listIndent', item.getAttribute('listIndent') + indentChange);\n\n          item = item.nextSibling;\n        }\n      }\n    }\n  }\n} // Helper function that converts children of a given `<li>` view element into corresponding model elements.\n// The function maintains proper order of elements if model `listItem` is split during the conversion\n// due to block children conversion.\n//\n// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.\n// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.\n\nfunction viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {\n  const {\n    writer,\n    schema\n  } = conversionApi; // A position after the last inserted `listItem`.\n\n  let nextPosition = writer.createPositionAfter(listItemModel); // Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n  // in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n\n  for (const child of viewChildren) {\n    if (child.name == 'ul' || child.name == 'ol') {\n      // If the children is a list, we will insert its conversion result after currently handled `listItem`.\n      // Then, next insertion position will be set after all the new list items (and maybe other elements if\n      // something split list item).\n      //\n      // If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n      // should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n      nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;\n    } else {\n      // If this is not a list, try inserting content at the end of the currently handled `listItem`.\n      const result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, 'end')); // It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n      //\n      // <li><p>Foo</p></li>\n      //\n      // will be converted to:\n      //\n      // <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n      //\n\n      const convertedChild = result.modelRange.start.nodeAfter;\n      const wasSplit = convertedChild && convertedChild.is('element') && !schema.checkChild(listItemModel, convertedChild.name);\n\n      if (wasSplit) {\n        // As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n        //\n        // `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n        // that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n        //\n        //\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n        //\n        // However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n        //\n        //\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n        //\n        // or after an element if another element broken auto-paragraphed element:\n        //\n        //\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n        //\n        // We need to check for such cases and use proper list item and position based on it.\n        //\n        if (result.modelCursor.parent.is('listItem')) {\n          // (1).\n          listItemModel = result.modelCursor.parent;\n        } else {\n          // (2), (3).\n          listItemModel = findNextListItem(result.modelCursor);\n        }\n\n        nextPosition = writer.createPositionAfter(listItemModel);\n      }\n    }\n  }\n\n  return nextPosition;\n} // Helper function that seeks for a next list item starting from given `startPosition`.\n\n\nfunction findNextListItem(startPosition) {\n  const treeWalker = new TreeWalker({\n    startPosition\n  });\n  let value;\n\n  do {\n    value = treeWalker.next();\n  } while (!value.value.item.is('listItem'));\n\n  return value.value.item;\n} // Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n// to other given parameters.\n\n\nfunction hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {\n  // Find correct previous model list item element.\n  // The element has to have either same or smaller indent than given reference indent.\n  // This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n  // Keep in mind that such element might not be found, if removed item was the first item.\n  const prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {\n    sameIndent: true,\n    smallerIndent: true,\n    listIndent: nextIndent,\n    foo: 'b'\n  });\n  const mapper = conversionApi.mapper;\n  const viewWriter = conversionApi.writer; // Indent of found element or `null` if the element has not been found.\n\n  const prevIndent = prevModelItem ? prevModelItem.getAttribute('listIndent') : null;\n  let insertPosition;\n\n  if (!prevModelItem) {\n    // If element has not been found, simply insert lists at the position where the removed item was:\n    //\n    // Lorem ipsum.\n    // 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n    //   1.1 --------       <--- this is reference indent.\n    //     1.1.1 --------\n    //     1.1.2 --------\n    //   1.2 --------\n    //\n    // Becomes:\n    //\n    // Lorem ipsum.\n    // 1.1 --------\n    //   1.1.1 --------\n    //   1.1.2 --------\n    // 1.2 --------\n    insertPosition = viewRemoveStartPosition;\n  } else if (prevIndent == nextIndent) {\n    // If element has been found and has same indent as reference indent it means that nested items should\n    // become siblings of found element:\n    //\n    // 1 --------\n    //   1.1 --------\n    //   1.2 --------       <--- this is `prevModelItem`.\n    // 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n    //   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n    //   2.2 --------\n    //\n    // Becomes:\n    //\n    // 1 --------\n    //   1.1 --------\n    //   1.2 --------\n    //   2.1 --------\n    //   2.2 --------\n    const prevViewList = mapper.toViewElement(prevModelItem).parent;\n    insertPosition = viewWriter.createPositionAfter(prevViewList);\n  } else {\n    // If element has been found and has smaller indent as reference indent it means that nested items\n    // should become nested items of found item:\n    //\n    // 1 --------           <--- this is `prevModelItem`.\n    //   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n    //     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n    //     1.1.2 --------\n    //   1.2 --------\n    //\n    // Becomes:\n    //\n    // 1 --------\n    //   1.1.1 --------\n    //   1.1.2 --------\n    //   1.2 --------\n    //\n    // Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n    // because following item may have indent bigger only by one. But this is fixed by postfixer.\n    const modelPosition = model.createPositionAt(prevModelItem, 'end');\n    insertPosition = mapper.toViewPosition(modelPosition);\n  }\n\n  insertPosition = positionAfterUiElements(insertPosition); // Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n  // are inserted after the first list (no need to recalculate insertion position for them).\n\n  for (const child of [...viewRemovedItem.getChildren()]) {\n    if (child.is('ul') || child.is('ol')) {\n      insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;\n      mergeViewLists(viewWriter, child, child.nextSibling);\n      mergeViewLists(viewWriter, child.previousSibling, child);\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-list/src/converters.js"],"names":["generateLiInUl","injectViewList","mergeViewLists","getSiblingListItem","positionAfterUiElements","TreeWalker","modelViewInsertion","model","evt","data","conversionApi","consumable","test","item","consume","modelItem","viewItem","modelViewRemove","viewStart","mapper","toViewPosition","position","getLastMatchingPosition","value","is","nodeAfter","viewWriter","writer","breakContainer","createPositionBefore","createPositionAfter","viewList","parent","viewListPrev","previousSibling","removeRange","createRangeOn","removed","remove","nextSibling","toModelElement","hoistNestedLists","getAttribute","start","child","createRangeIn","getItems","unbindViewElement","stop","modelViewChangeType","toViewElement","listName","attributeNewValue","rename","modelViewMergeAfterChangeType","getChildren","modelViewChangeIndent","attributeOldValue","range","modelViewSplitOnInsert","name","viewPosition","lists","removeStart","removeEnd","createPositionAt","isEqual","createRange","push","length","i","previousList","nodeBefore","insertedRange","insert","end","mergePos","offset","modelViewMergeAfter","viewItemPrev","viewItemNext","viewModelConverter","conversionStore","store","listItem","createElement","indent","setAttribute","type","splitResult","splitToAllowedParent","modelCursor","nextPosition","viewToModelListItemChildrenConverter","modelRange","cursorParent","cleanList","children","Array","from","_remove","cleanListItem","childCount","foundList","firstNode","_data","replace","modelToViewPosition","view","isPhantom","modelPosition","topmostViewList","getAncestors","find","element","walker","getWalker","previousPosition","viewToModelPosition","viewPos","viewParent","isAtEnd","modelNode","modelLength","getModelLength","getShiftedBy","modelChangePostFixer","changes","document","differ","getChanges","itemToListHead","Map","applied","entry","_addListToFix","hasAttribute","removeAttribute","posAfter","attributeKey","listHead","values","_fixListIndents","_fixListTypes","prev","set","has","maxIndent","fixBy","itemIndent","newIndent","typesStack","slice","modelIndentPasteFixer","content","selectable","getChild","selection","createSelection","pos","getFirstPosition","refItem","indentChange","_setAttribute","listItemModel","viewChildren","schema","convertItem","result","convertedChild","wasSplit","checkChild","findNextListItem","startPosition","treeWalker","next","nextIndent","modelRemoveStartPosition","viewRemoveStartPosition","viewRemovedItem","prevModelItem","sameIndent","smallerIndent","listIndent","foo","prevIndent","insertPosition","prevViewList","move"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/converters\n */\n\nimport {\n\tgenerateLiInUl,\n\tinjectViewList,\n\tmergeViewLists,\n\tgetSiblingListItem,\n\tpositionAfterUiElements\n} from './utils';\nimport TreeWalker from '@ckeditor/ckeditor5-engine/src/model/treewalker';\n\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewInsertion( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst consumable = conversionApi.consumable;\n\n\t\tif ( !consumable.test( data.item, 'insert' ) ||\n\t\t\t!consumable.test( data.item, 'attribute:listType' ) ||\n\t\t\t!consumable.test( data.item, 'attribute:listIndent' )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsumable.consume( data.item, 'insert' );\n\t\tconsumable.consume( data.item, 'attribute:listType' );\n\t\tconsumable.consume( data.item, 'attribute:listIndent' );\n\n\t\tconst modelItem = data.item;\n\t\tconst viewItem = generateLiInUl( modelItem, conversionApi );\n\n\t\tinjectViewList( modelItem, viewItem, conversionApi, model );\n\t};\n}\n\n/**\n * A model-to-view converter for the `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewRemove( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position ).getLastMatchingPosition( value => !value.item.is( 'li' ) );\n\t\tconst viewItem = viewStart.nodeAfter;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// 1. Break the container after and before the list item.\n\t\t// This will create a view list with one view list item - the one to remove.\n\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t\t// 2. Remove the list with the item to remove.\n\t\tconst viewList = viewItem.parent;\n\t\tconst viewListPrev = viewList.previousSibling;\n\t\tconst removeRange = viewWriter.createRangeOn( viewList );\n\t\tconst removed = viewWriter.remove( removeRange );\n\n\t\t// 3. Merge the whole created by breaking and removing the list.\n\t\tif ( viewListPrev && viewListPrev.nextSibling ) {\n\t\t\tmergeViewLists( viewWriter, viewListPrev, viewListPrev.nextSibling );\n\t\t}\n\n\t\t// 4. Bring back nested list that was in the removed <li>.\n\t\tconst modelItem = conversionApi.mapper.toModelElement( viewItem );\n\n\t\thoistNestedLists( modelItem.getAttribute( 'listIndent' ) + 1, data.position, removeRange.start, viewItem, conversionApi, model );\n\n\t\t// 5. Unbind removed view item and all children.\n\t\tfor ( const child of viewWriter.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n/**\n * A model-to-view converter for the `type` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements and changing their name. The next {@link module:list/converters~modelViewMergeAfterChangeType}\n * converter will attempt to merge split nodes.\n *\n * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.\n * Check {@link module:list/todolistconverters~modelViewChangeType} to see an example of it.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewChangeType( evt, data, conversionApi ) {\n\tif ( !conversionApi.consumable.consume( data.item, 'attribute:listType' ) ) {\n\t\treturn;\n\t}\n\n\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\tconst viewWriter = conversionApi.writer;\n\n\t// Break the container after and before the list item.\n\t// This will create a view list with one view list item -- the one that changed type.\n\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t// Change name of the view list that holds the changed view item.\n\t// We cannot just change name property, because that would not render properly.\n\tconst viewList = viewItem.parent;\n\tconst listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n\n\tviewWriter.rename( listName, viewList );\n}\n\n/**\n * A model-to-view converter that attempts to merge nodes split by {@link module:list/converters~modelViewChangeType}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewMergeAfterChangeType( evt, data, conversionApi ) {\n\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\tconst viewList = viewItem.parent;\n\tconst viewWriter = conversionApi.writer;\n\n\t// Merge the changed view list with other lists, if possible.\n\tmergeViewLists( viewWriter, viewList, viewList.nextSibling );\n\tmergeViewLists( viewWriter, viewList.previousSibling, viewList );\n\n\t// Consumable insertion of children inside the item. They are already handled by re-building the item in view.\n\tfor ( const child of data.item.getChildren() ) {\n\t\tconversionApi.consumable.consume( child, 'insert' );\n\t}\n}\n\n/**\n * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewChangeIndent( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'attribute:listIndent' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// 1. Break the container after and before the list item.\n\t\t// This will create a view list with one view list item -- the one that changed type.\n\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t\t// 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n\t\tconst viewList = viewItem.parent;\n\t\tconst viewListPrev = viewList.previousSibling;\n\t\tconst removeRange = viewWriter.createRangeOn( viewList );\n\t\tviewWriter.remove( removeRange );\n\n\t\tif ( viewListPrev && viewListPrev.nextSibling ) {\n\t\t\tmergeViewLists( viewWriter, viewListPrev, viewListPrev.nextSibling );\n\t\t}\n\n\t\t// 3. Bring back nested list that was in the removed <li>.\n\t\thoistNestedLists( data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model );\n\n\t\t// 4. Inject view list like it is newly inserted.\n\t\tinjectViewList( data.item, viewItem, conversionApi, model );\n\n\t\t// 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n\t\tfor ( const child of data.item.getChildren() ) {\n\t\t\tconversionApi.consumable.consume( child, 'insert' );\n\t\t}\n\t};\n}\n\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n *\t\t<paragraph>xxx</paragraph>       // Instead of this wrong view state:\n *\t\t<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewSplitOnInsert( evt, data, conversionApi ) {\n\tif ( data.item.name != 'listItem' ) {\n\t\tlet viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst lists = [];\n\n\t\t// Break multiple ULs/OLs if there are.\n\t\t//\n\t\t// Imagine following list:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//     1.1.2 --------\n\t\t//     1.1.3 --------\n\t\t//       1.1.3.1 --------\n\t\t//   1.2 --------\n\t\t//     1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\t// Insert paragraph after item 1.1.1:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//\n\t\t// Lorem ipsum.\n\t\t//\n\t\t//     1.1.2 --------\n\t\t//     1.1.3 --------\n\t\t//       1.1.3.1 --------\n\t\t//   1.2 --------\n\t\t//     1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\t// In this case 1.1.2 has to become beginning of a new list.\n\t\t// We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n\t\t// Then we need to move those broken pieces one after another and merge:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//\n\t\t// Lorem ipsum.\n\t\t//\n\t\t// 1.1.2 --------\n\t\t//   1.1.3 --------\n\t\t//     1.1.3.1 --------\n\t\t// 1.2 --------\n\t\t//   1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\twhile ( viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol' ) {\n\t\t\tviewPosition = viewWriter.breakContainer( viewPosition );\n\n\t\t\tif ( viewPosition.parent.name != 'li' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Remove lists that are after inserted element.\n\t\t\t// They will be brought back later, below the inserted element.\n\t\t\tconst removeStart = viewPosition;\n\t\t\tconst removeEnd = viewWriter.createPositionAt( viewPosition.parent, 'end' );\n\n\t\t\t// Don't remove if there is nothing to remove.\n\t\t\tif ( !removeStart.isEqual( removeEnd ) ) {\n\t\t\t\tconst removed = viewWriter.remove( viewWriter.createRange( removeStart, removeEnd ) );\n\t\t\t\tlists.push( removed );\n\t\t\t}\n\n\t\t\tviewPosition = viewWriter.createPositionAfter( viewPosition.parent );\n\t\t}\n\n\t\t// Bring back removed lists.\n\t\tif ( lists.length > 0 ) {\n\t\t\tfor ( let i = 0; i < lists.length; i++ ) {\n\t\t\t\tconst previousList = viewPosition.nodeBefore;\n\t\t\t\tconst insertedRange = viewWriter.insert( viewPosition, lists[ i ] );\n\t\t\t\tviewPosition = insertedRange.end;\n\n\t\t\t\t// Don't merge first list! We want a split in that place (this is why this converter is introduced).\n\t\t\t\tif ( i > 0 ) {\n\t\t\t\t\tconst mergePos = mergeViewLists( viewWriter, previousList, previousList.nextSibling );\n\n\t\t\t\t\t// If `mergePos` is in `previousList` it means that the lists got merged.\n\t\t\t\t\t// In this case, we need to fix insert position.\n\t\t\t\t\tif ( mergePos && mergePos.parent == previousList ) {\n\t\t\t\t\t\tviewPosition.offset--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Merge last inserted list with element after it.\n\t\t\tmergeViewLists( viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter );\n\t\t}\n\t}\n}\n\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul>\n *\t\t<paragraph>xxx</paragraph>       <p>xxx</p>\n *\t\t<listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewMergeAfter( evt, data, conversionApi ) {\n\tconst viewPosition = conversionApi.mapper.toViewPosition( data.position );\n\tconst viewItemPrev = viewPosition.nodeBefore;\n\tconst viewItemNext = viewPosition.nodeAfter;\n\n\t// Merge lists if something (remove, move) was done from inside of list.\n\t// Merging will be done only if both items are view lists of the same type.\n\t// The check is done inside the helper function.\n\tmergeViewLists( conversionApi.writer, viewItemPrev, viewItemNext );\n}\n\n/**\n * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function viewModelConverter( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\tconst writer = conversionApi.writer;\n\t\tconst conversionStore = this.conversionApi.store;\n\n\t\t// 1. Create `listItem` model element.\n\t\tconst listItem = writer.createElement( 'listItem' );\n\n\t\t// 2. Handle `listItem` model element attributes.\n\t\tconversionStore.indent = conversionStore.indent || 0;\n\t\twriter.setAttribute( 'listIndent', conversionStore.indent, listItem );\n\n\t\t// Set 'bulleted' as default. If this item is pasted into a context,\n\t\tconst type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n\t\twriter.setAttribute( 'listType', type, listItem );\n\n\t\t// `listItem`s created recursively should have bigger indent.\n\t\tconversionStore.indent++;\n\n\t\t// Try to find allowed parent for list item.\n\t\tconst splitResult = conversionApi.splitToAllowedParent( listItem, data.modelCursor );\n\n\t\t// When there is no allowed parent it means that list item cannot be converted at current model position\n\t\t// and in any of position ancestors.\n\t\tif ( !splitResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\twriter.insert( listItem, splitResult.position );\n\n\t\tconst nextPosition = viewToModelListItemChildrenConverter( listItem, data.viewItem.getChildren(), conversionApi );\n\n\t\tconversionStore.indent--;\n\n\t\t// Result range starts before the first item and ends after the last.\n\t\tdata.modelRange = writer.createRange( data.modelCursor, nextPosition );\n\n\t\t// When `data.modelCursor` parent had to be split to insert list item...\n\t\tif ( splitResult.cursorParent ) {\n\t\t\t// Continue conversion in the split element.\n\t\t\tdata.modelCursor = writer.createPositionAt( splitResult.cursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise continue conversion after the last list item.\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t}\n}\n\n/**\n * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function cleanList( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.test( data.viewItem, { name: true } ) ) {\n\t\t// Caching children because when we start removing them iterating fails.\n\t\tconst children = Array.from( data.viewItem.getChildren() );\n\n\t\tfor ( const child of children ) {\n\t\t\tif ( !child.is( 'li' ) ) {\n\t\t\t\tchild._remove();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function cleanListItem( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.test( data.viewItem, { name: true } ) ) {\n\t\tif ( data.viewItem.childCount === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst children = [ ...data.viewItem.getChildren() ];\n\n\t\tlet foundList = false;\n\t\tlet firstNode = true;\n\n\t\tfor ( const child of children ) {\n\t\t\tif ( foundList && !child.is( 'ul' ) && !child.is( 'ol' ) ) {\n\t\t\t\tchild._remove();\n\t\t\t}\n\n\t\t\tif ( child.is( 'text' ) ) {\n\t\t\t\t// If this is the first node and it's a text node, left-trim it.\n\t\t\t\tif ( firstNode ) {\n\t\t\t\t\tchild._data = child.data.replace( /^\\s+/, '' );\n\t\t\t\t}\n\n\t\t\t\t// If this is the last text node before <ul> or <ol>, right-trim it.\n\t\t\t\tif ( !child.nextSibling || ( child.nextSibling.is( 'ul' ) || child.nextSibling.is( 'ol' ) ) ) {\n\t\t\t\t\tchild._data = child.data.replace( /\\s+$/, '' );\n\t\t\t\t}\n\t\t\t} else if ( child.is( 'ul' ) || child.is( 'ol' ) ) {\n\t\t\t\t// If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n\t\t\t\tfoundList = true;\n\t\t\t}\n\n\t\t\tfirstNode = false;\n\t\t}\n\t}\n}\n\n/**\n * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition\n * @param {module:engine/view/view~View} view A view instance.\n * @returns {Function}\n */\nexport function modelToViewPosition( view ) {\n\treturn ( evt, data ) => {\n\t\tif ( data.isPhantom ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelItem = data.modelPosition.nodeBefore;\n\n\t\tif ( modelItem && modelItem.is( 'listItem' ) ) {\n\t\t\tconst viewItem = data.mapper.toViewElement( modelItem );\n\t\t\tconst topmostViewList = viewItem.getAncestors().find( element => element.is( 'ul' ) || element.is( 'ol' ) );\n\t\t\tconst walker = view.createPositionAt( viewItem, 0 ).getWalker();\n\n\t\t\tfor ( const value of walker ) {\n\t\t\t\tif ( value.type == 'elementStart' && value.item.is( 'li' ) ) {\n\t\t\t\t\tdata.viewPosition = value.previousPosition;\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( value.type == 'elementEnd' && value.item == topmostViewList ) {\n\t\t\t\t\tdata.viewPosition = value.nextPosition;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function viewToModelPosition( model ) {\n\treturn ( evt, data ) => {\n\t\tconst viewPos = data.viewPosition;\n\t\tconst viewParent = viewPos.parent;\n\t\tconst mapper = data.mapper;\n\n\t\tif ( viewParent.name == 'ul' || viewParent.name == 'ol' ) {\n\t\t\t// Position is directly in <ul> or <ol>.\n\t\t\tif ( !viewPos.isAtEnd ) {\n\t\t\t\t// If position is not at the end, it must be before <li>.\n\t\t\t\t// Get that <li>, map it to `listItem` and set model position before that `listItem`.\n\t\t\t\tconst modelNode = mapper.toModelElement( viewPos.nodeAfter );\n\n\t\t\t\tdata.modelPosition = model.createPositionBefore( modelNode );\n\t\t\t} else {\n\t\t\t\t// Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n\t\t\t\t// There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n\t\t\t\t// because that <li> may contain nested items.\n\t\t\t\t// We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n\t\t\t\tconst modelNode = mapper.toModelElement( viewPos.nodeBefore );\n\t\t\t\tconst modelLength = mapper.getModelLength( viewPos.nodeBefore );\n\n\t\t\t\t// Then we get model position before mapped `listItem` and shift it accordingly.\n\t\t\t\tdata.modelPosition = model.createPositionBefore( modelNode ).getShiftedBy( modelLength );\n\t\t\t}\n\n\t\t\tevt.stop();\n\t\t} else if (\n\t\t\tviewParent.name == 'li' &&\n\t\t\tviewPos.nodeBefore &&\n\t\t\t( viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol' )\n\t\t) {\n\t\t\t// In most cases when view position is in <li> it is in text and this is a correct position.\n\t\t\t// However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n\t\t\tconst modelNode = mapper.toModelElement( viewParent );\n\n\t\t\t// Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n\t\t\t// Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n\t\t\tlet modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n\t\t\tlet viewList = viewPos.nodeBefore;\n\n\t\t\twhile ( viewList && ( viewList.is( 'ul' ) || viewList.is( 'ol' ) ) ) {\n\t\t\t\tmodelLength += mapper.getModelLength( viewList );\n\n\t\t\t\tviewList = viewList.previousSibling;\n\t\t\t}\n\n\t\t\tdata.modelPosition = model.createPositionBefore( modelNode ).getShiftedBy( modelLength );\n\n\t\t\tevt.stop();\n\t\t}\n\t};\n}\n\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * The list structure after the middle element is removed:\n *\n * \t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n *\n * @param {module:engine/model/model~Model} model The data model.\n * @param {module:engine/model/writer~Writer} writer The writer to do changes with.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function modelChangePostFixer( model, writer ) {\n\tconst changes = model.document.differ.getChanges();\n\tconst itemToListHead = new Map();\n\n\tlet applied = false;\n\n\tfor ( const entry of changes ) {\n\t\tif ( entry.type == 'insert' && entry.name == 'listItem' ) {\n\t\t\t_addListToFix( entry.position );\n\t\t} else if ( entry.type == 'insert' && entry.name != 'listItem' ) {\n\t\t\tif ( entry.name != '$text' ) {\n\t\t\t\t// In case of renamed element.\n\t\t\t\tconst item = entry.position.nodeAfter;\n\n\t\t\t\tif ( item.hasAttribute( 'listIndent' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listIndent', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\n\t\t\t\tif ( item.hasAttribute( 'listType' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listType', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst posAfter = entry.position.getShiftedBy( entry.length );\n\n\t\t\t_addListToFix( posAfter );\n\t\t} else if ( entry.type == 'remove' && entry.name == 'listItem' ) {\n\t\t\t_addListToFix( entry.position );\n\t\t} else if ( entry.type == 'attribute' && entry.attributeKey == 'listIndent' ) {\n\t\t\t_addListToFix( entry.range.start );\n\t\t} else if ( entry.type == 'attribute' && entry.attributeKey == 'listType' ) {\n\t\t\t_addListToFix( entry.range.start );\n\t\t}\n\t}\n\n\tfor ( const listHead of itemToListHead.values() ) {\n\t\t_fixListIndents( listHead );\n\t\t_fixListTypes( listHead );\n\t}\n\n\treturn applied;\n\n\tfunction _addListToFix( position ) {\n\t\tconst prev = position.nodeBefore;\n\n\t\tif ( !prev || !prev.is( 'listItem' ) ) {\n\t\t\tconst item = position.nodeAfter;\n\n\t\t\tif ( item && item.is( 'listItem' ) ) {\n\t\t\t\titemToListHead.set( item, item );\n\t\t\t}\n\t\t} else {\n\t\t\tlet listHead = prev;\n\n\t\t\tif ( itemToListHead.has( listHead ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twhile ( listHead.previousSibling && listHead.previousSibling.is( 'listItem' ) ) {\n\t\t\t\tlistHead = listHead.previousSibling;\n\n\t\t\t\tif ( itemToListHead.has( listHead ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titemToListHead.set( position.nodeBefore, listHead );\n\t\t}\n\t}\n\n\tfunction _fixListIndents( item ) {\n\t\tlet maxIndent = 0;\n\t\tlet fixBy = null;\n\n\t\twhile ( item && item.is( 'listItem' ) ) {\n\t\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\t\tif ( itemIndent > maxIndent ) {\n\t\t\t\tlet newIndent;\n\n\t\t\t\tif ( fixBy === null ) {\n\t\t\t\t\tfixBy = itemIndent - maxIndent;\n\t\t\t\t\tnewIndent = maxIndent;\n\t\t\t\t} else {\n\t\t\t\t\tif ( fixBy > itemIndent ) {\n\t\t\t\t\t\tfixBy = itemIndent;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewIndent = itemIndent - fixBy;\n\t\t\t\t}\n\n\t\t\t\twriter.setAttribute( 'listIndent', newIndent, item );\n\n\t\t\t\tapplied = true;\n\t\t\t} else {\n\t\t\t\tfixBy = null;\n\t\t\t\tmaxIndent = item.getAttribute( 'listIndent' ) + 1;\n\t\t\t}\n\n\t\t\titem = item.nextSibling;\n\t\t}\n\t}\n\n\tfunction _fixListTypes( item ) {\n\t\tlet typesStack = [];\n\t\tlet prev = null;\n\n\t\twhile ( item && item.is( 'listItem' ) ) {\n\t\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\t\tif ( prev && prev.getAttribute( 'listIndent' ) > itemIndent ) {\n\t\t\t\ttypesStack = typesStack.slice( 0, itemIndent + 1 );\n\t\t\t}\n\n\t\t\tif ( itemIndent != 0 ) {\n\t\t\t\tif ( typesStack[ itemIndent ] ) {\n\t\t\t\t\tconst type = typesStack[ itemIndent ];\n\n\t\t\t\t\tif ( item.getAttribute( 'listType' ) != type ) {\n\t\t\t\t\t\twriter.setAttribute( 'listType', type, item );\n\n\t\t\t\t\t\tapplied = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttypesStack[ itemIndent ] = item.getAttribute( 'listType' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev = item;\n\t\t\titem = item.nextSibling;\n\t\t}\n\t}\n}\n\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n *\t\t// At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n *\t\t//              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.\n */\nexport function modelIndentPasteFixer( evt, [ content, selectable ] ) {\n\t// Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n\t// elements before it and there is no need to fix indents, because even if we insert that content into a list,\n\t// that list will be broken.\n\t// Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n\t// would create incorrect model.\n\tlet item = content.is( 'documentFragment' ) ? content.getChild( 0 ) : content;\n\n\tlet selection;\n\n\tif ( !selectable ) {\n\t\tselection = this.document.selection;\n\t} else {\n\t\tselection = this.createSelection( selectable );\n\t}\n\n\tif ( item && item.is( 'listItem' ) ) {\n\t\t// Get a reference list item. Inserted list items will be fixed according to that item.\n\t\tconst pos = selection.getFirstPosition();\n\t\tlet refItem = null;\n\n\t\tif ( pos.parent.is( 'listItem' ) ) {\n\t\t\trefItem = pos.parent;\n\t\t} else if ( pos.nodeBefore && pos.nodeBefore.is( 'listItem' ) ) {\n\t\t\trefItem = pos.nodeBefore;\n\t\t}\n\n\t\t// If there is `refItem` it means that we do insert list items into an existing list.\n\t\tif ( refItem ) {\n\t\t\t// First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n\t\t\t// to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n\t\t\t// Indent of all those items has to be adjusted to reference item.\n\t\t\tconst indentChange = refItem.getAttribute( 'listIndent' );\n\n\t\t\t// Fix only if there is anything to fix.\n\t\t\tif ( indentChange > 0 ) {\n\t\t\t\t// Adjust indent of all \"first\" list items in inserted data.\n\t\t\t\twhile ( item && item.is( 'listItem' ) ) {\n\t\t\t\t\titem._setAttribute( 'listIndent', item.getAttribute( 'listIndent' ) + indentChange );\n\n\t\t\t\t\titem = item.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function that converts children of a given `<li>` view element into corresponding model elements.\n// The function maintains proper order of elements if model `listItem` is split during the conversion\n// due to block children conversion.\n//\n// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.\n// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.\nfunction viewToModelListItemChildrenConverter( listItemModel, viewChildren, conversionApi ) {\n\tconst { writer, schema } = conversionApi;\n\n\t// A position after the last inserted `listItem`.\n\tlet nextPosition = writer.createPositionAfter( listItemModel );\n\n\t// Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n\t// in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n\tfor ( const child of viewChildren ) {\n\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t\t\t// If the children is a list, we will insert its conversion result after currently handled `listItem`.\n\t\t\t// Then, next insertion position will be set after all the new list items (and maybe other elements if\n\t\t\t// something split list item).\n\t\t\t//\n\t\t\t// If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n\t\t\t// should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n\t\t\tnextPosition = conversionApi.convertItem( child, nextPosition ).modelCursor;\n\t\t} else {\n\t\t\t// If this is not a list, try inserting content at the end of the currently handled `listItem`.\n\t\t\tconst result = conversionApi.convertItem( child, writer.createPositionAt( listItemModel, 'end' ) );\n\n\t\t\t// It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n\t\t\t//\n\t\t\t// <li><p>Foo</p></li>\n\t\t\t//\n\t\t\t// will be converted to:\n\t\t\t//\n\t\t\t// <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n\t\t\t//\n\t\t\tconst convertedChild = result.modelRange.start.nodeAfter;\n\t\t\tconst wasSplit = convertedChild && convertedChild.is( 'element' ) && !schema.checkChild( listItemModel, convertedChild.name );\n\n\t\t\tif ( wasSplit ) {\n\t\t\t\t// As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n\t\t\t\t//\n\t\t\t\t// `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n\t\t\t\t// that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n\t\t\t\t//\n\t\t\t\t// However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n\t\t\t\t//\n\t\t\t\t// or after an element if another element broken auto-paragraphed element:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n\t\t\t\t//\n\t\t\t\t// We need to check for such cases and use proper list item and position based on it.\n\t\t\t\t//\n\t\t\t\tif ( result.modelCursor.parent.is( 'listItem' ) ) {\n\t\t\t\t\t// (1).\n\t\t\t\t\tlistItemModel = result.modelCursor.parent;\n\t\t\t\t} else {\n\t\t\t\t\t// (2), (3).\n\t\t\t\t\tlistItemModel = findNextListItem( result.modelCursor );\n\t\t\t\t}\n\n\t\t\t\tnextPosition = writer.createPositionAfter( listItemModel );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nextPosition;\n}\n\n// Helper function that seeks for a next list item starting from given `startPosition`.\nfunction findNextListItem( startPosition ) {\n\tconst treeWalker = new TreeWalker( { startPosition } );\n\n\tlet value;\n\n\tdo {\n\t\tvalue = treeWalker.next();\n\t} while ( !value.value.item.is( 'listItem' ) );\n\n\treturn value.value.item;\n}\n\n// Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n// to other given parameters.\nfunction hoistNestedLists( nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model ) {\n\t// Find correct previous model list item element.\n\t// The element has to have either same or smaller indent than given reference indent.\n\t// This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n\t// Keep in mind that such element might not be found, if removed item was the first item.\n\tconst prevModelItem = getSiblingListItem( modelRemoveStartPosition.nodeBefore, {\n\t\tsameIndent: true,\n\t\tsmallerIndent: true,\n\t\tlistIndent: nextIndent,\n\t\tfoo: 'b'\n\t} );\n\n\tconst mapper = conversionApi.mapper;\n\tconst viewWriter = conversionApi.writer;\n\n\t// Indent of found element or `null` if the element has not been found.\n\tconst prevIndent = prevModelItem ? prevModelItem.getAttribute( 'listIndent' ) : null;\n\n\tlet insertPosition;\n\n\tif ( !prevModelItem ) {\n\t\t// If element has not been found, simply insert lists at the position where the removed item was:\n\t\t//\n\t\t// Lorem ipsum.\n\t\t// 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n\t\t//   1.1 --------       <--- this is reference indent.\n\t\t//     1.1.1 --------\n\t\t//     1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// Lorem ipsum.\n\t\t// 1.1 --------\n\t\t//   1.1.1 --------\n\t\t//   1.1.2 --------\n\t\t// 1.2 --------\n\t\tinsertPosition = viewRemoveStartPosition;\n\t} else if ( prevIndent == nextIndent ) {\n\t\t// If element has been found and has same indent as reference indent it means that nested items should\n\t\t// become siblings of found element:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//   1.2 --------       <--- this is `prevModelItem`.\n\t\t// 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n\t\t//   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n\t\t//   2.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//   1.2 --------\n\t\t//   2.1 --------\n\t\t//   2.2 --------\n\t\tconst prevViewList = mapper.toViewElement( prevModelItem ).parent;\n\t\tinsertPosition = viewWriter.createPositionAfter( prevViewList );\n\t} else {\n\t\t// If element has been found and has smaller indent as reference indent it means that nested items\n\t\t// should become nested items of found item:\n\t\t//\n\t\t// 1 --------           <--- this is `prevModelItem`.\n\t\t//   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n\t\t//     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n\t\t//     1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1.1 --------\n\t\t//   1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n\t\t// because following item may have indent bigger only by one. But this is fixed by postfixer.\n\t\tconst modelPosition = model.createPositionAt( prevModelItem, 'end' );\n\t\tinsertPosition = mapper.toViewPosition( modelPosition );\n\t}\n\n\tinsertPosition = positionAfterUiElements( insertPosition );\n\n\t// Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n\t// are inserted after the first list (no need to recalculate insertion position for them).\n\tfor ( const child of [ ...viewRemovedItem.getChildren() ] ) {\n\t\tif ( child.is( 'ul' ) || child.is( 'ol' ) ) {\n\t\t\tinsertPosition = viewWriter.move( viewWriter.createRangeOn( child ), insertPosition ).end;\n\n\t\t\tmergeViewLists( viewWriter, child, child.nextSibling );\n\t\t\tmergeViewLists( viewWriter, child.previousSibling, child );\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}