{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/upcasttable\n */\nimport { createEmptyTableCell } from '../commands/utils';\n/**\n * View table element to model table element conversion helper.\n *\n * This conversion helper converts the table element as well as table rows.\n *\n * @returns {Function} Conversion helper.\n */\n\nexport default function upcastTable() {\n  return dispatcher => {\n    dispatcher.on('element:table', (evt, data, conversionApi) => {\n      const viewTable = data.viewItem; // When element was already consumed then skip it.\n\n      if (!conversionApi.consumable.test(viewTable, {\n        name: true\n      })) {\n        return;\n      }\n\n      const {\n        rows,\n        headingRows,\n        headingColumns\n      } = scanTable(viewTable); // Only set attributes if values is greater then 0.\n\n      const attributes = {};\n\n      if (headingColumns) {\n        attributes.headingColumns = headingColumns;\n      }\n\n      if (headingRows) {\n        attributes.headingRows = headingRows;\n      }\n\n      const table = conversionApi.writer.createElement('table', attributes); // Insert element on allowed position.\n\n      const splitResult = conversionApi.splitToAllowedParent(table, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n      if (!splitResult) {\n        return;\n      }\n\n      conversionApi.writer.insert(table, splitResult.position);\n      conversionApi.consumable.consume(viewTable, {\n        name: true\n      });\n\n      if (rows.length) {\n        // Upcast table rows in proper order (heading rows first).\n        rows.forEach(row => conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table, 'end')));\n      } else {\n        // Create one row and one table cell for empty table.\n        const row = conversionApi.writer.createElement('tableRow');\n        conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table, 'end'));\n        createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, 'end'));\n      } // Set conversion result range.\n\n\n      data.modelRange = conversionApi.writer.createRange( // Range should start before inserted element\n      conversionApi.writer.createPositionBefore(table), // Should end after but we need to take into consideration that children could split our\n      // element, so we need to move range after parent of the last converted child.\n      // before: <allowed>[]</allowed>\n      // after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n      conversionApi.writer.createPositionAfter(table)); // Now we need to check where the modelCursor should be.\n      // If we had to split parent to insert our element then we want to continue conversion inside split parent.\n      //\n      // before: <allowed><notAllowed>[]</notAllowed></allowed>\n      // after:  <allowed><notAllowed></notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\n      if (splitResult.cursorParent) {\n        data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0); // Otherwise just continue after inserted element.\n      } else {\n        data.modelCursor = data.modelRange.end;\n      }\n    });\n  };\n}\nexport function upcastTableCell(elementName) {\n  return dispatcher => {\n    dispatcher.on(`element:${elementName}`, (evt, data, conversionApi) => {\n      const viewTableCell = data.viewItem; // When element was already consumed then skip it.\n\n      if (!conversionApi.consumable.test(viewTableCell, {\n        name: true\n      })) {\n        return;\n      }\n\n      const tableCell = conversionApi.writer.createElement('tableCell'); // Insert element on allowed position.\n\n      const splitResult = conversionApi.splitToAllowedParent(tableCell, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\n      if (!splitResult) {\n        return;\n      }\n\n      conversionApi.writer.insert(tableCell, splitResult.position);\n      conversionApi.consumable.consume(viewTableCell, {\n        name: true\n      });\n      const modelCursor = conversionApi.writer.createPositionAt(tableCell, 0);\n      conversionApi.convertChildren(viewTableCell, modelCursor); // Ensure a paragraph in the model for empty table cells.\n\n      if (!tableCell.childCount) {\n        conversionApi.writer.insertElement('paragraph', modelCursor);\n      } // Set conversion result range.\n\n\n      data.modelRange = conversionApi.writer.createRange( // Range should start before inserted element\n      conversionApi.writer.createPositionBefore(tableCell), // Should end after but we need to take into consideration that children could split our\n      // element, so we need to move range after parent of the last converted child.\n      // before: <allowed>[]</allowed>\n      // after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n      conversionApi.writer.createPositionAfter(tableCell)); // Continue after inserted element.\n\n      data.modelCursor = data.modelRange.end;\n    });\n  };\n} // Scans table rows and extracts required metadata from the table:\n//\n// headingRows    - the number of rows that goes as table header.\n// headingColumns - max number of row headings.\n// rows           - sorted `<tr>`s as they should go into the model - ie. if `<thead>` is inserted after `<tbody>` in the view.\n//\n// @param {module:engine/view/element~Element} viewTable\n// @returns {{headingRows, headingColumns, rows}}\n\nfunction scanTable(viewTable) {\n  const tableMeta = {\n    headingRows: 0,\n    headingColumns: 0\n  }; // The `<tbody>` and <thead> sections in the DOM do not have to be in order `<thead>` -> `<tbody>` and there might be more then one of\n  // them.\n  // As the model does not have those sections, rows from different sections must be sorted.\n  // For example, below is a valid HTML table:\n  //\n  //\t\t<table>\n  //\t\t\t<tbody><tr><td>2</td></tr></tbody>\n  //\t\t\t<thead><tr><td>1</td></tr></thead>\n  //\t\t\t<tbody><tr><td>3</td></tr></tbody>\n  //\t\t</table>\n  //\n  // But browsers will render rows in order as: 1 as heading and 2 and 3 as (body).\n\n  const headRows = [];\n  const bodyRows = []; // Currently the editor does not support more then one <thead> section.\n  // Only the first <thead> from the view will be used as heading rows and others will be converted to body rows.\n\n  let firstTheadElement;\n\n  for (const tableChild of Array.from(viewTable.getChildren())) {\n    // Only <thead>, <tbody> & <tfoot> from allowed table children can have <tr>s.\n    // The else is for future purposes (mainly <caption>).\n    if (tableChild.name === 'tbody' || tableChild.name === 'thead' || tableChild.name === 'tfoot') {\n      // Save the first <thead> in the table as table header - all other ones will be converted to table body rows.\n      if (tableChild.name === 'thead' && !firstTheadElement) {\n        firstTheadElement = tableChild;\n      } // There might be some extra empty text nodes between the `tr`s.\n      // Make sure further code operates on `tr`s only. (#145)\n\n\n      const trs = Array.from(tableChild.getChildren()).filter(el => el.is('element', 'tr'));\n\n      for (const tr of trs) {\n        // This <tr> is a child of a first <thead> element.\n        if (tr.parent.name === 'thead' && tr.parent === firstTheadElement) {\n          tableMeta.headingRows++;\n          headRows.push(tr);\n        } else {\n          bodyRows.push(tr); // For other rows check how many column headings this row has.\n\n          const headingCols = scanRowForHeadingColumns(tr, tableMeta, firstTheadElement);\n\n          if (headingCols > tableMeta.headingColumns) {\n            tableMeta.headingColumns = headingCols;\n          }\n        }\n      }\n    }\n  }\n\n  tableMeta.rows = [...headRows, ...bodyRows];\n  return tableMeta;\n} // Scans `<tr>` and its children for metadata:\n// - For heading row:\n//     - either adds this row to heading or body rows.\n//     - updates number of heading rows.\n// - For body rows:\n//     - calculates the number of column headings.\n//\n// @param {module:engine/view/element~Element} tr\n// @returns {Number}\n\n\nfunction scanRowForHeadingColumns(tr) {\n  let headingColumns = 0;\n  let index = 0; // Filter out empty text nodes from tr children.\n\n  const children = Array.from(tr.getChildren()).filter(child => child.name === 'th' || child.name === 'td'); // Count starting adjacent <th> elements of a <tr>.\n\n  while (index < children.length && children[index].name === 'th') {\n    const th = children[index]; // Adjust columns calculation by the number of spanned columns.\n\n    const colspan = parseInt(th.getAttribute('colspan') || 1);\n    headingColumns = headingColumns + colspan;\n    index++;\n  }\n\n  return headingColumns;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/converters/upcasttable.js"],"names":["createEmptyTableCell","upcastTable","dispatcher","on","evt","data","conversionApi","viewTable","viewItem","consumable","test","name","rows","headingRows","headingColumns","scanTable","attributes","table","writer","createElement","splitResult","splitToAllowedParent","modelCursor","insert","position","consume","length","forEach","row","convertItem","createPositionAt","modelRange","createRange","createPositionBefore","createPositionAfter","cursorParent","end","upcastTableCell","elementName","viewTableCell","tableCell","convertChildren","childCount","insertElement","tableMeta","headRows","bodyRows","firstTheadElement","tableChild","Array","from","getChildren","trs","filter","el","is","tr","parent","push","headingCols","scanRowForHeadingColumns","index","children","child","th","colspan","parseInt","getAttribute"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/upcasttable\n */\n\nimport { createEmptyTableCell } from '../commands/utils';\n\n/**\n * View table element to model table element conversion helper.\n *\n * This conversion helper converts the table element as well as table rows.\n *\n * @returns {Function} Conversion helper.\n */\nexport default function upcastTable() {\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element:table', ( evt, data, conversionApi ) => {\n\t\t\tconst viewTable = data.viewItem;\n\n\t\t\t// When element was already consumed then skip it.\n\t\t\tif ( !conversionApi.consumable.test( viewTable, { name: true } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { rows, headingRows, headingColumns } = scanTable( viewTable );\n\n\t\t\t// Only set attributes if values is greater then 0.\n\t\t\tconst attributes = {};\n\n\t\t\tif ( headingColumns ) {\n\t\t\t\tattributes.headingColumns = headingColumns;\n\t\t\t}\n\n\t\t\tif ( headingRows ) {\n\t\t\t\tattributes.headingRows = headingRows;\n\t\t\t}\n\n\t\t\tconst table = conversionApi.writer.createElement( 'table', attributes );\n\n\t\t\t// Insert element on allowed position.\n\t\t\tconst splitResult = conversionApi.splitToAllowedParent( table, data.modelCursor );\n\n\t\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\t\tif ( !splitResult ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconversionApi.writer.insert( table, splitResult.position );\n\t\t\tconversionApi.consumable.consume( viewTable, { name: true } );\n\n\t\t\tif ( rows.length ) {\n\t\t\t\t// Upcast table rows in proper order (heading rows first).\n\t\t\t\trows.forEach( row => conversionApi.convertItem( row, conversionApi.writer.createPositionAt( table, 'end' ) ) );\n\t\t\t} else {\n\t\t\t\t// Create one row and one table cell for empty table.\n\t\t\t\tconst row = conversionApi.writer.createElement( 'tableRow' );\n\t\t\t\tconversionApi.writer.insert( row, conversionApi.writer.createPositionAt( table, 'end' ) );\n\n\t\t\t\tcreateEmptyTableCell( conversionApi.writer, conversionApi.writer.createPositionAt( row, 'end' ) );\n\t\t\t}\n\n\t\t\t// Set conversion result range.\n\t\t\tdata.modelRange = conversionApi.writer.createRange(\n\t\t\t\t// Range should start before inserted element\n\t\t\t\tconversionApi.writer.createPositionBefore( table ),\n\t\t\t\t// Should end after but we need to take into consideration that children could split our\n\t\t\t\t// element, so we need to move range after parent of the last converted child.\n\t\t\t\t// before: <allowed>[]</allowed>\n\t\t\t\t// after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n\t\t\t\tconversionApi.writer.createPositionAfter( table )\n\t\t\t);\n\n\t\t\t// Now we need to check where the modelCursor should be.\n\t\t\t// If we had to split parent to insert our element then we want to continue conversion inside split parent.\n\t\t\t//\n\t\t\t// before: <allowed><notAllowed>[]</notAllowed></allowed>\n\t\t\t// after:  <allowed><notAllowed></notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\t\t\tif ( splitResult.cursorParent ) {\n\t\t\t\tdata.modelCursor = conversionApi.writer.createPositionAt( splitResult.cursorParent, 0 );\n\n\t\t\t\t// Otherwise just continue after inserted element.\n\t\t\t} else {\n\t\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t\t}\n\t\t} );\n\t};\n}\n\nexport function upcastTableCell( elementName ) {\n\treturn dispatcher => {\n\t\tdispatcher.on( `element:${ elementName }`, ( evt, data, conversionApi ) => {\n\t\t\tconst viewTableCell = data.viewItem;\n\n\t\t\t// When element was already consumed then skip it.\n\t\t\tif ( !conversionApi.consumable.test( viewTableCell, { name: true } ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tableCell = conversionApi.writer.createElement( 'tableCell' );\n\n\t\t\t// Insert element on allowed position.\n\t\t\tconst splitResult = conversionApi.splitToAllowedParent( tableCell, data.modelCursor );\n\n\t\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\t\tif ( !splitResult ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconversionApi.writer.insert( tableCell, splitResult.position );\n\t\t\tconversionApi.consumable.consume( viewTableCell, { name: true } );\n\n\t\t\tconst modelCursor = conversionApi.writer.createPositionAt( tableCell, 0 );\n\t\t\tconversionApi.convertChildren( viewTableCell, modelCursor );\n\n\t\t\t// Ensure a paragraph in the model for empty table cells.\n\t\t\tif ( !tableCell.childCount ) {\n\t\t\t\tconversionApi.writer.insertElement( 'paragraph', modelCursor );\n\t\t\t}\n\n\t\t\t// Set conversion result range.\n\t\t\tdata.modelRange = conversionApi.writer.createRange(\n\t\t\t\t// Range should start before inserted element\n\t\t\t\tconversionApi.writer.createPositionBefore( tableCell ),\n\t\t\t\t// Should end after but we need to take into consideration that children could split our\n\t\t\t\t// element, so we need to move range after parent of the last converted child.\n\t\t\t\t// before: <allowed>[]</allowed>\n\t\t\t\t// after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>\n\t\t\t\tconversionApi.writer.createPositionAfter( tableCell )\n\t\t\t);\n\n\t\t\t// Continue after inserted element.\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t} );\n\t};\n}\n\n// Scans table rows and extracts required metadata from the table:\n//\n// headingRows    - the number of rows that goes as table header.\n// headingColumns - max number of row headings.\n// rows           - sorted `<tr>`s as they should go into the model - ie. if `<thead>` is inserted after `<tbody>` in the view.\n//\n// @param {module:engine/view/element~Element} viewTable\n// @returns {{headingRows, headingColumns, rows}}\nfunction scanTable( viewTable ) {\n\tconst tableMeta = {\n\t\theadingRows: 0,\n\t\theadingColumns: 0\n\t};\n\n\t// The `<tbody>` and <thead> sections in the DOM do not have to be in order `<thead>` -> `<tbody>` and there might be more then one of\n\t// them.\n\t// As the model does not have those sections, rows from different sections must be sorted.\n\t// For example, below is a valid HTML table:\n\t//\n\t//\t\t<table>\n\t//\t\t\t<tbody><tr><td>2</td></tr></tbody>\n\t//\t\t\t<thead><tr><td>1</td></tr></thead>\n\t//\t\t\t<tbody><tr><td>3</td></tr></tbody>\n\t//\t\t</table>\n\t//\n\t// But browsers will render rows in order as: 1 as heading and 2 and 3 as (body).\n\tconst headRows = [];\n\tconst bodyRows = [];\n\n\t// Currently the editor does not support more then one <thead> section.\n\t// Only the first <thead> from the view will be used as heading rows and others will be converted to body rows.\n\tlet firstTheadElement;\n\n\tfor ( const tableChild of Array.from( viewTable.getChildren() ) ) {\n\t\t// Only <thead>, <tbody> & <tfoot> from allowed table children can have <tr>s.\n\t\t// The else is for future purposes (mainly <caption>).\n\t\tif ( tableChild.name === 'tbody' || tableChild.name === 'thead' || tableChild.name === 'tfoot' ) {\n\t\t\t// Save the first <thead> in the table as table header - all other ones will be converted to table body rows.\n\t\t\tif ( tableChild.name === 'thead' && !firstTheadElement ) {\n\t\t\t\tfirstTheadElement = tableChild;\n\t\t\t}\n\n\t\t\t// There might be some extra empty text nodes between the `tr`s.\n\t\t\t// Make sure further code operates on `tr`s only. (#145)\n\t\t\tconst trs = Array.from( tableChild.getChildren() ).filter( el => el.is( 'element', 'tr' ) );\n\n\t\t\tfor ( const tr of trs ) {\n\t\t\t\t// This <tr> is a child of a first <thead> element.\n\t\t\t\tif ( tr.parent.name === 'thead' && tr.parent === firstTheadElement ) {\n\t\t\t\t\ttableMeta.headingRows++;\n\t\t\t\t\theadRows.push( tr );\n\t\t\t\t} else {\n\t\t\t\t\tbodyRows.push( tr );\n\t\t\t\t\t// For other rows check how many column headings this row has.\n\n\t\t\t\t\tconst headingCols = scanRowForHeadingColumns( tr, tableMeta, firstTheadElement );\n\n\t\t\t\t\tif ( headingCols > tableMeta.headingColumns ) {\n\t\t\t\t\t\ttableMeta.headingColumns = headingCols;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttableMeta.rows = [ ...headRows, ...bodyRows ];\n\n\treturn tableMeta;\n}\n\n// Scans `<tr>` and its children for metadata:\n// - For heading row:\n//     - either adds this row to heading or body rows.\n//     - updates number of heading rows.\n// - For body rows:\n//     - calculates the number of column headings.\n//\n// @param {module:engine/view/element~Element} tr\n// @returns {Number}\nfunction scanRowForHeadingColumns( tr ) {\n\tlet headingColumns = 0;\n\tlet index = 0;\n\n\t// Filter out empty text nodes from tr children.\n\tconst children = Array.from( tr.getChildren() )\n\t\t.filter( child => child.name === 'th' || child.name === 'td' );\n\n\t// Count starting adjacent <th> elements of a <tr>.\n\twhile ( index < children.length && children[ index ].name === 'th' ) {\n\t\tconst th = children[ index ];\n\n\t\t// Adjust columns calculation by the number of spanned columns.\n\t\tconst colspan = parseInt( th.getAttribute( 'colspan' ) || 1 );\n\n\t\theadingColumns = headingColumns + colspan;\n\t\tindex++;\n\t}\n\n\treturn headingColumns;\n}\n"]},"metadata":{},"sourceType":"module"}