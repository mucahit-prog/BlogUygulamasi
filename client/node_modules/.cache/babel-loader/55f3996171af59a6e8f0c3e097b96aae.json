{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablewalker\n */\n\n/**\n * Table iterator class. It allows to iterate over table cells. For each cell the iterator yields\n * {@link module:table/tablewalker~TableWalkerValue} with proper table cell attributes.\n */\nexport default class TableWalker {\n  /**\n   * Creates an instance of the table walker.\n   *\n   *\n   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.\n   * It walks row by row and column by column in order to output values defined in the constructor.\n   * By default it will output only those locations that are occupied by a cell. To include also spanned rows and columns,\n   * pass the `includeSpanned` option to the constructor.\n   *\n   * The most important values of the iterator are column and row indexes of a cell.\n   *\n   * To iterate over a given row:\n   *\n   *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );\n   *\n   *\t\tfor ( const cellInfo of tableWalker ) {\n   *\t\t\tconsole.log( 'A cell at row ' + cellInfo.row + ' and column ' + cellInfo.column );\n   *\t\t}\n   *\n   * For instance the code above for the following table:\n   *\n   *\t\t+----+----+----+----+----+----+\n   *\t\t| 00      | 02 | 03 | 04 | 05 |\n   *\t\t|         +----+----+----+----+\n   *\t\t|         | 12      | 14 | 15 |\n   *\t\t|         +----+----+----+    +\n   *\t\t|         | 22           |    |\n   *\t\t|----+----+----+----+----+    +\n   *\t\t| 30 | 31 | 32 | 33 | 34 |    |\n   *\t\t+----+----+----+----+----+----+\n   *\n   * will log in the console:\n   *\n   *\t\t'A cell at row 1 and column 2'\n   *\t\t'A cell at row 1 and column 4'\n   *\t\t'A cell at row 1 and column 5'\n   *\t\t'A cell at row 2 and column 2'\n   *\n   * To also iterate over spanned cells:\n   *\n   *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 1, includeSpanned: true } );\n   *\n   *\t\tfor ( const cellInfo of tableWalker ) {\n   *\t\t\tconsole.log( 'Cell at ' + cellInfo.row + ' x ' + cellInfo.column + ' : ' + ( cellInfo.cell ? 'has data' : 'is spanned' ) );\n   *\t\t}\n   *\n   * will log in the console for the table from previous example:\n   *\n   *\t\t'Cell at 1 x 0 : is spanned'\n   *\t\t'Cell at 1 x 1 : is spanned'\n   *\t\t'Cell at 1 x 2 : has data'\n   *\t\t'Cell at 1 x 3 : is spanned'\n   *\t\t'Cell at 1 x 4 : has data'\n   *\t\t'Cell at 1 x 5 : has data'\n   *\n   * @constructor\n   * @param {module:engine/model/element~Element} table A table over which the walker iterates.\n   * @param {Object} [options={}] An object with configuration.\n   * @param {Number} [options.column] A column index for which this iterator will output cells.\n   * @param {Number} [options.startRow=0] A row index for which this iterator should start.\n   * @param {Number} [options.endRow] A row index for which this iterator should end.\n   * @param {Boolean} [options.includeSpanned] Also return values for spanned cells.\n   */\n  constructor(table, options = {}) {\n    /**\n     * The walker's table element.\n     *\n     * @readonly\n     * @member {module:engine/model/element~Element}\n     */\n    this.table = table;\n    /**\n     * A row index on which this iterator will start.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.startRow = options.startRow || 0;\n    /**\n     * A row index on which this iterator will end.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.endRow = typeof options.endRow == 'number' ? options.endRow : undefined;\n    /**\n     * Enables output of spanned cells that are normally not yielded.\n     *\n     * @readonly\n     * @member {Boolean}\n     */\n\n    this.includeSpanned = !!options.includeSpanned;\n    /**\n     * If set, the table walker will only output cells of a given column or cells that overlap it.\n     *\n     * @readonly\n     * @member {Number}\n     */\n\n    this.column = typeof options.column == 'number' ? options.column : undefined;\n    /**\n     * Row indexes to skip from the iteration.\n     *\n     * @readonly\n     * @member {Set<Number>}\n     * @private\n     */\n\n    this._skipRows = new Set();\n    /**\n     * The current row index.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._row = 0;\n    /**\n     * The current column index.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._column = 0;\n    /**\n     * The cell index in a parent row. For spanned cells when {@link #includeSpanned} is set to `true`,\n     * this represents the index of the next table cell.\n     *\n     * @readonly\n     * @member {Number}\n     * @private\n     */\n\n    this._cell = 0;\n    /**\n     * Holds a map of spanned cells in a table.\n     *\n     * @readonly\n     * @member {Map<Number, Map.<Number, Number>>}\n     * @private\n     */\n\n    this._spannedCells = new Map();\n  }\n  /**\n   * Iterable interface.\n   *\n   * @returns {Iterable.<module:table/tablewalker~TableWalkerValue>}\n   */\n\n\n  [Symbol.iterator]() {\n    return this;\n  }\n  /**\n   * Gets the next table walker's value.\n   *\n   * @returns {module:table/tablewalker~TableWalkerValue} The next table walker's value.\n   */\n\n\n  next() {\n    const row = this.table.getChild(this._row); // Iterator is done when no row (table end) or the row is after #endRow.\n\n    if (!row || this._isOverEndRow()) {\n      return {\n        done: true\n      };\n    } // Spanned cell location handling.\n\n\n    if (this._isSpanned(this._row, this._column)) {\n      // Current column must be kept as it will be updated before returning current value.\n      const currentColumn = this._column;\n\n      const outValue = this._formatOutValue(undefined, currentColumn); // Advance to next column - always.\n\n\n      this._column++;\n\n      const skipCurrentValue = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn(currentColumn, 1); // The current value will be returned only if #includedSpanned=true and also current row and column are not skipped.\n\n\n      return skipCurrentValue ? this.next() : outValue;\n    } // The cell location is not spanned by other cells.\n\n\n    const cell = row.getChild(this._cell);\n\n    if (!cell) {\n      // If there are no more cells left in row advance to next row.\n      this._row++; // And reset column & cell indexes.\n\n      this._column = 0;\n      this._cell = 0; // Return next value.\n\n      return this.next();\n    } // Read table cell attributes.\n\n\n    const colspan = parseInt(cell.getAttribute('colspan') || 1);\n    const rowspan = parseInt(cell.getAttribute('rowspan') || 1); // Record this cell spans if it's not 1x1 cell.\n\n    if (colspan > 1 || rowspan > 1) {\n      this._recordSpans(this._row, this._column, rowspan, colspan);\n    } // Current column must be kept as it will be updated before returning current value.\n\n\n    const currentColumn = this._column;\n\n    const outValue = this._formatOutValue(cell, currentColumn, rowspan, colspan); // Advance to next column before returning value.\n\n\n    this._column++; // Advance to next cell in a parent row before returning value.\n\n    this._cell++;\n\n    const skipCurrentValue = this._shouldSkipRow() || this._shouldSkipColumn(currentColumn, colspan); // The current value will be returned only if current row & column are not skipped.\n\n\n    return skipCurrentValue ? this.next() : outValue;\n  }\n  /**\n   * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row\n   * to output.\n   *\n   * @param {Number} row Row index to skip.\n   */\n\n\n  skipRow(row) {\n    this._skipRows.add(row);\n  }\n  /**\n   * Checks if the current row is over {@link #endRow}.\n   *\n   * @returns {Boolean}\n   * @private\n   */\n\n\n  _isOverEndRow() {\n    // If {@link #endRow) is defined skip all rows above it.\n    return this.endRow !== undefined && this._row > this.endRow;\n  }\n  /**\n   * A common method for formatting the iterator's output value.\n   *\n   * @param {module:engine/model/element~Element|undefined} cell The table cell to output. It might be undefined for spanned cell\n   * locations.\n   * @param {Number} column Column index (use the cached value)\n   * @param {Number} rowspan Rowspan of the current cell.\n   * @param {Number} colspan Colspan of the current cell.\n   * @returns {{done: boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}\n   * @private\n   */\n\n\n  _formatOutValue(cell, column, rowspan = 1, colspan = 1) {\n    return {\n      done: false,\n      value: {\n        cell,\n        row: this._row,\n        column,\n        rowspan,\n        colspan,\n        cellIndex: this._cell\n      }\n    };\n  }\n  /**\n   * Checks if the current row should be skipped.\n   *\n   * @returns {Boolean}\n   * @private\n   */\n\n\n  _shouldSkipRow() {\n    const rowIsBelowStartRow = this._row < this.startRow;\n\n    const rowIsMarkedAsSkipped = this._skipRows.has(this._row);\n\n    return rowIsBelowStartRow || rowIsMarkedAsSkipped;\n  }\n  /**\n   * Checks if the current column should be skipped.\n   *\n   * @param {Number} column\n   * @param {Number} colspan\n   * @returns {Boolean}\n   * @private\n   */\n\n\n  _shouldSkipColumn(column, colspan) {\n    if (this.column === undefined) {\n      // The {@link #column} is not defined so output all columns.\n      return false;\n    } // When outputting cells from given column we skip:\n    // - Cells that are not on that column.\n\n\n    const isCurrentColumn = column === this.column; // - CSells that are before given column and they overlaps given column.\n\n    const isPreviousThatOverlapsColumn = column < this.column && column + colspan > this.column;\n    return !isCurrentColumn && !isPreviousThatOverlapsColumn;\n  }\n  /**\n   * Checks if the current cell location (row x column) is spanned by another cell.\n   *\n   * @param {Number} row Row index of a cell location to check.\n   * @param {Number} column Column index of a cell location to check.\n   * @returns {Boolean}\n   * @private\n   */\n\n\n  _isSpanned(row, column) {\n    if (!this._spannedCells.has(row)) {\n      // No spans for given row.\n      return false;\n    }\n\n    const rowSpans = this._spannedCells.get(row); // If spans for given rows has entry for column it means that this location if spanned by other cell.\n\n\n    return rowSpans.has(column);\n  }\n  /**\n   * Updates spanned cells map relative to the current cell location and its span dimensions.\n   *\n   * @param {Number} row Row index of a cell.\n   * @param {Number} column Column index of a cell.\n   * @param {Number} rowspan Cell height.\n   * @param {Number} colspan Cell width.\n   * @private\n   */\n\n\n  _recordSpans(row, column, rowspan, colspan) {\n    // This will update all cell locations after current column - ie a cell has colspan set.\n    for (let columnToUpdate = column + 1; columnToUpdate <= column + colspan - 1; columnToUpdate++) {\n      this._markSpannedCell(row, columnToUpdate);\n    } // This will update all rows below current up to row's height.\n\n\n    for (let rowToUpdate = row + 1; rowToUpdate < row + rowspan; rowToUpdate++) {\n      for (let columnToUpdate = column; columnToUpdate <= column + colspan - 1; columnToUpdate++) {\n        this._markSpannedCell(rowToUpdate, columnToUpdate);\n      }\n    }\n  }\n  /**\n   * Marks the cell location as spanned by another cell.\n   *\n   * @param {Number} row Row index of the cell location.\n   * @param {Number} column Column index of the cell location.\n   * @private\n   */\n\n\n  _markSpannedCell(row, column) {\n    if (!this._spannedCells.has(row)) {\n      this._spannedCells.set(row, new Map());\n    }\n\n    const rowSpans = this._spannedCells.get(row);\n\n    rowSpans.set(column, true);\n  }\n\n}\n/**\n * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.\n *\n * @typedef {Object} module:table/tablewalker~TableWalkerValue\n * @property {module:engine/model/element~Element} [cell] The current table cell. Might be empty if\n * {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} row The row index of a cell.\n * @property {Number} column The column index of a cell. Column index is adjusted to widths and heights of previous cells.\n * @property {Number} [colspan] The `colspan` attribute of a cell. It is always defined even if the model attribute is not present. Not\n * set if {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} [rowspan] The `rowspan` attribute of a cell. It is always defined even if the model attribute is not present. Not\n * set if {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} cellIndex The index of the current cell in a parent row. When using the `includeSpanned` option it will indicate the\n * next child index if #cell is empty (which indicates that the cell is spanned by another cell).\n */","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js"],"names":["TableWalker","constructor","table","options","startRow","endRow","undefined","includeSpanned","column","_skipRows","Set","_row","_column","_cell","_spannedCells","Map","Symbol","iterator","next","row","getChild","_isOverEndRow","done","_isSpanned","currentColumn","outValue","_formatOutValue","skipCurrentValue","_shouldSkipRow","_shouldSkipColumn","cell","colspan","parseInt","getAttribute","rowspan","_recordSpans","skipRow","add","value","cellIndex","rowIsBelowStartRow","rowIsMarkedAsSkipped","has","isCurrentColumn","isPreviousThatOverlapsColumn","rowSpans","get","columnToUpdate","_markSpannedCell","rowToUpdate","set"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAMA,WAAN,CAAkB;AAChC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAAEC,KAAF,EAASC,OAAO,GAAG,EAAnB,EAAwB;AAClC;AACF;AACA;AACA;AACA;AACA;AACE,SAAKD,KAAL,GAAaA,KAAb;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKE,QAAL,GAAgBD,OAAO,CAACC,QAAR,IAAoB,CAApC;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,MAAL,GAAc,OAAOF,OAAO,CAACE,MAAf,IAAyB,QAAzB,GAAoCF,OAAO,CAACE,MAA5C,GAAqDC,SAAnE;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,cAAL,GAAsB,CAAC,CAACJ,OAAO,CAACI,cAAhC;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,SAAKC,MAAL,GAAc,OAAOL,OAAO,CAACK,MAAf,IAAyB,QAAzB,GAAoCL,OAAO,CAACK,MAA5C,GAAqDF,SAAnE;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKG,SAAL,GAAiB,IAAIC,GAAJ,EAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,IAAL,GAAY,CAAZ;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,OAAL,GAAe,CAAf;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAKC,KAAL,GAAa,CAAb;AAEA;AACF;A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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablewalker\n */\n\n/**\n * Table iterator class. It allows to iterate over table cells. For each cell the iterator yields\n * {@link module:table/tablewalker~TableWalkerValue} with proper table cell attributes.\n */\nexport default class TableWalker {\n\t/**\n\t * Creates an instance of the table walker.\n\t *\n\t *\n\t * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.\n\t * It walks row by row and column by column in order to output values defined in the constructor.\n\t * By default it will output only those locations that are occupied by a cell. To include also spanned rows and columns,\n\t * pass the `includeSpanned` option to the constructor.\n\t *\n\t * The most important values of the iterator are column and row indexes of a cell.\n\t *\n\t * To iterate over a given row:\n\t *\n\t *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );\n\t *\n\t *\t\tfor ( const cellInfo of tableWalker ) {\n\t *\t\t\tconsole.log( 'A cell at row ' + cellInfo.row + ' and column ' + cellInfo.column );\n\t *\t\t}\n\t *\n\t * For instance the code above for the following table:\n\t *\n\t *\t\t+----+----+----+----+----+----+\n\t *\t\t| 00      | 02 | 03 | 04 | 05 |\n\t *\t\t|         +----+----+----+----+\n\t *\t\t|         | 12      | 14 | 15 |\n\t *\t\t|         +----+----+----+    +\n\t *\t\t|         | 22           |    |\n\t *\t\t|----+----+----+----+----+    +\n\t *\t\t| 30 | 31 | 32 | 33 | 34 |    |\n\t *\t\t+----+----+----+----+----+----+\n\t *\n\t * will log in the console:\n\t *\n\t *\t\t'A cell at row 1 and column 2'\n\t *\t\t'A cell at row 1 and column 4'\n\t *\t\t'A cell at row 1 and column 5'\n\t *\t\t'A cell at row 2 and column 2'\n\t *\n\t * To also iterate over spanned cells:\n\t *\n\t *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 1, includeSpanned: true } );\n\t *\n\t *\t\tfor ( const cellInfo of tableWalker ) {\n\t *\t\t\tconsole.log( 'Cell at ' + cellInfo.row + ' x ' + cellInfo.column + ' : ' + ( cellInfo.cell ? 'has data' : 'is spanned' ) );\n\t *\t\t}\n\t *\n\t * will log in the console for the table from previous example:\n\t *\n\t *\t\t'Cell at 1 x 0 : is spanned'\n\t *\t\t'Cell at 1 x 1 : is spanned'\n\t *\t\t'Cell at 1 x 2 : has data'\n\t *\t\t'Cell at 1 x 3 : is spanned'\n\t *\t\t'Cell at 1 x 4 : has data'\n\t *\t\t'Cell at 1 x 5 : has data'\n\t *\n\t * @constructor\n\t * @param {module:engine/model/element~Element} table A table over which the walker iterates.\n\t * @param {Object} [options={}] An object with configuration.\n\t * @param {Number} [options.column] A column index for which this iterator will output cells.\n\t * @param {Number} [options.startRow=0] A row index for which this iterator should start.\n\t * @param {Number} [options.endRow] A row index for which this iterator should end.\n\t * @param {Boolean} [options.includeSpanned] Also return values for spanned cells.\n\t */\n\tconstructor( table, options = {} ) {\n\t\t/**\n\t\t * The walker's table element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element}\n\t\t */\n\t\tthis.table = table;\n\n\t\t/**\n\t\t * A row index on which this iterator will start.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.startRow = options.startRow || 0;\n\n\t\t/**\n\t\t * A row index on which this iterator will end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.endRow = typeof options.endRow == 'number' ? options.endRow : undefined;\n\n\t\t/**\n\t\t * Enables output of spanned cells that are normally not yielded.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.includeSpanned = !!options.includeSpanned;\n\n\t\t/**\n\t\t * If set, the table walker will only output cells of a given column or cells that overlap it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.column = typeof options.column == 'number' ? options.column : undefined;\n\n\t\t/**\n\t\t * Row indexes to skip from the iteration.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set<Number>}\n\t\t * @private\n\t\t */\n\t\tthis._skipRows = new Set();\n\n\t\t/**\n\t\t * The current row index.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._row = 0;\n\n\t\t/**\n\t\t * The current column index.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._column = 0;\n\n\t\t/**\n\t\t * The cell index in a parent row. For spanned cells when {@link #includeSpanned} is set to `true`,\n\t\t * this represents the index of the next table cell.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._cell = 0;\n\n\t\t/**\n\t\t * Holds a map of spanned cells in a table.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map<Number, Map.<Number, Number>>}\n\t\t * @private\n\t\t */\n\t\tthis._spannedCells = new Map();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:table/tablewalker~TableWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets the next table walker's value.\n\t *\n\t * @returns {module:table/tablewalker~TableWalkerValue} The next table walker's value.\n\t */\n\tnext() {\n\t\tconst row = this.table.getChild( this._row );\n\n\t\t// Iterator is done when no row (table end) or the row is after #endRow.\n\t\tif ( !row || this._isOverEndRow() ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\t// Spanned cell location handling.\n\t\tif ( this._isSpanned( this._row, this._column ) ) {\n\t\t\t// Current column must be kept as it will be updated before returning current value.\n\t\t\tconst currentColumn = this._column;\n\t\t\tconst outValue = this._formatOutValue( undefined, currentColumn );\n\n\t\t\t// Advance to next column - always.\n\t\t\tthis._column++;\n\n\t\t\tconst skipCurrentValue = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn( currentColumn, 1 );\n\n\t\t\t// The current value will be returned only if #includedSpanned=true and also current row and column are not skipped.\n\t\t\treturn skipCurrentValue ? this.next() : outValue;\n\t\t}\n\n\t\t// The cell location is not spanned by other cells.\n\t\tconst cell = row.getChild( this._cell );\n\n\t\tif ( !cell ) {\n\t\t\t// If there are no more cells left in row advance to next row.\n\t\t\tthis._row++;\n\t\t\t// And reset column & cell indexes.\n\t\t\tthis._column = 0;\n\t\t\tthis._cell = 0;\n\n\t\t\t// Return next value.\n\t\t\treturn this.next();\n\t\t}\n\n\t\t// Read table cell attributes.\n\t\tconst colspan = parseInt( cell.getAttribute( 'colspan' ) || 1 );\n\t\tconst rowspan = parseInt( cell.getAttribute( 'rowspan' ) || 1 );\n\n\t\t// Record this cell spans if it's not 1x1 cell.\n\t\tif ( colspan > 1 || rowspan > 1 ) {\n\t\t\tthis._recordSpans( this._row, this._column, rowspan, colspan );\n\t\t}\n\n\t\t// Current column must be kept as it will be updated before returning current value.\n\t\tconst currentColumn = this._column;\n\t\tconst outValue = this._formatOutValue( cell, currentColumn, rowspan, colspan );\n\n\t\t// Advance to next column before returning value.\n\t\tthis._column++;\n\n\t\t// Advance to next cell in a parent row before returning value.\n\t\tthis._cell++;\n\n\t\tconst skipCurrentValue = this._shouldSkipRow() || this._shouldSkipColumn( currentColumn, colspan );\n\n\t\t// The current value will be returned only if current row & column are not skipped.\n\t\treturn skipCurrentValue ? this.next() : outValue;\n\t}\n\n\t/**\n\t * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row\n\t * to output.\n\t *\n\t * @param {Number} row Row index to skip.\n\t */\n\tskipRow( row ) {\n\t\tthis._skipRows.add( row );\n\t}\n\n\t/**\n\t * Checks if the current row is over {@link #endRow}.\n\t *\n\t * @returns {Boolean}\n\t * @private\n\t */\n\t_isOverEndRow() {\n\t\t// If {@link #endRow) is defined skip all rows above it.\n\t\treturn this.endRow !== undefined && this._row > this.endRow;\n\t}\n\n\t/**\n\t * A common method for formatting the iterator's output value.\n\t *\n\t * @param {module:engine/model/element~Element|undefined} cell The table cell to output. It might be undefined for spanned cell\n\t * locations.\n\t * @param {Number} column Column index (use the cached value)\n\t * @param {Number} rowspan Rowspan of the current cell.\n\t * @param {Number} colspan Colspan of the current cell.\n\t * @returns {{done: boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}\n\t * @private\n\t */\n\t_formatOutValue( cell, column, rowspan = 1, colspan = 1 ) {\n\t\treturn {\n\t\t\tdone: false,\n\t\t\tvalue: {\n\t\t\t\tcell,\n\t\t\t\trow: this._row,\n\t\t\t\tcolumn,\n\t\t\t\trowspan,\n\t\t\t\tcolspan,\n\t\t\t\tcellIndex: this._cell\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Checks if the current row should be skipped.\n\t *\n\t * @returns {Boolean}\n\t * @private\n\t */\n\t_shouldSkipRow() {\n\t\tconst rowIsBelowStartRow = this._row < this.startRow;\n\t\tconst rowIsMarkedAsSkipped = this._skipRows.has( this._row );\n\n\t\treturn rowIsBelowStartRow || rowIsMarkedAsSkipped;\n\t}\n\n\t/**\n\t * Checks if the current column should be skipped.\n\t *\n\t * @param {Number} column\n\t * @param {Number} colspan\n\t * @returns {Boolean}\n\t * @private\n\t */\n\t_shouldSkipColumn( column, colspan ) {\n\t\tif ( this.column === undefined ) {\n\t\t\t// The {@link #column} is not defined so output all columns.\n\t\t\treturn false;\n\t\t}\n\n\t\t// When outputting cells from given column we skip:\n\t\t// - Cells that are not on that column.\n\t\tconst isCurrentColumn = column === this.column;\n\t\t// - CSells that are before given column and they overlaps given column.\n\t\tconst isPreviousThatOverlapsColumn = column < this.column && column + colspan > this.column;\n\n\t\treturn !isCurrentColumn && !isPreviousThatOverlapsColumn;\n\t}\n\n\t/**\n\t * Checks if the current cell location (row x column) is spanned by another cell.\n\t *\n\t * @param {Number} row Row index of a cell location to check.\n\t * @param {Number} column Column index of a cell location to check.\n\t * @returns {Boolean}\n\t * @private\n\t */\n\t_isSpanned( row, column ) {\n\t\tif ( !this._spannedCells.has( row ) ) {\n\t\t\t// No spans for given row.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst rowSpans = this._spannedCells.get( row );\n\n\t\t// If spans for given rows has entry for column it means that this location if spanned by other cell.\n\t\treturn rowSpans.has( column );\n\t}\n\n\t/**\n\t * Updates spanned cells map relative to the current cell location and its span dimensions.\n\t *\n\t * @param {Number} row Row index of a cell.\n\t * @param {Number} column Column index of a cell.\n\t * @param {Number} rowspan Cell height.\n\t * @param {Number} colspan Cell width.\n\t * @private\n\t */\n\t_recordSpans( row, column, rowspan, colspan ) {\n\t\t// This will update all cell locations after current column - ie a cell has colspan set.\n\t\tfor ( let columnToUpdate = column + 1; columnToUpdate <= column + colspan - 1; columnToUpdate++ ) {\n\t\t\tthis._markSpannedCell( row, columnToUpdate );\n\t\t}\n\n\t\t// This will update all rows below current up to row's height.\n\t\tfor ( let rowToUpdate = row + 1; rowToUpdate < row + rowspan; rowToUpdate++ ) {\n\t\t\tfor ( let columnToUpdate = column; columnToUpdate <= column + colspan - 1; columnToUpdate++ ) {\n\t\t\t\tthis._markSpannedCell( rowToUpdate, columnToUpdate );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Marks the cell location as spanned by another cell.\n\t *\n\t * @param {Number} row Row index of the cell location.\n\t * @param {Number} column Column index of the cell location.\n\t * @private\n\t */\n\t_markSpannedCell( row, column ) {\n\t\tif ( !this._spannedCells.has( row ) ) {\n\t\t\tthis._spannedCells.set( row, new Map() );\n\t\t}\n\n\t\tconst rowSpans = this._spannedCells.get( row );\n\n\t\trowSpans.set( column, true );\n\t}\n}\n\n/**\n * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.\n *\n * @typedef {Object} module:table/tablewalker~TableWalkerValue\n * @property {module:engine/model/element~Element} [cell] The current table cell. Might be empty if\n * {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} row The row index of a cell.\n * @property {Number} column The column index of a cell. Column index is adjusted to widths and heights of previous cells.\n * @property {Number} [colspan] The `colspan` attribute of a cell. It is always defined even if the model attribute is not present. Not\n * set if {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} [rowspan] The `rowspan` attribute of a cell. It is always defined even if the model attribute is not present. Not\n * set if {@link module:table/tablewalker~TableWalker#includeSpanned} is set to `true`.\n * @property {Number} cellIndex The index of the current cell in a parent row. When using the `includeSpanned` option it will indicate the\n * next child index if #cell is empty (which indicates that the cell is spanned by another cell).\n */\n"]},"metadata":{},"sourceType":"module"}