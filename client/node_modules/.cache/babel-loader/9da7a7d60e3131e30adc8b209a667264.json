{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport findLinkRange from './findlinkrange';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\n/**\n * The link command. It is used by the {@link module:link/link~Link link feature}.\n *\n * @extends module:core/command~Command\n */\n\nexport default class LinkCommand extends Command {\n  /**\n   * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.\n   *\n   * @observable\n   * @readonly\n   * @member {Object|undefined} #value\n   */\n  constructor(editor) {\n    super(editor);\n    /**\n     * A collection of {@link module:link/utils~ManualDecorator manual decorators}\n     * corresponding to the {@link module:link/link~LinkConfig#decorators decorator configuration}.\n     *\n     * You can consider it a model with states of manual decorators added to the currently selected link.\n     *\n     * @readonly\n     * @type {module:utils/collection~Collection}\n     */\n\n    this.manualDecorators = new Collection();\n  }\n  /**\n   * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.\n   */\n\n\n  restoreManualDecoratorStates() {\n    for (const manualDecorator of this.manualDecorators) {\n      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  refresh() {\n    const model = this.editor.model;\n    const doc = model.document;\n    this.value = doc.selection.getAttribute('linkHref');\n\n    for (const manualDecorator of this.manualDecorators) {\n      manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);\n    }\n\n    this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'linkHref');\n  }\n  /**\n   * Executes the command.\n   *\n   * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to\n   * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).\n   *\n   * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a\n   * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but\n   * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.\n   * The selection will be updated to wrap the just inserted text node.\n   *\n   * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.\n   *\n   * # Decorators and model attribute management\n   *\n   * There is an optional argument to this command that applies or removes model\n   * {@glink framework/guides/architecture/editing-engine#text-attributes text attributes} brought by\n   * {@link module:link/utils~ManualDecorator manual link decorators}.\n   *\n   * Text attribute names in the model correspond to the entries in the {@link module:link/link~LinkConfig#decorators configuration}.\n   * For every decorator configured, a model text attribute exists with the \"link\" prefix. For example, a `'linkMyDecorator'` attribute\n   * corresponds to `'myDecorator'` in the configuration.\n   *\n   * To learn more about link decorators, check out the {@link module:link/link~LinkConfig#decorators `config.link.decorators`}\n   * documentation.\n   *\n   * Here is how to manage decorator attributes with the link command:\n   *\n   *\t\tconst linkCommand = editor.commands.get( 'link' );\n   *\n   *\t\t// Adding a new decorator attribute.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: true\n   *\t\t} );\n   *\n   *\t\t// Removing a decorator attribute from the selection.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: false\n   *\t\t} );\n   *\n   *\t\t// Adding multiple decorator attributes at the same time.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: true,\n   *\t\t\tlinkIsDownloadable: true,\n   *\t\t} );\n   *\n   *\t\t// Removing and adding decorator attributes at the same time.\n   *\t\tlinkCommand.execute( 'http://example.com', {\n   *\t\t\tlinkIsExternal: false,\n   *\t\t\tlinkFoo: true,\n   *\t\t\tlinkIsDownloadable: false,\n   *\t\t} );\n   *\n   * **Note**: If the decorator attribute name is not specified, its state remains untouched.\n   *\n   * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all\n   * decorator attributes.\n   *\n   * @fires execute\n   * @param {String} href Link destination.\n   * @param {Object} [manualDecoratorIds={}] The information about manual decorator attributes to be applied or removed upon execution.\n   */\n\n\n  execute(href, manualDecoratorIds = {}) {\n    const model = this.editor.model;\n    const selection = model.document.selection; // Stores information about manual decorators to turn them on/off when command is applied.\n\n    const truthyManualDecorators = [];\n    const falsyManualDecorators = [];\n\n    for (const name in manualDecoratorIds) {\n      if (manualDecoratorIds[name]) {\n        truthyManualDecorators.push(name);\n      } else {\n        falsyManualDecorators.push(name);\n      }\n    }\n\n    model.change(writer => {\n      // If selection is collapsed then update selected link or insert new one at the place of caret.\n      if (selection.isCollapsed) {\n        const position = selection.getFirstPosition(); // When selection is inside text with `linkHref` attribute.\n\n        if (selection.hasAttribute('linkHref')) {\n          // Then update `linkHref` value.\n          const linkRange = findLinkRange(position, selection.getAttribute('linkHref'), model);\n          writer.setAttribute('linkHref', href, linkRange);\n          truthyManualDecorators.forEach(item => {\n            writer.setAttribute(item, true, linkRange);\n          });\n          falsyManualDecorators.forEach(item => {\n            writer.removeAttribute(item, linkRange);\n          }); // Create new range wrapping changed link.\n\n          writer.setSelection(linkRange);\n        } // If not then insert text node with `linkHref` attribute in place of caret.\n        // However, since selection in collapsed, attribute value will be used as data for text node.\n        // So, if `href` is empty, do not create text node.\n        else if (href !== '') {\n            const attributes = toMap(selection.getAttributes());\n            attributes.set('linkHref', href);\n            truthyManualDecorators.forEach(item => {\n              attributes.set(item, true);\n            });\n            const node = writer.createText(href, attributes);\n            model.insertContent(node, position); // Create new range wrapping created node.\n\n            writer.setSelection(writer.createRangeOn(node));\n          }\n      } else {\n        // If selection has non-collapsed ranges, we change attribute on nodes inside those ranges\n        // omitting nodes where `linkHref` attribute is disallowed.\n        const ranges = model.schema.getValidRanges(selection.getRanges(), 'linkHref');\n\n        for (const range of ranges) {\n          writer.setAttribute('linkHref', href, range);\n          truthyManualDecorators.forEach(item => {\n            writer.setAttribute(item, true, range);\n          });\n          falsyManualDecorators.forEach(item => {\n            writer.removeAttribute(item, range);\n          });\n        }\n      }\n    });\n  }\n  /**\n   * Provides information whether a decorator with a given name is present in the currently processed selection.\n   *\n   * @private\n   * @param {String} decoratorName The name of the manual decorator used in the model\n   * @returns {Boolean} The information whether a given decorator is currently present in the selection.\n   */\n\n\n  _getDecoratorStateFromModel(decoratorName) {\n    const doc = this.editor.model.document;\n    return doc.selection.getAttribute(decoratorName) || false;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-link/src/linkcommand.js"],"names":["Command","findLinkRange","toMap","Collection","LinkCommand","constructor","editor","manualDecorators","restoreManualDecoratorStates","manualDecorator","value","_getDecoratorStateFromModel","id","refresh","model","doc","document","selection","getAttribute","isEnabled","schema","checkAttributeInSelection","execute","href","manualDecoratorIds","truthyManualDecorators","falsyManualDecorators","name","push","change","writer","isCollapsed","position","getFirstPosition","hasAttribute","linkRange","setAttribute","forEach","item","removeAttribute","setSelection","attributes","getAttributes","set","node","createText","insertContent","createRangeOn","ranges","getValidRanges","getRanges","range","decoratorName"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module link/linkcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport findLinkRange from './findlinkrange';\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport Collection from '@ckeditor/ckeditor5-utils/src/collection';\n\n/**\n * The link command. It is used by the {@link module:link/link~Link link feature}.\n *\n * @extends module:core/command~Command\n */\nexport default class LinkCommand extends Command {\n\t/**\n\t * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.\n\t *\n\t * @observable\n\t * @readonly\n\t * @member {Object|undefined} #value\n\t */\n\n\tconstructor( editor ) {\n\t\tsuper( editor );\n\n\t\t/**\n\t\t * A collection of {@link module:link/utils~ManualDecorator manual decorators}\n\t\t * corresponding to the {@link module:link/link~LinkConfig#decorators decorator configuration}.\n\t\t *\n\t\t * You can consider it a model with states of manual decorators added to the currently selected link.\n\t\t *\n\t\t * @readonly\n\t\t * @type {module:utils/collection~Collection}\n\t\t */\n\t\tthis.manualDecorators = new Collection();\n\t}\n\n\t/**\n\t * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.\n\t */\n\trestoreManualDecoratorStates() {\n\t\tfor ( const manualDecorator of this.manualDecorators ) {\n\t\t\tmanualDecorator.value = this._getDecoratorStateFromModel( manualDecorator.id );\n\t\t}\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\n\t\tthis.value = doc.selection.getAttribute( 'linkHref' );\n\n\t\tfor ( const manualDecorator of this.manualDecorators ) {\n\t\t\tmanualDecorator.value = this._getDecoratorStateFromModel( manualDecorator.id );\n\t\t}\n\n\t\tthis.isEnabled = model.schema.checkAttributeInSelection( doc.selection, 'linkHref' );\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to\n\t * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).\n\t *\n\t * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a\n\t * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but\n\t * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.\n\t * The selection will be updated to wrap the just inserted text node.\n\t *\n\t * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.\n\t *\n\t * # Decorators and model attribute management\n\t *\n\t * There is an optional argument to this command that applies or removes model\n\t * {@glink framework/guides/architecture/editing-engine#text-attributes text attributes} brought by\n\t * {@link module:link/utils~ManualDecorator manual link decorators}.\n\t *\n\t * Text attribute names in the model correspond to the entries in the {@link module:link/link~LinkConfig#decorators configuration}.\n\t * For every decorator configured, a model text attribute exists with the \"link\" prefix. For example, a `'linkMyDecorator'` attribute\n\t * corresponds to `'myDecorator'` in the configuration.\n\t *\n\t * To learn more about link decorators, check out the {@link module:link/link~LinkConfig#decorators `config.link.decorators`}\n\t * documentation.\n\t *\n\t * Here is how to manage decorator attributes with the link command:\n\t *\n\t *\t\tconst linkCommand = editor.commands.get( 'link' );\n\t *\n\t *\t\t// Adding a new decorator attribute.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: true\n\t *\t\t} );\n\t *\n\t *\t\t// Removing a decorator attribute from the selection.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: false\n\t *\t\t} );\n\t *\n\t *\t\t// Adding multiple decorator attributes at the same time.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: true,\n\t *\t\t\tlinkIsDownloadable: true,\n\t *\t\t} );\n\t *\n\t *\t\t// Removing and adding decorator attributes at the same time.\n\t *\t\tlinkCommand.execute( 'http://example.com', {\n\t *\t\t\tlinkIsExternal: false,\n\t *\t\t\tlinkFoo: true,\n\t *\t\t\tlinkIsDownloadable: false,\n\t *\t\t} );\n\t *\n\t * **Note**: If the decorator attribute name is not specified, its state remains untouched.\n\t *\n\t * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all\n\t * decorator attributes.\n\t *\n\t * @fires execute\n\t * @param {String} href Link destination.\n\t * @param {Object} [manualDecoratorIds={}] The information about manual decorator attributes to be applied or removed upon execution.\n\t */\n\texecute( href, manualDecoratorIds = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst selection = model.document.selection;\n\t\t// Stores information about manual decorators to turn them on/off when command is applied.\n\t\tconst truthyManualDecorators = [];\n\t\tconst falsyManualDecorators = [];\n\n\t\tfor ( const name in manualDecoratorIds ) {\n\t\t\tif ( manualDecoratorIds[ name ] ) {\n\t\t\t\ttruthyManualDecorators.push( name );\n\t\t\t} else {\n\t\t\t\tfalsyManualDecorators.push( name );\n\t\t\t}\n\t\t}\n\n\t\tmodel.change( writer => {\n\t\t\t// If selection is collapsed then update selected link or insert new one at the place of caret.\n\t\t\tif ( selection.isCollapsed ) {\n\t\t\t\tconst position = selection.getFirstPosition();\n\n\t\t\t\t// When selection is inside text with `linkHref` attribute.\n\t\t\t\tif ( selection.hasAttribute( 'linkHref' ) ) {\n\t\t\t\t\t// Then update `linkHref` value.\n\t\t\t\t\tconst linkRange = findLinkRange( position, selection.getAttribute( 'linkHref' ), model );\n\n\t\t\t\t\twriter.setAttribute( 'linkHref', href, linkRange );\n\n\t\t\t\t\ttruthyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.setAttribute( item, true, linkRange );\n\t\t\t\t\t} );\n\n\t\t\t\t\tfalsyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.removeAttribute( item, linkRange );\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Create new range wrapping changed link.\n\t\t\t\t\twriter.setSelection( linkRange );\n\t\t\t\t}\n\t\t\t\t// If not then insert text node with `linkHref` attribute in place of caret.\n\t\t\t\t// However, since selection in collapsed, attribute value will be used as data for text node.\n\t\t\t\t// So, if `href` is empty, do not create text node.\n\t\t\t\telse if ( href !== '' ) {\n\t\t\t\t\tconst attributes = toMap( selection.getAttributes() );\n\n\t\t\t\t\tattributes.set( 'linkHref', href );\n\n\t\t\t\t\ttruthyManualDecorators.forEach( item => {\n\t\t\t\t\t\tattributes.set( item, true );\n\t\t\t\t\t} );\n\n\t\t\t\t\tconst node = writer.createText( href, attributes );\n\n\t\t\t\t\tmodel.insertContent( node, position );\n\n\t\t\t\t\t// Create new range wrapping created node.\n\t\t\t\t\twriter.setSelection( writer.createRangeOn( node ) );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If selection has non-collapsed ranges, we change attribute on nodes inside those ranges\n\t\t\t\t// omitting nodes where `linkHref` attribute is disallowed.\n\t\t\t\tconst ranges = model.schema.getValidRanges( selection.getRanges(), 'linkHref' );\n\n\t\t\t\tfor ( const range of ranges ) {\n\t\t\t\t\twriter.setAttribute( 'linkHref', href, range );\n\n\t\t\t\t\ttruthyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.setAttribute( item, true, range );\n\t\t\t\t\t} );\n\n\t\t\t\t\tfalsyManualDecorators.forEach( item => {\n\t\t\t\t\t\twriter.removeAttribute( item, range );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Provides information whether a decorator with a given name is present in the currently processed selection.\n\t *\n\t * @private\n\t * @param {String} decoratorName The name of the manual decorator used in the model\n\t * @returns {Boolean} The information whether a given decorator is currently present in the selection.\n\t */\n\t_getDecoratorStateFromModel( decoratorName ) {\n\t\tconst doc = this.editor.model.document;\n\t\treturn doc.selection.getAttribute( decoratorName ) || false;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}