{"ast":null,"code":"// @flow\nimport React from 'react';\nimport getContentStateFragment from 'draft-js/lib/getContentStateFragment';\nimport getDraftEditorSelection from 'draft-js/lib/getDraftEditorSelection';\nimport editOnCopy from 'draft-js/lib/editOnCopy';\nimport editOnCut from 'draft-js/lib/editOnCut';\nimport { convertFromRaw, Modifier, EditorState, ContentState, convertToRaw } from 'draft-js'; // @flow\n\n/*:: import type { BlockNode } from \"draft-js/lib/BlockNode\";*/\n// Default maximum block depth supported by Draft.js CSS.\n\nvar DRAFT_DEFAULT_MAX_DEPTH = 4; // Default depth class prefix from Draft.js CSS.\n\nvar DRAFT_DEFAULT_DEPTH_CLASS = \"public-DraftStyleDefault-depth\";\n/**\n * Generates CSS styles for list items, for a given selector pattern.\n * @param {string} selectorPrefix\n * @param {number} minDepth\n * @param {number} maxDepth\n */\n\nvar generateListNestingStyles = function generateListNestingStyles(selectorPrefix\n/*: string*/\n, minDepth\n/*: number*/\n, maxDepth\n/*: number*/\n) {\n  var styles = \"\";\n\n  for (var depth = minDepth; depth <= maxDepth; depth++) {\n    var d = String(depth);\n    var prefix = \"\".concat(selectorPrefix).concat(d);\n    var counter = \"ol\".concat(d);\n    var margin = 1.5 * (depth + 1);\n    var m = String(margin);\n    styles += \"\\n.\".concat(prefix, \".public-DraftStyleDefault-listLTR { margin-left: \").concat(m, \"em; }\\n.\").concat(prefix, \".public-DraftStyleDefault-listRTL { margin-right: \").concat(m, \"em; }\\n.\").concat(prefix, \".public-DraftStyleDefault-orderedListItem::before { content: counter(\").concat(counter, \") '. '; counter-increment: \").concat(counter, \"; }\\n.\").concat(prefix, \".public-DraftStyleDefault-reset { counter-reset: \").concat(counter, \"; }\");\n  }\n\n  return styles;\n};\n/**\n * Dynamically generates the right list nesting styles.\n * Can be wrapped as a pure component - to re-render only when `max` changes (eg. never).\n */\n\n\nvar ListNestingStyles = function ListNestingStyles(props\n/*: { max: number }*/\n) {\n  var max = props.max;\n  var min = DRAFT_DEFAULT_MAX_DEPTH + 1;\n  return max > DRAFT_DEFAULT_MAX_DEPTH ? /*#__PURE__*/React.createElement(\"style\", null, generateListNestingStyles(DRAFT_DEFAULT_DEPTH_CLASS, min, max)) : null;\n};\n/**\n * Add depth classes that Draft.js doesn't provide.\n * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.\n * @param {ContentBlock} block\n */\n\n\nvar blockDepthStyleFn = function blockDepthStyleFn(block\n/*: BlockNode*/\n) {\n  var depth = block.getDepth();\n  return depth > DRAFT_DEFAULT_MAX_DEPTH ? \"\".concat(DRAFT_DEFAULT_DEPTH_CLASS).concat(String(depth)) : \"\";\n}; // @flow\n\n/*:: import type { ElementRef } from \"react\";*/\n\n/*:: import type { Editor, EditorState as EditorStateType } from \"draft-js\";*/\n// Custom attribute to store Draft.js content in the HTML clipboard.\n\n\nvar FRAGMENT_ATTR = \"data-draftjs-conductor-fragment\";\nvar DRAFT_DECORATOR = '[data-contents=\"true\"] [contenteditable=\"false\"]'; // Checks whether the selection is inside a decorator or not.\n// This is important to change the copy-cut behavior accordingly.\n\nvar isSelectionInDecorator = function isSelectionInDecorator(selection\n/*: Selection*/\n) {\n  var anchorNode = selection.anchorNode,\n      focusNode = selection.focusNode;\n\n  if (!anchorNode || !focusNode) {\n    return false;\n  }\n\n  var anchor = anchorNode instanceof Element ? anchorNode : anchorNode.parentElement;\n  var focus = focusNode instanceof Element ? focusNode : focusNode.parentElement;\n  var anchorDecorator = anchor && anchor.closest(DRAFT_DECORATOR);\n  var focusDecorator = focus && focus.closest(DRAFT_DECORATOR);\n  return anchorDecorator && focusDecorator && (anchorDecorator.contains(focusDecorator) || focusDecorator.contains(anchorDecorator));\n}; // Get clipboard content from the selection like Draft.js would.\n\n\nvar getSelectedContent = function getSelectedContent(editorState\n/*: EditorStateType*/\n, editorRoot\n/*: HTMLElement*/\n) {\n  var _getDraftEditorSelect = getDraftEditorSelection(editorState, editorRoot),\n      selectionState = _getDraftEditorSelect.selectionState;\n\n  var fragment = getContentStateFragment(editorState.getCurrentContent(), selectionState); // If the selection contains no content (according to Draft.js), use the default browser behavior.\n  // This happens when selecting text that's within contenteditable=false blocks in Draft.js.\n  // See https://github.com/thibaudcolas/draftjs-conductor/issues/12.\n\n  var isEmpty = fragment.every(function (block) {\n    return block.getText().length === 0;\n  });\n  return isEmpty ? null : fragment;\n}; // Overrides the default copy/cut behavior, adding the serialised Draft.js content to the clipboard data.\n// See also https://github.com/basecamp/trix/blob/62145978f352b8d971cf009882ba06ca91a16292/src/trix/controllers/input_controller.coffee#L415-L422\n// We serialise the editor content within HTML, not as a separate mime type, because Draft.js only allows access\n// to HTML in its paste event handler.\n\n\nvar draftEditorCopyCutListener = function draftEditorCopyCutListener(ref\n/*: ElementRef<Editor>*/\n, e\n/*: SyntheticClipboardEvent<>*/\n) {\n  var selection = window.getSelection(); // Completely skip event handling if clipboardData is not supported (IE11 is out).\n  // Also skip if there is no selection ranges.\n  // Or if the selection is fully within a decorator.\n\n  if (!e.clipboardData || selection.rangeCount === 0 || isSelectionInDecorator(selection)) {\n    return;\n  }\n\n  var fragment = getSelectedContent(ref._latestEditorState, ref.editor); // Override the default behavior if there is selected content.\n\n  if (fragment) {\n    var content = ContentState.createFromBlockArray(fragment.toArray());\n    var serialisedContent = JSON.stringify(convertToRaw(content)); // Create a temporary element to store the selectionâ€™s HTML.\n    // See also Rangy's implementation: https://github.com/timdown/rangy/blob/1e55169d2e4d1d9458c2a87119addf47a8265276/src/core/domrange.js#L515-L520.\n\n    var fragmentElt = document.createElement(\"div\"); // Modern browsers only support a single range.\n\n    fragmentElt.appendChild(selection.getRangeAt(0).cloneContents());\n    fragmentElt.setAttribute(FRAGMENT_ATTR, serialisedContent); // We set the style property to replicate the browser's behavior of inline styles in rich text copy-paste.\n    // In Draft.js, this is important for line breaks to be interpreted correctly when pasted into another word processor.\n    // See https://github.com/facebook/draft-js/blob/a1f4593d8fa949954053e5d5840d33ce1d1082c6/src/component/base/DraftEditor.react.js#L328.\n\n    fragmentElt.setAttribute(\"style\", \"white-space: pre-wrap;\");\n    e.clipboardData.setData(\"text/plain\", selection.toString());\n    e.clipboardData.setData(\"text/html\", fragmentElt.outerHTML);\n    e.preventDefault();\n  }\n};\n\nvar onDraftEditorCopy = function onDraftEditorCopy(editor\n/*: Editor*/\n, e\n/*: SyntheticClipboardEvent<>*/\n) {\n  draftEditorCopyCutListener(editor, e);\n  editOnCopy(editor, e);\n};\n\nvar onDraftEditorCut = function onDraftEditorCut(editor\n/*: Editor*/\n, e\n/*: SyntheticClipboardEvent<>*/\n) {\n  draftEditorCopyCutListener(editor, e);\n  editOnCut(editor, e);\n};\n/**\n * Registers custom copy/cut event listeners on an editor.\n */\n\n\nvar registerCopySource = function registerCopySource(ref\n/*: ElementRef<Editor>*/\n) {\n  var editorElt = ref.editor;\n  var onCopyCut = draftEditorCopyCutListener.bind(null, ref);\n  editorElt.addEventListener(\"copy\", onCopyCut);\n  editorElt.addEventListener(\"cut\", onCopyCut);\n  return {\n    unregister() {\n      editorElt.removeEventListener(\"copy\", onCopyCut);\n      editorElt.removeEventListener(\"cut\", onCopyCut);\n    }\n\n  };\n};\n/**\n * Returns pasted content coming from Draft.js editors set up to serialise\n * their Draft.js content within the HTML.\n */\n\n\nvar getDraftEditorPastedContent = function getDraftEditorPastedContent(html\n/*: ?string*/\n) {\n  // Plain-text pastes are better handled by Draft.js.\n  if (html === \"\" || typeof html === \"undefined\" || html === null) {\n    return null;\n  }\n\n  var doc = new DOMParser().parseFromString(html, \"text/html\");\n  var fragmentElt = doc.querySelector(\"[\".concat(FRAGMENT_ATTR, \"]\")); // Handle the paste if it comes from draftjs-conductor.\n\n  if (fragmentElt) {\n    var fragmentAttr = fragmentElt.getAttribute(FRAGMENT_ATTR);\n    var rawContent;\n\n    try {\n      // If JSON parsing fails, leave paste handling to Draft.js.\n      // There is no reason for this to happen, unless the clipboard was altered somehow.\n      // $FlowFixMe\n      rawContent = JSON.parse(fragmentAttr);\n    } catch (error) {\n      return null;\n    }\n\n    return convertFromRaw(rawContent);\n  }\n\n  return null;\n};\n/**\n * Handles pastes coming from Draft.js editors set up to serialise\n * their Draft.js content within the HTML.\n * This SHOULD NOT be used for stripPastedStyles editor.\n */\n\n\nvar handleDraftEditorPastedText = function handleDraftEditorPastedText(html\n/*: ?string*/\n, editorState\n/*: EditorStateType*/\n) {\n  var pastedContent = getDraftEditorPastedContent(html);\n\n  if (pastedContent) {\n    var fragment = pastedContent.getBlockMap();\n    var content = Modifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n    return EditorState.push(editorState, content, \"insert-fragment\");\n  }\n\n  return false;\n}; // @flow\n\n/*:: import type { RawDraftContentState } from \"draft-js/lib/RawDraftContentState\";*/\n\n/*:: import type { DraftDecoratorType } from \"draft-js/lib/DraftDecoratorType\";*/\n\n\nvar EMPTY_CONTENT_STATE = null;\n/**\n * Creates a new EditorState from a RawDraftContentState, or an empty editor state by\n * passing `null`. Optionally takes a decorator.\n */\n\nvar createEditorStateFromRaw = function createEditorStateFromRaw(rawContentState\n/*: ?RawDraftContentState*/\n, decorator\n/*:: ?: ?DraftDecoratorType*/\n) {\n  var editorState;\n\n  if (rawContentState) {\n    var contentState = convertFromRaw(rawContentState);\n    editorState = EditorState.createWithContent(contentState, decorator);\n  } else {\n    editorState = EditorState.createEmpty(decorator);\n  }\n\n  return editorState;\n};\n/**\n * Serialises the editorState using `convertToRaw`, but returns `null` if\n * the editor content is empty (no text, entities, styles).\n */\n\n\nvar serialiseEditorStateToRaw = function serialiseEditorStateToRaw(editorState\n/*: EditorState*/\n) {\n  var contentState = editorState.getCurrentContent();\n  var rawContentState = convertToRaw(contentState);\n  var isEmpty = rawContentState.blocks.every(function (block) {\n    var isEmptyBlock = block.text.trim().length === 0 && (!block.entityRanges || block.entityRanges.length === 0) && (!block.inlineStyleRanges || block.inlineStyleRanges.length === 0);\n    return isEmptyBlock;\n  });\n  return isEmpty ? EMPTY_CONTENT_STATE : rawContentState;\n};\n\nexport { DRAFT_DEFAULT_DEPTH_CLASS, DRAFT_DEFAULT_MAX_DEPTH, ListNestingStyles, blockDepthStyleFn, createEditorStateFromRaw, generateListNestingStyles, getDraftEditorPastedContent, handleDraftEditorPastedText, onDraftEditorCopy, onDraftEditorCut, registerCopySource, serialiseEditorStateToRaw };","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/draftjs-conductor/dist/draftjs-conductor.esm.js"],"names":["React","getContentStateFragment","getDraftEditorSelection","editOnCopy","editOnCut","convertFromRaw","Modifier","EditorState","ContentState","convertToRaw","DRAFT_DEFAULT_MAX_DEPTH","DRAFT_DEFAULT_DEPTH_CLASS","generateListNestingStyles","selectorPrefix","minDepth","maxDepth","styles","depth","d","String","prefix","concat","counter","margin","m","ListNestingStyles","props","max","min","createElement","blockDepthStyleFn","block","getDepth","FRAGMENT_ATTR","DRAFT_DECORATOR","isSelectionInDecorator","selection","anchorNode","focusNode","anchor","Element","parentElement","focus","anchorDecorator","closest","focusDecorator","contains","getSelectedContent","editorState","editorRoot","_getDraftEditorSelect","selectionState","fragment","getCurrentContent","isEmpty","every","getText","length","draftEditorCopyCutListener","ref","e","window","getSelection","clipboardData","rangeCount","_latestEditorState","editor","content","createFromBlockArray","toArray","serialisedContent","JSON","stringify","fragmentElt","document","appendChild","getRangeAt","cloneContents","setAttribute","setData","toString","outerHTML","preventDefault","onDraftEditorCopy","onDraftEditorCut","registerCopySource","editorElt","onCopyCut","bind","addEventListener","unregister","removeEventListener","getDraftEditorPastedContent","html","doc","DOMParser","parseFromString","querySelector","fragmentAttr","getAttribute","rawContent","parse","error","handleDraftEditorPastedText","pastedContent","getBlockMap","replaceWithFragment","push","EMPTY_CONTENT_STATE","createEditorStateFromRaw","rawContentState","decorator","contentState","createWithContent","createEmpty","serialiseEditorStateToRaw","blocks","isEmptyBlock","text","trim","entityRanges","inlineStyleRanges"],"mappings":"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","sourcesContent":["// @flow\nimport React from 'react';\nimport getContentStateFragment from 'draft-js/lib/getContentStateFragment';\nimport getDraftEditorSelection from 'draft-js/lib/getDraftEditorSelection';\nimport editOnCopy from 'draft-js/lib/editOnCopy';\nimport editOnCut from 'draft-js/lib/editOnCut';\nimport { convertFromRaw, Modifier, EditorState, ContentState, convertToRaw } from 'draft-js';\n\n// @flow\n/*:: import type { BlockNode } from \"draft-js/lib/BlockNode\";*/\n\n// Default maximum block depth supported by Draft.js CSS.\nvar DRAFT_DEFAULT_MAX_DEPTH = 4; // Default depth class prefix from Draft.js CSS.\n\nvar DRAFT_DEFAULT_DEPTH_CLASS = \"public-DraftStyleDefault-depth\";\n/**\n * Generates CSS styles for list items, for a given selector pattern.\n * @param {string} selectorPrefix\n * @param {number} minDepth\n * @param {number} maxDepth\n */\n\nvar generateListNestingStyles = function generateListNestingStyles(selectorPrefix\n/*: string*/\n, minDepth\n/*: number*/\n, maxDepth\n/*: number*/\n) {\n  var styles = \"\";\n\n  for (var depth = minDepth; depth <= maxDepth; depth++) {\n    var d = String(depth);\n    var prefix = \"\".concat(selectorPrefix).concat(d);\n    var counter = \"ol\".concat(d);\n    var margin = 1.5 * (depth + 1);\n    var m = String(margin);\n    styles += \"\\n.\".concat(prefix, \".public-DraftStyleDefault-listLTR { margin-left: \").concat(m, \"em; }\\n.\").concat(prefix, \".public-DraftStyleDefault-listRTL { margin-right: \").concat(m, \"em; }\\n.\").concat(prefix, \".public-DraftStyleDefault-orderedListItem::before { content: counter(\").concat(counter, \") '. '; counter-increment: \").concat(counter, \"; }\\n.\").concat(prefix, \".public-DraftStyleDefault-reset { counter-reset: \").concat(counter, \"; }\");\n  }\n\n  return styles;\n};\n/**\n * Dynamically generates the right list nesting styles.\n * Can be wrapped as a pure component - to re-render only when `max` changes (eg. never).\n */\n\nvar ListNestingStyles = function ListNestingStyles(props\n/*: { max: number }*/\n) {\n  var max = props.max;\n  var min = DRAFT_DEFAULT_MAX_DEPTH + 1;\n  return max > DRAFT_DEFAULT_MAX_DEPTH ? /*#__PURE__*/React.createElement(\"style\", null, generateListNestingStyles(DRAFT_DEFAULT_DEPTH_CLASS, min, max)) : null;\n};\n/**\n * Add depth classes that Draft.js doesn't provide.\n * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.\n * @param {ContentBlock} block\n */\n\nvar blockDepthStyleFn = function blockDepthStyleFn(block\n/*: BlockNode*/\n) {\n  var depth = block.getDepth();\n  return depth > DRAFT_DEFAULT_MAX_DEPTH ? \"\".concat(DRAFT_DEFAULT_DEPTH_CLASS).concat(String(depth)) : \"\";\n};\n\n// @flow\n/*:: import type { ElementRef } from \"react\";*/\n\n/*:: import type { Editor, EditorState as EditorStateType } from \"draft-js\";*/\n\n// Custom attribute to store Draft.js content in the HTML clipboard.\nvar FRAGMENT_ATTR = \"data-draftjs-conductor-fragment\";\nvar DRAFT_DECORATOR = '[data-contents=\"true\"] [contenteditable=\"false\"]'; // Checks whether the selection is inside a decorator or not.\n// This is important to change the copy-cut behavior accordingly.\n\nvar isSelectionInDecorator = function isSelectionInDecorator(selection\n/*: Selection*/\n) {\n  var anchorNode = selection.anchorNode,\n      focusNode = selection.focusNode;\n\n  if (!anchorNode || !focusNode) {\n    return false;\n  }\n\n  var anchor = anchorNode instanceof Element ? anchorNode : anchorNode.parentElement;\n  var focus = focusNode instanceof Element ? focusNode : focusNode.parentElement;\n  var anchorDecorator = anchor && anchor.closest(DRAFT_DECORATOR);\n  var focusDecorator = focus && focus.closest(DRAFT_DECORATOR);\n  return anchorDecorator && focusDecorator && (anchorDecorator.contains(focusDecorator) || focusDecorator.contains(anchorDecorator));\n}; // Get clipboard content from the selection like Draft.js would.\n\n\nvar getSelectedContent = function getSelectedContent(editorState\n/*: EditorStateType*/\n, editorRoot\n/*: HTMLElement*/\n) {\n  var _getDraftEditorSelect = getDraftEditorSelection(editorState, editorRoot),\n      selectionState = _getDraftEditorSelect.selectionState;\n\n  var fragment = getContentStateFragment(editorState.getCurrentContent(), selectionState); // If the selection contains no content (according to Draft.js), use the default browser behavior.\n  // This happens when selecting text that's within contenteditable=false blocks in Draft.js.\n  // See https://github.com/thibaudcolas/draftjs-conductor/issues/12.\n\n  var isEmpty = fragment.every(function (block) {\n    return block.getText().length === 0;\n  });\n  return isEmpty ? null : fragment;\n}; // Overrides the default copy/cut behavior, adding the serialised Draft.js content to the clipboard data.\n// See also https://github.com/basecamp/trix/blob/62145978f352b8d971cf009882ba06ca91a16292/src/trix/controllers/input_controller.coffee#L415-L422\n// We serialise the editor content within HTML, not as a separate mime type, because Draft.js only allows access\n// to HTML in its paste event handler.\n\n\nvar draftEditorCopyCutListener = function draftEditorCopyCutListener(ref\n/*: ElementRef<Editor>*/\n, e\n/*: SyntheticClipboardEvent<>*/\n) {\n  var selection = window.getSelection(); // Completely skip event handling if clipboardData is not supported (IE11 is out).\n  // Also skip if there is no selection ranges.\n  // Or if the selection is fully within a decorator.\n\n  if (!e.clipboardData || selection.rangeCount === 0 || isSelectionInDecorator(selection)) {\n    return;\n  }\n\n  var fragment = getSelectedContent(ref._latestEditorState, ref.editor); // Override the default behavior if there is selected content.\n\n  if (fragment) {\n    var content = ContentState.createFromBlockArray(fragment.toArray());\n    var serialisedContent = JSON.stringify(convertToRaw(content)); // Create a temporary element to store the selectionâ€™s HTML.\n    // See also Rangy's implementation: https://github.com/timdown/rangy/blob/1e55169d2e4d1d9458c2a87119addf47a8265276/src/core/domrange.js#L515-L520.\n\n    var fragmentElt = document.createElement(\"div\"); // Modern browsers only support a single range.\n\n    fragmentElt.appendChild(selection.getRangeAt(0).cloneContents());\n    fragmentElt.setAttribute(FRAGMENT_ATTR, serialisedContent); // We set the style property to replicate the browser's behavior of inline styles in rich text copy-paste.\n    // In Draft.js, this is important for line breaks to be interpreted correctly when pasted into another word processor.\n    // See https://github.com/facebook/draft-js/blob/a1f4593d8fa949954053e5d5840d33ce1d1082c6/src/component/base/DraftEditor.react.js#L328.\n\n    fragmentElt.setAttribute(\"style\", \"white-space: pre-wrap;\");\n    e.clipboardData.setData(\"text/plain\", selection.toString());\n    e.clipboardData.setData(\"text/html\", fragmentElt.outerHTML);\n    e.preventDefault();\n  }\n};\n\nvar onDraftEditorCopy = function onDraftEditorCopy(editor\n/*: Editor*/\n, e\n/*: SyntheticClipboardEvent<>*/\n) {\n  draftEditorCopyCutListener(editor, e);\n  editOnCopy(editor, e);\n};\nvar onDraftEditorCut = function onDraftEditorCut(editor\n/*: Editor*/\n, e\n/*: SyntheticClipboardEvent<>*/\n) {\n  draftEditorCopyCutListener(editor, e);\n  editOnCut(editor, e);\n};\n/**\n * Registers custom copy/cut event listeners on an editor.\n */\n\nvar registerCopySource = function registerCopySource(ref\n/*: ElementRef<Editor>*/\n) {\n  var editorElt = ref.editor;\n  var onCopyCut = draftEditorCopyCutListener.bind(null, ref);\n  editorElt.addEventListener(\"copy\", onCopyCut);\n  editorElt.addEventListener(\"cut\", onCopyCut);\n  return {\n    unregister() {\n      editorElt.removeEventListener(\"copy\", onCopyCut);\n      editorElt.removeEventListener(\"cut\", onCopyCut);\n    }\n\n  };\n};\n/**\n * Returns pasted content coming from Draft.js editors set up to serialise\n * their Draft.js content within the HTML.\n */\n\nvar getDraftEditorPastedContent = function getDraftEditorPastedContent(html\n/*: ?string*/\n) {\n  // Plain-text pastes are better handled by Draft.js.\n  if (html === \"\" || typeof html === \"undefined\" || html === null) {\n    return null;\n  }\n\n  var doc = new DOMParser().parseFromString(html, \"text/html\");\n  var fragmentElt = doc.querySelector(\"[\".concat(FRAGMENT_ATTR, \"]\")); // Handle the paste if it comes from draftjs-conductor.\n\n  if (fragmentElt) {\n    var fragmentAttr = fragmentElt.getAttribute(FRAGMENT_ATTR);\n    var rawContent;\n\n    try {\n      // If JSON parsing fails, leave paste handling to Draft.js.\n      // There is no reason for this to happen, unless the clipboard was altered somehow.\n      // $FlowFixMe\n      rawContent = JSON.parse(fragmentAttr);\n    } catch (error) {\n      return null;\n    }\n\n    return convertFromRaw(rawContent);\n  }\n\n  return null;\n};\n/**\n * Handles pastes coming from Draft.js editors set up to serialise\n * their Draft.js content within the HTML.\n * This SHOULD NOT be used for stripPastedStyles editor.\n */\n\nvar handleDraftEditorPastedText = function handleDraftEditorPastedText(html\n/*: ?string*/\n, editorState\n/*: EditorStateType*/\n) {\n  var pastedContent = getDraftEditorPastedContent(html);\n\n  if (pastedContent) {\n    var fragment = pastedContent.getBlockMap();\n    var content = Modifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n    return EditorState.push(editorState, content, \"insert-fragment\");\n  }\n\n  return false;\n};\n\n// @flow\n/*:: import type { RawDraftContentState } from \"draft-js/lib/RawDraftContentState\";*/\n\n/*:: import type { DraftDecoratorType } from \"draft-js/lib/DraftDecoratorType\";*/\n\nvar EMPTY_CONTENT_STATE = null;\n/**\n * Creates a new EditorState from a RawDraftContentState, or an empty editor state by\n * passing `null`. Optionally takes a decorator.\n */\n\nvar createEditorStateFromRaw = function createEditorStateFromRaw(rawContentState\n/*: ?RawDraftContentState*/\n, decorator\n/*:: ?: ?DraftDecoratorType*/\n) {\n  var editorState;\n\n  if (rawContentState) {\n    var contentState = convertFromRaw(rawContentState);\n    editorState = EditorState.createWithContent(contentState, decorator);\n  } else {\n    editorState = EditorState.createEmpty(decorator);\n  }\n\n  return editorState;\n};\n/**\n * Serialises the editorState using `convertToRaw`, but returns `null` if\n * the editor content is empty (no text, entities, styles).\n */\n\nvar serialiseEditorStateToRaw = function serialiseEditorStateToRaw(editorState\n/*: EditorState*/\n) {\n  var contentState = editorState.getCurrentContent();\n  var rawContentState = convertToRaw(contentState);\n  var isEmpty = rawContentState.blocks.every(function (block) {\n    var isEmptyBlock = block.text.trim().length === 0 && (!block.entityRanges || block.entityRanges.length === 0) && (!block.inlineStyleRanges || block.inlineStyleRanges.length === 0);\n    return isEmptyBlock;\n  });\n  return isEmpty ? EMPTY_CONTENT_STATE : rawContentState;\n};\n\nexport { DRAFT_DEFAULT_DEPTH_CLASS, DRAFT_DEFAULT_MAX_DEPTH, ListNestingStyles, blockDepthStyleFn, createEditorStateFromRaw, generateListNestingStyles, getDraftEditorPastedContent, handleDraftEditorPastedText, onDraftEditorCopy, onDraftEditorCut, registerCopySource, serialiseEditorStateToRaw };\n"]},"metadata":{},"sourceType":"module"}