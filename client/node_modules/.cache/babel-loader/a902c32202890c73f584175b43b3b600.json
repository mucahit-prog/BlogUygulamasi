{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\nimport HighlightStack from './highlightstack';\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\nimport dragHandlerIcon from '../theme/icons/drag-handler.svg';\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\n\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\n\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\n\nexport function isWidget(node) {\n  if (!node.is('element')) {\n    return false;\n  }\n\n  return !!node.getCustomProperty('widget');\n}\n/* eslint-disable max-len */\n\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"true\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandler=false] If `true`, the widget will have a selection handler added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\n\n/* eslint-enable max-len */\n\nexport function toWidget(element, writer, options = {}) {\n  // The selection on Edge behaves better when the whole editor contents is in a single contenteditable element.\n  // https://github.com/ckeditor/ckeditor5/issues/1079\n  if (!env.isEdge) {\n    writer.setAttribute('contenteditable', 'false', element);\n  }\n\n  writer.addClass(WIDGET_CLASS_NAME, element);\n  writer.setCustomProperty('widget', true, element);\n  element.getFillerOffset = getFillerOffset;\n\n  if (options.label) {\n    setLabel(element, options.label, writer);\n  }\n\n  if (options.hasSelectionHandler) {\n    addSelectionHandler(element, writer);\n  }\n\n  setHighlightHandling(element, writer, (element, descriptor, writer) => writer.addClass(normalizeToArray(descriptor.classes), element), (element, descriptor, writer) => writer.removeClass(normalizeToArray(descriptor.classes), element));\n  return element; // Normalizes CSS class in descriptor that can be provided in form of an array or a string.\n\n  function normalizeToArray(classes) {\n    return Array.isArray(classes) ? classes : [classes];\n  }\n}\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} add\n * @param {Function} remove\n */\n\nexport function setHighlightHandling(element, writer, add, remove) {\n  const stack = new HighlightStack();\n  stack.on('change:top', (evt, data) => {\n    if (data.oldDescriptor) {\n      remove(element, data.oldDescriptor, data.writer);\n    }\n\n    if (data.newDescriptor) {\n      add(element, data.newDescriptor, data.writer);\n    }\n  });\n  writer.setCustomProperty('addHighlight', (element, descriptor, writer) => stack.add(descriptor, writer), element);\n  writer.setCustomProperty('removeHighlight', (element, id, writer) => stack.remove(id, writer), element);\n}\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\n\nexport function setLabel(element, labelOrCreator, writer) {\n  writer.setCustomProperty('widgetLabel', labelOrCreator, element);\n}\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\n\nexport function getLabel(element) {\n  const labelCreator = element.getCustomProperty('widgetLabel');\n\n  if (!labelCreator) {\n    return '';\n  }\n\n  return typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `dataDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\n\nexport function toWidgetEditable(editable, writer) {\n  writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable); // The selection on Edge behaves better when the whole editor contents is in a single contentedible element.\n  // https://github.com/ckeditor/ckeditor5/issues/1079\n\n  if (!env.isEdge) {\n    // Set initial contenteditable value.\n    writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable); // Bind the contenteditable property to element#isReadOnly.\n\n    editable.on('change:isReadOnly', (evt, property, is) => {\n      writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);\n    });\n  }\n\n  editable.on('change:isFocused', (evt, property, is) => {\n    if (is) {\n      writer.addClass('ck-editor__nested-editable_focused', editable);\n    } else {\n      writer.removeClass('ck-editor__nested-editable_focused', editable);\n    }\n  });\n  return editable;\n}\n/**\n * Returns a model position which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the position before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the position after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, that block will be returned. If that position\n * is then passed to {@link module:engine/model/model~Model#insertContent},\n * the block will be fully replaced by the image.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/position~Position} The optimal position.\n */\n\nexport function findOptimalInsertionPosition(selection, model) {\n  const selectedElement = selection.getSelectedElement();\n\n  if (selectedElement && model.schema.isBlock(selectedElement)) {\n    return model.createPositionAfter(selectedElement);\n  }\n\n  const firstBlock = selection.getSelectedBlocks().next().value;\n\n  if (firstBlock) {\n    // If inserting into an empty block – return position in that block. It will get\n    // replaced with the image by insertContent(). #42.\n    if (firstBlock.isEmpty) {\n      return model.createPositionAt(firstBlock, 0);\n    }\n\n    const positionAfter = model.createPositionAfter(firstBlock); // If selection is at the end of the block - return position after the block.\n\n    if (selection.focus.isTouching(positionAfter)) {\n      return positionAfter;\n    } // Otherwise return position before the block.\n\n\n    return model.createPositionBefore(firstBlock);\n  }\n\n  return selection.focus;\n}\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\n\nexport function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {\n  return (evt, data) => {\n    const {\n      mapper,\n      viewPosition\n    } = data;\n    const viewParent = mapper.findMappedViewAncestor(viewPosition);\n\n    if (!viewElementMatcher(viewParent)) {\n      return;\n    }\n\n    const modelParent = mapper.toModelElement(viewParent);\n    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');\n  };\n} // Default filler offset function applied to all widget elements.\n//\n// @returns {null}\n\nfunction getFillerOffset() {\n  return null;\n} // Adds a drag handler to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\n\n\nfunction addSelectionHandler(widgetElement, writer) {\n  const selectionHandler = writer.createUIElement('div', {\n    class: 'ck ck-widget__selection-handler'\n  }, function (domDocument) {\n    const domElement = this.toDomElement(domDocument); // Use the IconView from the ui library.\n\n    const icon = new IconView();\n    icon.set('content', dragHandlerIcon); // Render the icon view right away to append its #element to the selectionHandler DOM element.\n\n    icon.render();\n    domElement.appendChild(icon.element);\n    return domElement;\n  }); // Append the selection handler into the widget wrapper.\n\n  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandler);\n  writer.addClass(['ck-widget_with-selection-handler'], widgetElement);\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-widget/src/utils.js"],"names":["HighlightStack","IconView","env","dragHandlerIcon","WIDGET_CLASS_NAME","WIDGET_SELECTED_CLASS_NAME","isWidget","node","is","getCustomProperty","toWidget","element","writer","options","isEdge","setAttribute","addClass","setCustomProperty","getFillerOffset","label","setLabel","hasSelectionHandler","addSelectionHandler","setHighlightHandling","descriptor","normalizeToArray","classes","removeClass","Array","isArray","add","remove","stack","on","evt","data","oldDescriptor","newDescriptor","id","labelOrCreator","getLabel","labelCreator","toWidgetEditable","editable","isReadOnly","property","findOptimalInsertionPosition","selection","model","selectedElement","getSelectedElement","schema","isBlock","createPositionAfter","firstBlock","getSelectedBlocks","next","value","isEmpty","createPositionAt","positionAfter","focus","isTouching","createPositionBefore","viewToModelPositionOutsideModelElement","viewElementMatcher","mapper","viewPosition","viewParent","findMappedViewAncestor","modelParent","toModelElement","modelPosition","isAtStart","widgetElement","selectionHandler","createUIElement","class","domDocument","domElement","toDomElement","icon","set","render","appendChild","insert"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module widget/utils\n */\n\nimport HighlightStack from './highlightstack';\nimport IconView from '@ckeditor/ckeditor5-ui/src/icon/iconview';\nimport env from '@ckeditor/ckeditor5-utils/src/env';\n\nimport dragHandlerIcon from '../theme/icons/drag-handler.svg';\n\n/**\n * CSS class added to each widget element.\n *\n * @const {String}\n */\nexport const WIDGET_CLASS_NAME = 'ck-widget';\n\n/**\n * CSS class added to currently selected widget element.\n *\n * @const {String}\n */\nexport const WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';\n\n/**\n * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.\n *\n * @param {module:engine/view/node~Node} node\n * @returns {Boolean}\n */\nexport function isWidget( node ) {\n\tif ( !node.is( 'element' ) ) {\n\t\treturn false;\n\t}\n\n\treturn !!node.getCustomProperty( 'widget' );\n}\n\n/* eslint-disable max-len */\n/**\n * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:\n *\n * * sets the `contenteditable` attribute to `\"true\"`,\n * * adds the `ck-widget` CSS class,\n * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,\n * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},\n * * implements the {@link ~setHighlightHandling view highlight on widgets}.\n *\n * This function needs to be used in conjunction with\n * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}\n * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.\n *\n * For example, in order to convert a `<widget>` model element to `<div class=\"widget\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\tconst div = writer.createContainerElement( 'div', { class: 'widget' } );\n *\n *\t\t\t\t\treturn toWidget( div, writer, { label: 'some widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'widget',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'widget' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with a nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Object} [options={}]\n * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as\n * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).\n * @param {Boolean} [options.hasSelectionHandler=false] If `true`, the widget will have a selection handler added.\n * @returns {module:engine/view/element~Element} Returns the same element.\n */\n/* eslint-enable max-len */\nexport function toWidget( element, writer, options = {} ) {\n\t// The selection on Edge behaves better when the whole editor contents is in a single contenteditable element.\n\t// https://github.com/ckeditor/ckeditor5/issues/1079\n\tif ( !env.isEdge ) {\n\t\twriter.setAttribute( 'contenteditable', 'false', element );\n\t}\n\n\twriter.addClass( WIDGET_CLASS_NAME, element );\n\twriter.setCustomProperty( 'widget', true, element );\n\telement.getFillerOffset = getFillerOffset;\n\n\tif ( options.label ) {\n\t\tsetLabel( element, options.label, writer );\n\t}\n\n\tif ( options.hasSelectionHandler ) {\n\t\taddSelectionHandler( element, writer );\n\t}\n\n\tsetHighlightHandling(\n\t\telement,\n\t\twriter,\n\t\t( element, descriptor, writer ) => writer.addClass( normalizeToArray( descriptor.classes ), element ),\n\t\t( element, descriptor, writer ) => writer.removeClass( normalizeToArray( descriptor.classes ), element )\n\t);\n\n\treturn element;\n\n\t// Normalizes CSS class in descriptor that can be provided in form of an array or a string.\n\tfunction normalizeToArray( classes ) {\n\t\treturn Array.isArray( classes ) ? classes : [ classes ];\n\t}\n}\n\n/**\n * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to\n * properly determine which highlight descriptor should be used at given time.\n *\n * @param {module:engine/view/element~Element} element\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @param {Function} add\n * @param {Function} remove\n */\nexport function setHighlightHandling( element, writer, add, remove ) {\n\tconst stack = new HighlightStack();\n\n\tstack.on( 'change:top', ( evt, data ) => {\n\t\tif ( data.oldDescriptor ) {\n\t\t\tremove( element, data.oldDescriptor, data.writer );\n\t\t}\n\n\t\tif ( data.newDescriptor ) {\n\t\t\tadd( element, data.newDescriptor, data.writer );\n\t\t}\n\t} );\n\n\twriter.setCustomProperty( 'addHighlight', ( element, descriptor, writer ) => stack.add( descriptor, writer ), element );\n\twriter.setCustomProperty( 'removeHighlight', ( element, id, writer ) => stack.remove( id, writer ), element );\n}\n\n/**\n * Sets label for given element.\n * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by\n * {@link ~getLabel `getLabel()`}.\n *\n * @param {module:engine/view/element~Element} element\n * @param {String|Function} labelOrCreator\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n */\nexport function setLabel( element, labelOrCreator, writer ) {\n\twriter.setCustomProperty( 'widgetLabel', labelOrCreator, element );\n}\n\n/**\n * Returns the label of the provided element.\n *\n * @param {module:engine/view/element~Element} element\n * @returns {String}\n */\nexport function getLabel( element ) {\n\tconst labelCreator = element.getCustomProperty( 'widgetLabel' );\n\n\tif ( !labelCreator ) {\n\t\treturn '';\n\t}\n\n\treturn typeof labelCreator == 'function' ? labelCreator() : labelCreator;\n}\n\n/**\n * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:\n *\n * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,\n * otherwise sets it to `false`,\n * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,\n * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.\n *\n * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `dataDowncast` only and it is usually\n * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.\n *\n * For example, in order to convert a `<nested>` model element to `<div class=\"nested\">` in the view, you can define\n * such converters:\n *\n *\t\teditor.conversion.for( 'editingDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\tconst div = writer.createEditableElement( 'div', { class: 'nested' } );\n *\n *\t\t\t\t\treturn toWidgetEditable( nested, writer );\n *\t\t\t\t}\n *\t\t\t} );\n *\n *\t\teditor.conversion.for( 'dataDowncast' )\n *\t\t\t.elementToElement( {\n *\t\t\t\tmodel: 'nested',\n *\t\t\t\tview: ( modelItem, writer ) => {\n *\t\t\t\t\treturn writer.createContainerElement( 'div', { class: 'nested' } );\n *\t\t\t\t}\n *\t\t\t} );\n *\n * See the full source code of the widget (with nested editable) schema definition and converters in\n * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).\n *\n * @param {module:engine/view/editableelement~EditableElement} editable\n * @param {module:engine/view/downcastwriter~DowncastWriter} writer\n * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter\n */\nexport function toWidgetEditable( editable, writer ) {\n\twriter.addClass( [ 'ck-editor__editable', 'ck-editor__nested-editable' ], editable );\n\n\t// The selection on Edge behaves better when the whole editor contents is in a single contentedible element.\n\t// https://github.com/ckeditor/ckeditor5/issues/1079\n\tif ( !env.isEdge ) {\n\t\t// Set initial contenteditable value.\n\t\twriter.setAttribute( 'contenteditable', editable.isReadOnly ? 'false' : 'true', editable );\n\n\t\t// Bind the contenteditable property to element#isReadOnly.\n\t\teditable.on( 'change:isReadOnly', ( evt, property, is ) => {\n\t\t\twriter.setAttribute( 'contenteditable', is ? 'false' : 'true', editable );\n\t\t} );\n\t}\n\n\teditable.on( 'change:isFocused', ( evt, property, is ) => {\n\t\tif ( is ) {\n\t\t\twriter.addClass( 'ck-editor__nested-editable_focused', editable );\n\t\t} else {\n\t\t\twriter.removeClass( 'ck-editor__nested-editable_focused', editable );\n\t\t}\n\t} );\n\n\treturn editable;\n}\n\n/**\n * Returns a model position which is optimal (in terms of UX) for inserting a widget block.\n *\n * For instance, if a selection is in the middle of a paragraph, the position before this paragraph\n * will be returned so that it is not split. If the selection is at the end of a paragraph,\n * the position after this paragraph will be returned.\n *\n * Note: If the selection is placed in an empty block, that block will be returned. If that position\n * is then passed to {@link module:engine/model/model~Model#insertContent},\n * the block will be fully replaced by the image.\n *\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * The selection based on which the insertion position should be calculated.\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {module:engine/model/position~Position} The optimal position.\n */\nexport function findOptimalInsertionPosition( selection, model ) {\n\tconst selectedElement = selection.getSelectedElement();\n\n\tif ( selectedElement && model.schema.isBlock( selectedElement ) ) {\n\t\treturn model.createPositionAfter( selectedElement );\n\t}\n\n\tconst firstBlock = selection.getSelectedBlocks().next().value;\n\n\tif ( firstBlock ) {\n\t\t// If inserting into an empty block – return position in that block. It will get\n\t\t// replaced with the image by insertContent(). #42.\n\t\tif ( firstBlock.isEmpty ) {\n\t\t\treturn model.createPositionAt( firstBlock, 0 );\n\t\t}\n\n\t\tconst positionAfter = model.createPositionAfter( firstBlock );\n\n\t\t// If selection is at the end of the block - return position after the block.\n\t\tif ( selection.focus.isTouching( positionAfter ) ) {\n\t\t\treturn positionAfter;\n\t\t}\n\n\t\t// Otherwise return position before the block.\n\t\treturn model.createPositionBefore( firstBlock );\n\t}\n\n\treturn selection.focus;\n}\n\n/**\n * A util to be used in order to map view positions to correct model positions when implementing a widget\n * which renders non-empty view element for an empty model element.\n *\n * For example:\n *\n *\t\t// Model:\n *\t\t<placeholder type=\"name\"></placeholder>\n *\n *\t\t// View:\n *\t\t<span class=\"placeholder\">name</span>\n *\n * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).\n * To handle mapping positions inside `<span class=\"placeholder\">` to the model use this util as follows:\n *\n *\t\teditor.editing.mapper.on(\n *\t\t\t'viewToModelPosition',\n *\t\t\tviewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )\n *\t\t);\n *\n * The callback will try to map the view offset of selection to an expected model position.\n *\n * 1. When the position is at the end (or in the middle) of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">name|</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo <placeholder type=\"name\"></placeholder>| bar</paragraph>\n *\n * 2. When the position is at the beginning of the inline widget:\n *\n *\t\t// View:\n *\t\t<p>foo <span class=\"placeholder\">|name</span> bar</p>\n *\n *\t\t// Model:\n *\t\t<paragraph>foo |<placeholder type=\"name\"></placeholder> bar</paragraph>\n *\n * @param {module:engine/model/model~Model} model Model instance on which the callback operates.\n * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping\n * should be applied to the given view element.\n * @return {Function}\n */\nexport function viewToModelPositionOutsideModelElement( model, viewElementMatcher ) {\n\treturn ( evt, data ) => {\n\t\tconst { mapper, viewPosition } = data;\n\n\t\tconst viewParent = mapper.findMappedViewAncestor( viewPosition );\n\n\t\tif ( !viewElementMatcher( viewParent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelParent = mapper.toModelElement( viewParent );\n\n\t\tdata.modelPosition = model.createPositionAt( modelParent, viewPosition.isAtStart ? 'before' : 'after' );\n\t};\n}\n\n// Default filler offset function applied to all widget elements.\n//\n// @returns {null}\nfunction getFillerOffset() {\n\treturn null;\n}\n\n// Adds a drag handler to the widget.\n//\n// @param {module:engine/view/containerelement~ContainerElement}\n// @param {module:engine/view/downcastwriter~DowncastWriter} writer\nfunction addSelectionHandler( widgetElement, writer ) {\n\tconst selectionHandler = writer.createUIElement( 'div', { class: 'ck ck-widget__selection-handler' }, function( domDocument ) {\n\t\tconst domElement = this.toDomElement( domDocument );\n\n\t\t// Use the IconView from the ui library.\n\t\tconst icon = new IconView();\n\t\ticon.set( 'content', dragHandlerIcon );\n\n\t\t// Render the icon view right away to append its #element to the selectionHandler DOM element.\n\t\ticon.render();\n\n\t\tdomElement.appendChild( icon.element );\n\n\t\treturn domElement;\n\t} );\n\n\t// Append the selection handler into the widget wrapper.\n\twriter.insert( writer.createPositionAt( widgetElement, 0 ), selectionHandler );\n\twriter.addClass( [ 'ck-widget_with-selection-handler' ], widgetElement );\n}\n"]},"metadata":{},"sourceType":"module"}