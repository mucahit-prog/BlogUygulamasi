{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/config\n */\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n/**\n * Handles a configuration dictionary.\n */\n\nexport default class Config {\n  /**\n   * Creates an instance of the {@link ~Config} class.\n   *\n   * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n   * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n   */\n  constructor(configurations, defaultConfigurations) {\n    /**\n     * Store for the whole configuration.\n     *\n     * @private\n     * @member {Object}\n     */\n    this._config = {}; // Set default configuration.\n\n    if (defaultConfigurations) {\n      this.define(defaultConfigurations);\n    } // Set initial configuration.\n\n\n    if (configurations) {\n      this._setObjectToTarget(this._config, configurations);\n    }\n  }\n  /**\n   * Set configuration values.\n   *\n   * It accepts both a name/value pair or an object, which properties and values will be used to set\n   * configurations.\n   *\n   * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n   * the value for the `width` configuration in the `resize` subset.\n   *\n   *\t\tconfig.set( 'width', 500 );\n   *\t\tconfig.set( 'toolbar.collapsed', true );\n   *\n   *\t\t// Equivalent to:\n   *\t\tconfig.set( {\n   *\t\t\twidth: 500\n   *\t\t\ttoolbar: {\n   *\t\t\t\tcollapsed: true\n   *\t\t\t}\n   *\t\t} );\n   *\n   * Passing an object as the value will amend the configuration, not replace it.\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcollapsed: true,\n   *\t\t} );\n   *\n   *\t\tconfig.set( 'toolbar', {\n   *\t\t\tcolor: 'red',\n   *\t\t} );\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' ); // true\n   *\t\tconfig.get( 'toolbar.color' ); // 'red'\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n\n\n  set(name, value) {\n    this._setToTarget(this._config, name, value);\n  }\n  /**\n   * Does exactly the same as {@link #set} with one exception – passed configuration extends\n   * existing one, but does not overwrite already defined values.\n   *\n   * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n   * rarely used for other needs.\n   *\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   */\n\n\n  define(name, value) {\n    const isDefine = true;\n\n    this._setToTarget(this._config, name, value, isDefine);\n  }\n  /**\n   * Gets the value for a configuration entry.\n   *\n   *\t\tconfig.get( 'name' );\n   *\n   * Deep configurations can be retrieved by separating each part with a dot.\n   *\n   *\t\tconfig.get( 'toolbar.collapsed' );\n   *\n   * @param {String} name The configuration name. Configuration names are case-sensitive.\n   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n   */\n\n\n  get(name) {\n    return this._getFromSource(this._config, name);\n  }\n  /**\n   * Saves passed configuration to the specified target (nested object).\n   *\n   * @private\n   * @param {Object} target Nested config object.\n   * @param {String|Object} name The configuration name or an object from which take properties as\n   * configuration entries. Configuration names are case-sensitive.\n   * @param {*} value The configuration value. Used if a name is passed.\n   * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n   */\n\n\n  _setToTarget(target, name, value, isDefine = false) {\n    // In case of an object, iterate through it and call `_setToTarget` again for each property.\n    if (isPlainObject(name)) {\n      this._setObjectToTarget(target, name, isDefine);\n\n      return;\n    } // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\n\n    const parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\n    name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.\n\n    for (const part of parts) {\n      // If there is no object for specified part then create one.\n      if (!isPlainObject(target[part])) {\n        target[part] = {};\n      } // Nested object becomes a target.\n\n\n      target = target[part];\n    } // In case of value is an object.\n\n\n    if (isPlainObject(value)) {\n      // We take care of proper config structure.\n      if (!isPlainObject(target[name])) {\n        target[name] = {};\n      }\n\n      target = target[name]; // And iterate through this object calling `_setToTarget` again for each property.\n\n      this._setObjectToTarget(target, value, isDefine);\n\n      return;\n    } // Do nothing if we are defining configuration for non empty name.\n\n\n    if (isDefine && typeof target[name] != 'undefined') {\n      return;\n    }\n\n    target[name] = value;\n  }\n  /**\n   * Get specified configuration from specified source (nested object).\n   *\n   * @private\n   * @param {Object} source level of nested object.\n   * @param {String} name The configuration name. Configuration names are case-sensitive.\n   * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n   */\n\n\n  _getFromSource(source, name) {\n    // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n    const parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\n    name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.\n\n    for (const part of parts) {\n      if (!isPlainObject(source[part])) {\n        source = null;\n        break;\n      } // Nested object becomes a source.\n\n\n      source = source[part];\n    } // Always returns undefined for non existing configuration.\n\n\n    return source ? cloneConfig(source[name]) : undefined;\n  }\n  /**\n   * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n   *\n   * @private\n   * @param {Object} target Nested config object.\n   * @param {Object} configuration Configuration data set\n   * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n   */\n\n\n  _setObjectToTarget(target, configuration, isDefine) {\n    Object.keys(configuration).forEach(key => {\n      this._setToTarget(target, key, configuration[key], isDefine);\n    });\n  }\n\n} // Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\n\nfunction cloneConfig(source) {\n  return cloneDeepWith(source, leaveDOMReferences);\n} // A customizer function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\n\n\nfunction leaveDOMReferences(value) {\n  return isElement(value) ? value : undefined;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-utils/src/config.js"],"names":["isPlainObject","isElement","cloneDeepWith","Config","constructor","configurations","defaultConfigurations","_config","define","_setObjectToTarget","set","name","value","_setToTarget","isDefine","get","_getFromSource","target","parts","split","pop","part","source","cloneConfig","undefined","configuration","Object","keys","forEach","key","leaveDOMReferences"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/config\n */\n\nimport { isPlainObject, isElement, cloneDeepWith } from 'lodash-es';\n\n/**\n * Handles a configuration dictionary.\n */\nexport default class Config {\n\t/**\n\t * Creates an instance of the {@link ~Config} class.\n\t *\n\t * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.\n\t * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.\n\t */\n\tconstructor( configurations, defaultConfigurations ) {\n\t\t/**\n\t\t * Store for the whole configuration.\n\t\t *\n\t\t * @private\n\t\t * @member {Object}\n\t\t */\n\t\tthis._config = {};\n\n\t\t// Set default configuration.\n\t\tif ( defaultConfigurations ) {\n\t\t\tthis.define( defaultConfigurations );\n\t\t}\n\n\t\t// Set initial configuration.\n\t\tif ( configurations ) {\n\t\t\tthis._setObjectToTarget( this._config, configurations );\n\t\t}\n\t}\n\n\t/**\n\t * Set configuration values.\n\t *\n\t * It accepts both a name/value pair or an object, which properties and values will be used to set\n\t * configurations.\n\t *\n\t * It also accepts setting a \"deep configuration\" by using dots in the name. For example, `'resize.width'` sets\n\t * the value for the `width` configuration in the `resize` subset.\n\t *\n\t *\t\tconfig.set( 'width', 500 );\n\t *\t\tconfig.set( 'toolbar.collapsed', true );\n\t *\n\t *\t\t// Equivalent to:\n\t *\t\tconfig.set( {\n\t *\t\t\twidth: 500\n\t *\t\t\ttoolbar: {\n\t *\t\t\t\tcollapsed: true\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Passing an object as the value will amend the configuration, not replace it.\n\t *\n\t *\t\tconfig.set( 'toolbar', {\n\t *\t\t\tcollapsed: true,\n\t *\t\t} );\n\t *\n\t *\t\tconfig.set( 'toolbar', {\n\t *\t\t\tcolor: 'red',\n\t *\t\t} );\n\t *\n\t *\t\tconfig.get( 'toolbar.collapsed' ); // true\n\t *\t\tconfig.get( 'toolbar.color' ); // 'red'\n\t *\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t */\n\tset( name, value ) {\n\t\tthis._setToTarget( this._config, name, value );\n\t}\n\n\t/**\n\t * Does exactly the same as {@link #set} with one exception – passed configuration extends\n\t * existing one, but does not overwrite already defined values.\n\t *\n\t * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be\n\t * rarely used for other needs.\n\t *\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t */\n\tdefine( name, value ) {\n\t\tconst isDefine = true;\n\n\t\tthis._setToTarget( this._config, name, value, isDefine );\n\t}\n\n\t/**\n\t * Gets the value for a configuration entry.\n\t *\n\t *\t\tconfig.get( 'name' );\n\t *\n\t * Deep configurations can be retrieved by separating each part with a dot.\n\t *\n\t *\t\tconfig.get( 'toolbar.collapsed' );\n\t *\n\t * @param {String} name The configuration name. Configuration names are case-sensitive.\n\t * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n\t */\n\tget( name ) {\n\t\treturn this._getFromSource( this._config, name );\n\t}\n\n\t/**\n\t * Saves passed configuration to the specified target (nested object).\n\t *\n\t * @private\n\t * @param {Object} target Nested config object.\n\t * @param {String|Object} name The configuration name or an object from which take properties as\n\t * configuration entries. Configuration names are case-sensitive.\n\t * @param {*} value The configuration value. Used if a name is passed.\n\t * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.\n\t */\n\t_setToTarget( target, name, value, isDefine = false ) {\n\t\t// In case of an object, iterate through it and call `_setToTarget` again for each property.\n\t\tif ( isPlainObject( name ) ) {\n\t\t\tthis._setObjectToTarget( target, name, isDefine );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\t\tconst parts = name.split( '.' );\n\n\t\t// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\t\tname = parts.pop();\n\n\t\t// Iterate over parts to check if currently stored configuration has proper structure.\n\t\tfor ( const part of parts ) {\n\t\t\t// If there is no object for specified part then create one.\n\t\t\tif ( !isPlainObject( target[ part ] ) ) {\n\t\t\t\ttarget[ part ] = {};\n\t\t\t}\n\n\t\t\t// Nested object becomes a target.\n\t\t\ttarget = target[ part ];\n\t\t}\n\n\t\t// In case of value is an object.\n\t\tif ( isPlainObject( value ) ) {\n\t\t\t// We take care of proper config structure.\n\t\t\tif ( !isPlainObject( target[ name ] ) ) {\n\t\t\t\ttarget[ name ] = {};\n\t\t\t}\n\n\t\t\ttarget = target[ name ];\n\n\t\t\t// And iterate through this object calling `_setToTarget` again for each property.\n\t\t\tthis._setObjectToTarget( target, value, isDefine );\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Do nothing if we are defining configuration for non empty name.\n\t\tif ( isDefine && typeof target[ name ] != 'undefined' ) {\n\t\t\treturn;\n\t\t}\n\n\t\ttarget[ name ] = value;\n\t}\n\n\t/**\n\t * Get specified configuration from specified source (nested object).\n\t *\n\t * @private\n\t * @param {Object} source level of nested object.\n\t * @param {String} name The configuration name. Configuration names are case-sensitive.\n\t * @returns {*} The configuration value or `undefined` if the configuration entry was not found.\n\t */\n\t_getFromSource( source, name ) {\n\t\t// The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].\n\t\tconst parts = name.split( '.' );\n\n\t\t// Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.\n\t\tname = parts.pop();\n\n\t\t// Iterate over parts to check if currently stored configuration has proper structure.\n\t\tfor ( const part of parts ) {\n\t\t\tif ( !isPlainObject( source[ part ] ) ) {\n\t\t\t\tsource = null;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Nested object becomes a source.\n\t\t\tsource = source[ part ];\n\t\t}\n\n\t\t// Always returns undefined for non existing configuration.\n\t\treturn source ? cloneConfig( source[ name ] ) : undefined;\n\t}\n\n\t/**\n\t * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.\n\t *\n\t * @private\n\t * @param {Object} target Nested config object.\n\t * @param {Object} configuration Configuration data set\n\t * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.\n\t */\n\t_setObjectToTarget( target, configuration, isDefine ) {\n\t\tObject.keys( configuration ).forEach( key => {\n\t\t\tthis._setToTarget( target, key, configuration[ key ], isDefine );\n\t\t} );\n\t}\n}\n\n// Clones configuration object or value.\n// @param {*} source Source configuration\n// @returns {*} Cloned configuration value.\nfunction cloneConfig( source ) {\n\treturn cloneDeepWith( source, leaveDOMReferences );\n}\n\n// A customizer function for cloneDeepWith.\n// It will leave references to DOM Elements instead of cloning them.\n//\n// @param {*} value\n// @returns {Element|undefined}\nfunction leaveDOMReferences( value ) {\n\treturn isElement( value ) ? value : undefined;\n}\n"]},"metadata":{},"sourceType":"module"}