{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableutils\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport TableWalker from './tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './commands/utils';\n/**\n * The table utilities plugin.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class TableUtils extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get pluginName() {\n    return 'TableUtils';\n  }\n  /**\n   * Returns the table cell location as an object with table row and table column indexes.\n   *\n   * For instance in the table below:\n   *\n   *\t\t    0   1   2   3\n   *\t\t  +---+---+---+---+\n   *\t\t0 | a     | b | c |\n   *\t\t  +       +   +---+\n   *\t\t1 |       |   | d |\n   *\t\t  +---+---+   +---+\n   *\t\t2 | e     |   | f |\n   *\t\t  +---+---+---+---+\n   *\n   * the method will return:\n   *\n   *\t\tconst cellA = table.getNodeByPath( [ 0, 0 ] );\n   *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellA );\n   *\t\t// will return { row: 0, column: 0 }\n   *\n   *\t\tconst cellD = table.getNodeByPath( [ 1, 0 ] );\n   *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellD );\n   *\t\t// will return { row: 1, column: 3 }\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @returns {Object} Returns a `{row, column}` object.\n   */\n\n\n  getCellLocation(tableCell) {\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const rowIndex = table.getChildIndex(tableRow);\n    const tableWalker = new TableWalker(table, {\n      startRow: rowIndex,\n      endRow: rowIndex\n    });\n\n    for (const {\n      cell,\n      row,\n      column\n    } of tableWalker) {\n      if (cell === tableCell) {\n        return {\n          row,\n          column\n        };\n      }\n    }\n  }\n  /**\n   * Creates an empty table with proper structure. The table needs to be inserted into the model,\n   * ie. using {@link module:engine/model/model~Model#insertContent} function.\n   *\n   *\t\tmodel.change( ( writer ) => {\n   *\t\t\t// Create a table of 2 rows and 7 columns:\n   *\t\t\tconst table = tableUtils.createTable( writer, 2, 7);\n   *\n   *\t\t\t// Insert table to the model at the best position taking current selection:\n   *\t\t\tmodel.insertContent( table );\n   *\t\t}\n   *\n   * @param {module:engine/model/writer~Writer} writer The model writer.\n   * @param {Number} rows The number of rows to create.\n   * @param {Number} columns The number of columns to create.\n   * @returns {module:engine/model/element~Element} The created table element.\n   */\n\n\n  createTable(writer, rows, columns) {\n    const table = writer.createElement('table');\n    createEmptyRows(writer, table, 0, rows, columns);\n    return table;\n  }\n  /**\n   * Inserts rows into a table.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );\n   *\n   * Assuming the table on the left, the above code will transform it to the table on the right:\n   *\n   *\t\trow index\n   *\t\t  0 +---+---+---+       `at` = 1,      +---+---+---+ 0\n   *\t\t    | a | b | c |       `rows` = 2,    | a | b | c |\n   *\t\t  1 +   +---+---+   <-- insert here    +   +---+---+ 1\n   *\t\t    |   | d | e |                      |   |   |   |\n   *\t\t  2 +   +---+---+       will give:     +   +---+---+ 2\n   *\t\t    |   | f | g |                      |   |   |   |\n   *\t\t  3 +---+---+---+                      +   +---+---+ 3\n   *\t\t                                       |   | d | e |\n   *\t\t                                       +---+---+---+ 4\n   *\t\t                                       +   + f | g |\n   *\t\t                                       +---+---+---+ 5\n   *\n   * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.\n   * @param {Object} options\n   * @param {Number} [options.at=0] Row index at which the rows will be inserted.\n   * @param {Number} [options.rows=1] The number of rows to insert.\n   */\n\n\n  insertRows(table, options = {}) {\n    const model = this.editor.model;\n    const insertAt = options.at || 0;\n    const rowsToInsert = options.rows || 1;\n    model.change(writer => {\n      const headingRows = table.getAttribute('headingRows') || 0; // Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.\n\n      if (headingRows > insertAt) {\n        writer.setAttribute('headingRows', headingRows + rowsToInsert, table);\n      } // Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\n\n      if (insertAt === 0 || insertAt === table.childCount) {\n        createEmptyRows(writer, table, insertAt, rowsToInsert, this.getColumns(table));\n        return;\n      } // Iterate over all rows above inserted rows in order to check for rowspanned cells.\n\n\n      const tableIterator = new TableWalker(table, {\n        endRow: insertAt\n      }); // Will hold number of cells needed to insert in created rows.\n      // The number might be different then table cell width when there are rowspanned cells.\n\n      let cellsToInsert = 0;\n\n      for (const {\n        row,\n        rowspan,\n        colspan,\n        cell\n      } of tableIterator) {\n        const isBeforeInsertedRow = row < insertAt;\n        const overlapsInsertedRow = row + rowspan > insertAt;\n\n        if (isBeforeInsertedRow && overlapsInsertedRow) {\n          // This cell overlaps inserted rows so we need to expand it further.\n          writer.setAttribute('rowspan', rowspan + rowsToInsert, cell);\n        } // Calculate how many cells to insert based on the width of cells in a row at insert position.\n        // It might be lower then table width as some cells might overlaps inserted row.\n        // In the table above the cell 'a' overlaps inserted row so only two empty cells are need to be created.\n\n\n        if (row === insertAt) {\n          cellsToInsert += colspan;\n        }\n      }\n\n      createEmptyRows(writer, table, insertAt, rowsToInsert, cellsToInsert);\n    });\n  }\n  /**\n   * Inserts columns into a table.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );\n   *\n   * Assuming the table on the left, the above code will transform it to the table on the right:\n   *\n   *\t\t0   1   2   3                   0   1   2   3   4   5\n   *\t\t+---+---+---+                   +---+---+---+---+---+\n   *\t\t| a     | b |                   | a             | b |\n   *\t\t+       +---+                   +               +---+\n   *\t\t|       | c |                   |               | c |\n   *\t\t+---+---+---+     will give:    +---+---+---+---+---+\n   *\t\t| d | e | f |                   | d |   |   | e | f |\n   *\t\t+---+   +---+                   +---+---+---+  +---+\n   *\t\t| g |   | h |                   | g |   |   |   | h |\n   *\t\t+---+---+---+                   +---+---+---+---+---+\n   *\t\t| i         |                   | i                 |\n   *\t\t+---+---+---+                   +---+---+---+---+---+\n   *\t\t    ^---- insert here, `at` = 1, `columns` = 2\n   *\n   * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.\n   * @param {Object} options\n   * @param {Number} [options.at=0] Column index at which the columns will be inserted.\n   * @param {Number} [options.columns=1] The number of columns to insert.\n   */\n\n\n  insertColumns(table, options = {}) {\n    const model = this.editor.model;\n    const insertAt = options.at || 0;\n    const columnsToInsert = options.columns || 1;\n    model.change(writer => {\n      const headingColumns = table.getAttribute('headingColumns'); // Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.\n\n      if (insertAt < headingColumns) {\n        writer.setAttribute('headingColumns', headingColumns + columnsToInsert, table);\n      }\n\n      const tableColumns = this.getColumns(table); // Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\n      if (insertAt === 0 || tableColumns === insertAt) {\n        for (const tableRow of table.getChildren()) {\n          createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt ? 'end' : 0));\n        }\n\n        return;\n      }\n\n      const tableWalker = new TableWalker(table, {\n        column: insertAt,\n        includeSpanned: true\n      });\n\n      for (const {\n        row,\n        column,\n        cell,\n        colspan,\n        rowspan,\n        cellIndex\n      } of tableWalker) {\n        // When iterating over column the table walker outputs either:\n        // - cells at given column index (cell \"e\" from method docs),\n        // - spanned columns (spanned cell from row between cells \"g\" and \"h\" - spanned by \"e\", only if `includeSpanned: true`),\n        // - or a cell from the same row which spans over this column (cell \"a\").\n        if (column !== insertAt) {\n          // If column is different than `insertAt`, it is a cell that spans over an inserted column (cell \"a\" & \"i\").\n          // For such cells expand them by a number of columns inserted.\n          writer.setAttribute('colspan', colspan + columnsToInsert, cell); // The `includeSpanned` option will output the \"empty\"/spanned column so skip this row already.\n\n          tableWalker.skipRow(row); // This cell will overlap cells in rows below so skip them also (because of `includeSpanned` option) - (cell \"a\")\n\n          if (rowspan > 1) {\n            for (let i = row + 1; i < row + rowspan; i++) {\n              tableWalker.skipRow(i);\n            }\n          }\n        } else {\n          // It's either cell at this column index or spanned cell by a rowspanned cell from row above.\n          // In table above it's cell \"e\" and a spanned position from row below (empty cell between cells \"g\" and \"h\")\n          const insertPosition = writer.createPositionAt(table.getChild(row), cellIndex);\n          createCells(columnsToInsert, writer, insertPosition);\n        }\n      }\n    });\n  }\n  /**\n   * Divides a table cell vertically into several ones.\n   *\n   * The cell will be visually split into more cells by updating colspans of other cells in a column\n   * and inserting cells (columns) after that cell.\n   *\n   * In the table below, if cell \"a\" is split to 3 cells:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+---+---+---+\n   *\t\t| d | e | f |\n   *\t\t+---+---+---+\n   *\n   * it will result in the table below:\n   *\n   *\t\t+---+---+---+---+---+\n   *\t\t| a |   |   | b | c |\n   *\t\t+---+---+---+---+---+\n   *\t\t| d         | e | f |\n   *\t\t+---+---+---+---+---+\n   *\n   * So cell \"d\" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).\n   *\n   * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder\n   * will be left to the original cell:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a         |\n   *\t\t+---+---+---+\n   *\t\t| b | c | d |\n   *\t\t+---+---+---+\n   *\n   * Splitting cell \"a\" with `colspan=3` to 2 cells will create 1 cell with a `colspan=a` and cell \"a\" that will have `colspan=2`:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a     |   |\n   *\t\t+---+---+---+\n   *\t\t| b | c | d |\n   *\t\t+---+---+---+\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @param {Number} numberOfCells\n   */\n\n\n  splitCellVertically(tableCell, numberOfCells = 2) {\n    const model = this.editor.model;\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n    const colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n    model.change(writer => {\n      // First check - the cell spans over multiple rows so before doing anything else just split this cell.\n      if (colspan > 1) {\n        // Get spans of new (inserted) cells and span to update of split cell.\n        const {\n          newCellsSpan,\n          updatedSpan\n        } = breakSpanEvenly(colspan, numberOfCells);\n        updateNumericAttribute('colspan', updatedSpan, tableCell, writer); // Each inserted cell will have the same attributes:\n\n        const newCellsAttributes = {}; // Do not store default value in the model.\n\n        if (newCellsSpan > 1) {\n          newCellsAttributes.colspan = newCellsSpan;\n        } // Copy rowspan of split cell.\n\n\n        if (rowspan > 1) {\n          newCellsAttributes.rowspan = rowspan;\n        }\n\n        const cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;\n        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);\n      } // Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.\n\n\n      if (colspan < numberOfCells) {\n        const cellsToInsert = numberOfCells - colspan; // First step: expand cells on the same column as split cell.\n\n        const tableMap = [...new TableWalker(table)]; // Get the column index of split cell.\n\n        const {\n          column: splitCellColumn\n        } = tableMap.find(({\n          cell\n        }) => cell === tableCell); // Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.\n\n        const cellsToUpdate = tableMap.filter(({\n          cell,\n          colspan,\n          column\n        }) => {\n          const isOnSameColumn = cell !== tableCell && column === splitCellColumn;\n          const spansOverColumn = column < splitCellColumn && column + colspan > splitCellColumn;\n          return isOnSameColumn || spansOverColumn;\n        }); // Expand cells vertically.\n\n        for (const {\n          cell,\n          colspan\n        } of cellsToUpdate) {\n          writer.setAttribute('colspan', colspan + cellsToInsert, cell);\n        } // Second step: create columns after split cell.\n        // Each inserted cell will have the same attributes:\n\n\n        const newCellsAttributes = {}; // Do not store default value in the model.\n        // Copy rowspan of split cell.\n\n        if (rowspan > 1) {\n          newCellsAttributes.rowspan = rowspan;\n        }\n\n        createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);\n        const headingColumns = table.getAttribute('headingColumns') || 0; // Update heading section if split cell is in heading section.\n\n        if (headingColumns > splitCellColumn) {\n          updateNumericAttribute('headingColumns', headingColumns + cellsToInsert, table, writer);\n        }\n      }\n    });\n  }\n  /**\n   * Divides a table cell horizontally into several ones.\n   *\n   * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell\n   * below.\n   *\n   * If in the table below cell \"b\" is split to 3 cells:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+---+---+---+\n   *\t\t| d | e | f |\n   *\t\t+---+---+---+\n   *\n   * It will result in the table below:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+   +---+   +\n   *\t\t|   |   |   |\n   *\t\t+   +---+   +\n   *\t\t|   |   |   |\n   *\t\t+---+---+---+\n   *\t\t| d | e | f |\n   *\t\t+---+---+---+\n   *\n   * So cells \"a\" and \"b\" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.\n   *\n   * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder\n   * will be left to the original cell:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+   +---+---+\n   *\t\t|   | d | e |\n   *\t\t+   +---+---+\n   *\t\t|   | f | g |\n   *\t\t+   +---+---+\n   *\t\t|   | h | i |\n   *\t\t+---+---+---+\n   *\n   * Splitting cell \"a\" with `rowspan=4` to 3 cells will create 2 cells with a `rowspan=1` and cell \"a\" will have `rowspan=2`:\n   *\n   *\t\t+---+---+---+\n   *\t\t| a | b | c |\n   *\t\t+   +---+---+\n   *\t\t|   | d | e |\n   *\t\t+---+---+---+\n   *\t\t|   | f | g |\n   *\t\t+---+---+---+\n   *\t\t|   | h | i |\n   *\t\t+---+---+---+\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @param {Number} numberOfCells\n   */\n\n\n  splitCellHorizontally(tableCell, numberOfCells = 2) {\n    const model = this.editor.model;\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const splitCellRow = table.getChildIndex(tableRow);\n    const rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);\n    const colspan = parseInt(tableCell.getAttribute('colspan') || 1);\n    model.change(writer => {\n      // First check - the cell spans over multiple rows so before doing anything else just split this cell.\n      if (rowspan > 1) {\n        // Cache table map before updating table.\n        const tableMap = [...new TableWalker(table, {\n          startRow: splitCellRow,\n          endRow: splitCellRow + rowspan - 1,\n          includeSpanned: true\n        })]; // Get spans of new (inserted) cells and span to update of split cell.\n\n        const {\n          newCellsSpan,\n          updatedSpan\n        } = breakSpanEvenly(rowspan, numberOfCells);\n        updateNumericAttribute('rowspan', updatedSpan, tableCell, writer);\n        const {\n          column: cellColumn\n        } = tableMap.find(({\n          cell\n        }) => cell === tableCell); // Each inserted cell will have the same attributes:\n\n        const newCellsAttributes = {}; // Do not store default value in the model.\n\n        if (newCellsSpan > 1) {\n          newCellsAttributes.rowspan = newCellsSpan;\n        } // Copy colspan of split cell.\n\n\n        if (colspan > 1) {\n          newCellsAttributes.colspan = colspan;\n        }\n\n        for (const {\n          column,\n          row,\n          cellIndex\n        } of tableMap) {\n          // As both newly created cells and the split cell might have rowspan,\n          // the insertion of new cells must go to appropriate rows:\n          //\n          // 1. It's a row after split cell + it's height.\n          const isAfterSplitCell = row >= splitCellRow + updatedSpan; // 2. Is on the same column.\n\n          const isOnSameColumn = column === cellColumn; // 3. And it's row index is after previous cell height.\n\n          const isInEvenlySplitRow = (row + splitCellRow + updatedSpan) % newCellsSpan === 0;\n\n          if (isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow) {\n            const position = writer.createPositionAt(table.getChild(row), cellIndex);\n            createCells(1, writer, position, newCellsAttributes);\n          }\n        }\n      } // Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.\n\n\n      if (rowspan < numberOfCells) {\n        // We already split the cell in check one so here we split to the remaining number of cells only.\n        const cellsToInsert = numberOfCells - rowspan; // This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.\n\n        const tableMap = [...new TableWalker(table, {\n          startRow: 0,\n          endRow: splitCellRow\n        })]; // First step: expand cells.\n\n        for (const {\n          cell,\n          rowspan,\n          row\n        } of tableMap) {\n          // Expand rowspan of cells that are either:\n          // - on the same row as current cell,\n          // - or are below split cell row and overlaps that row.\n          if (cell !== tableCell && row + rowspan > splitCellRow) {\n            const rowspanToSet = rowspan + cellsToInsert;\n            writer.setAttribute('rowspan', rowspanToSet, cell);\n          }\n        } // Second step: create rows with single cell below split cell.\n\n\n        const newCellsAttributes = {}; // Copy colspan of split cell.\n\n        if (colspan > 1) {\n          newCellsAttributes.colspan = colspan;\n        }\n\n        createEmptyRows(writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes); // Update heading section if split cell is in heading section.\n\n        const headingRows = table.getAttribute('headingRows') || 0;\n\n        if (headingRows > splitCellRow) {\n          updateNumericAttribute('headingRows', headingRows + cellsToInsert, table, writer);\n        }\n      }\n    });\n  }\n  /**\n   * Returns the number of columns for a given table.\n   *\n   *\t\teditor.plugins.get( 'TableUtils' ).getColumns( table );\n   *\n   * @param {module:engine/model/element~Element} table The table to analyze.\n   * @returns {Number}\n   */\n\n\n  getColumns(table) {\n    // Analyze first row only as all the rows should have the same width.\n    const row = table.getChild(0);\n    return [...row.getChildren()].reduce((columns, row) => {\n      const columnWidth = parseInt(row.getAttribute('colspan') || 1);\n      return columns + columnWidth;\n    }, 0);\n  }\n\n} // Creates empty rows at the given index in an existing table.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/element~Element} table\n// @param {Number} insertAt Row index of row insertion.\n// @param {Number} rows Number of rows to create.\n// @param {Number} tableCellToInsert Number of cells to insert in each row.\n\nfunction createEmptyRows(writer, table, insertAt, rows, tableCellToInsert, attributes = {}) {\n  for (let i = 0; i < rows; i++) {\n    const tableRow = writer.createElement('tableRow');\n    writer.insert(tableRow, table, insertAt);\n    createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, 'end'), attributes);\n  }\n} // Creates cells at a given position.\n//\n// @param {Number} columns Number of columns to create\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/position~Position} insertPosition\n\n\nfunction createCells(cells, writer, insertPosition, attributes = {}) {\n  for (let i = 0; i < cells; i++) {\n    createEmptyTableCell(writer, insertPosition, attributes);\n  }\n} // Evenly distributes the span of a cell to a number of provided cells.\n// The resulting spans will always be integer values.\n//\n// For instance breaking a span of 7 into 3 cells will return:\n//\n//\t\t{ newCellsSpan: 2, updatedSpan: 3 }\n//\n// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.\n//\n// @param {Number} span Span value do break.\n// @param {Number} numberOfCells Number of resulting spans.\n// @returns {{newCellsSpan: Number, updatedSpan: Number}}\n\n\nfunction breakSpanEvenly(span, numberOfCells) {\n  if (span < numberOfCells) {\n    return {\n      newCellsSpan: 1,\n      updatedSpan: 1\n    };\n  }\n\n  const newCellsSpan = Math.floor(span / numberOfCells);\n  const updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;\n  return {\n    newCellsSpan,\n    updatedSpan\n  };\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-table/src/tableutils.js"],"names":["Plugin","TableWalker","createEmptyTableCell","updateNumericAttribute","TableUtils","pluginName","getCellLocation","tableCell","tableRow","parent","table","rowIndex","getChildIndex","tableWalker","startRow","endRow","cell","row","column","createTable","writer","rows","columns","createElement","createEmptyRows","insertRows","options","model","editor","insertAt","at","rowsToInsert","change","headingRows","getAttribute","setAttribute","childCount","getColumns","tableIterator","cellsToInsert","rowspan","colspan","isBeforeInsertedRow","overlapsInsertedRow","insertColumns","columnsToInsert","headingColumns","tableColumns","getChildren","createCells","createPositionAt","includeSpanned","cellIndex","skipRow","i","insertPosition","getChild","splitCellVertically","numberOfCells","parseInt","newCellsSpan","updatedSpan","breakSpanEvenly","newCellsAttributes","createPositionAfter","tableMap","splitCellColumn","find","cellsToUpdate","filter","isOnSameColumn","spansOverColumn","splitCellHorizontally","splitCellRow","cellColumn","isAfterSplitCell","isInEvenlySplitRow","position","rowspanToSet","reduce","columnWidth","tableCellToInsert","attributes","insert","cells","span","Math","floor"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableutils\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n\nimport TableWalker from './tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './commands/utils';\n\n/**\n * The table utilities plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableUtils extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableUtils';\n\t}\n\n\t/**\n\t * Returns the table cell location as an object with table row and table column indexes.\n\t *\n\t * For instance in the table below:\n\t *\n\t *\t\t    0   1   2   3\n\t *\t\t  +---+---+---+---+\n\t *\t\t0 | a     | b | c |\n\t *\t\t  +       +   +---+\n\t *\t\t1 |       |   | d |\n\t *\t\t  +---+---+   +---+\n\t *\t\t2 | e     |   | f |\n\t *\t\t  +---+---+---+---+\n\t *\n\t * the method will return:\n\t *\n\t *\t\tconst cellA = table.getNodeByPath( [ 0, 0 ] );\n\t *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellA );\n\t *\t\t// will return { row: 0, column: 0 }\n\t *\n\t *\t\tconst cellD = table.getNodeByPath( [ 1, 0 ] );\n\t *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellD );\n\t *\t\t// will return { row: 1, column: 3 }\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @returns {Object} Returns a `{row, column}` object.\n\t */\n\tgetCellLocation( tableCell ) {\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { startRow: rowIndex, endRow: rowIndex } );\n\n\t\tfor ( const { cell, row, column } of tableWalker ) {\n\t\t\tif ( cell === tableCell ) {\n\t\t\t\treturn { row, column };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an empty table with proper structure. The table needs to be inserted into the model,\n\t * ie. using {@link module:engine/model/model~Model#insertContent} function.\n\t *\n\t *\t\tmodel.change( ( writer ) => {\n\t *\t\t\t// Create a table of 2 rows and 7 columns:\n\t *\t\t\tconst table = tableUtils.createTable( writer, 2, 7);\n\t *\n\t *\t\t\t// Insert table to the model at the best position taking current selection:\n\t *\t\t\tmodel.insertContent( table );\n\t *\t\t}\n\t *\n\t * @param {module:engine/model/writer~Writer} writer The model writer.\n\t * @param {Number} rows The number of rows to create.\n\t * @param {Number} columns The number of columns to create.\n\t * @returns {module:engine/model/element~Element} The created table element.\n\t */\n\tcreateTable( writer, rows, columns ) {\n\t\tconst table = writer.createElement( 'table' );\n\n\t\tcreateEmptyRows( writer, table, 0, rows, columns );\n\n\t\treturn table;\n\t}\n\n\t/**\n\t * Inserts rows into a table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );\n\t *\n\t * Assuming the table on the left, the above code will transform it to the table on the right:\n\t *\n\t *\t\trow index\n\t *\t\t  0 +---+---+---+       `at` = 1,      +---+---+---+ 0\n\t *\t\t    | a | b | c |       `rows` = 2,    | a | b | c |\n\t *\t\t  1 +   +---+---+   <-- insert here    +   +---+---+ 1\n\t *\t\t    |   | d | e |                      |   |   |   |\n\t *\t\t  2 +   +---+---+       will give:     +   +---+---+ 2\n\t *\t\t    |   | f | g |                      |   |   |   |\n\t *\t\t  3 +---+---+---+                      +   +---+---+ 3\n\t *\t\t                                       |   | d | e |\n\t *\t\t                                       +---+---+---+ 4\n\t *\t\t                                       +   + f | g |\n\t *\t\t                                       +---+---+---+ 5\n\t *\n\t * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.\n\t * @param {Object} options\n\t * @param {Number} [options.at=0] Row index at which the rows will be inserted.\n\t * @param {Number} [options.rows=1] The number of rows to insert.\n\t */\n\tinsertRows( table, options = {} ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst insertAt = options.at || 0;\n\t\tconst rowsToInsert = options.rows || 1;\n\n\t\tmodel.change( writer => {\n\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t// Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.\n\t\t\tif ( headingRows > insertAt ) {\n\t\t\t\twriter.setAttribute( 'headingRows', headingRows + rowsToInsert, table );\n\t\t\t}\n\n\t\t\t// Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\t\t\tif ( insertAt === 0 || insertAt === table.childCount ) {\n\t\t\t\tcreateEmptyRows( writer, table, insertAt, rowsToInsert, this.getColumns( table ) );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Iterate over all rows above inserted rows in order to check for rowspanned cells.\n\t\t\tconst tableIterator = new TableWalker( table, { endRow: insertAt } );\n\n\t\t\t// Will hold number of cells needed to insert in created rows.\n\t\t\t// The number might be different then table cell width when there are rowspanned cells.\n\t\t\tlet cellsToInsert = 0;\n\n\t\t\tfor ( const { row, rowspan, colspan, cell } of tableIterator ) {\n\t\t\t\tconst isBeforeInsertedRow = row < insertAt;\n\t\t\t\tconst overlapsInsertedRow = row + rowspan > insertAt;\n\n\t\t\t\tif ( isBeforeInsertedRow && overlapsInsertedRow ) {\n\t\t\t\t\t// This cell overlaps inserted rows so we need to expand it further.\n\t\t\t\t\twriter.setAttribute( 'rowspan', rowspan + rowsToInsert, cell );\n\t\t\t\t}\n\n\t\t\t\t// Calculate how many cells to insert based on the width of cells in a row at insert position.\n\t\t\t\t// It might be lower then table width as some cells might overlaps inserted row.\n\t\t\t\t// In the table above the cell 'a' overlaps inserted row so only two empty cells are need to be created.\n\t\t\t\tif ( row === insertAt ) {\n\t\t\t\t\tcellsToInsert += colspan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcreateEmptyRows( writer, table, insertAt, rowsToInsert, cellsToInsert );\n\t\t} );\n\t}\n\n\t/**\n\t * Inserts columns into a table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );\n\t *\n\t * Assuming the table on the left, the above code will transform it to the table on the right:\n\t *\n\t *\t\t0   1   2   3                   0   1   2   3   4   5\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t| a     | b |                   | a             | b |\n\t *\t\t+       +---+                   +               +---+\n\t *\t\t|       | c |                   |               | c |\n\t *\t\t+---+---+---+     will give:    +---+---+---+---+---+\n\t *\t\t| d | e | f |                   | d |   |   | e | f |\n\t *\t\t+---+   +---+                   +---+---+---+  +---+\n\t *\t\t| g |   | h |                   | g |   |   |   | h |\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t| i         |                   | i                 |\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t    ^---- insert here, `at` = 1, `columns` = 2\n\t *\n\t * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.\n\t * @param {Object} options\n\t * @param {Number} [options.at=0] Column index at which the columns will be inserted.\n\t * @param {Number} [options.columns=1] The number of columns to insert.\n\t */\n\tinsertColumns( table, options = {} ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst insertAt = options.at || 0;\n\t\tconst columnsToInsert = options.columns || 1;\n\n\t\tmodel.change( writer => {\n\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' );\n\n\t\t\t// Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.\n\t\t\tif ( insertAt < headingColumns ) {\n\t\t\t\twriter.setAttribute( 'headingColumns', headingColumns + columnsToInsert, table );\n\t\t\t}\n\n\t\t\tconst tableColumns = this.getColumns( table );\n\n\t\t\t// Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\t\t\tif ( insertAt === 0 || tableColumns === insertAt ) {\n\t\t\t\tfor ( const tableRow of table.getChildren() ) {\n\t\t\t\t\tcreateCells( columnsToInsert, writer, writer.createPositionAt( tableRow, insertAt ? 'end' : 0 ) );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tableWalker = new TableWalker( table, { column: insertAt, includeSpanned: true } );\n\n\t\t\tfor ( const { row, column, cell, colspan, rowspan, cellIndex } of tableWalker ) {\n\t\t\t\t// When iterating over column the table walker outputs either:\n\t\t\t\t// - cells at given column index (cell \"e\" from method docs),\n\t\t\t\t// - spanned columns (spanned cell from row between cells \"g\" and \"h\" - spanned by \"e\", only if `includeSpanned: true`),\n\t\t\t\t// - or a cell from the same row which spans over this column (cell \"a\").\n\n\t\t\t\tif ( column !== insertAt ) {\n\t\t\t\t\t// If column is different than `insertAt`, it is a cell that spans over an inserted column (cell \"a\" & \"i\").\n\t\t\t\t\t// For such cells expand them by a number of columns inserted.\n\t\t\t\t\twriter.setAttribute( 'colspan', colspan + columnsToInsert, cell );\n\n\t\t\t\t\t// The `includeSpanned` option will output the \"empty\"/spanned column so skip this row already.\n\t\t\t\t\ttableWalker.skipRow( row );\n\n\t\t\t\t\t// This cell will overlap cells in rows below so skip them also (because of `includeSpanned` option) - (cell \"a\")\n\t\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\t\tfor ( let i = row + 1; i < row + rowspan; i++ ) {\n\t\t\t\t\t\t\ttableWalker.skipRow( i );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// It's either cell at this column index or spanned cell by a rowspanned cell from row above.\n\t\t\t\t\t// In table above it's cell \"e\" and a spanned position from row below (empty cell between cells \"g\" and \"h\")\n\t\t\t\t\tconst insertPosition = writer.createPositionAt( table.getChild( row ), cellIndex );\n\n\t\t\t\t\tcreateCells( columnsToInsert, writer, insertPosition );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Divides a table cell vertically into several ones.\n\t *\n\t * The cell will be visually split into more cells by updating colspans of other cells in a column\n\t * and inserting cells (columns) after that cell.\n\t *\n\t * In the table below, if cell \"a\" is split to 3 cells:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * it will result in the table below:\n\t *\n\t *\t\t+---+---+---+---+---+\n\t *\t\t| a |   |   | b | c |\n\t *\t\t+---+---+---+---+---+\n\t *\t\t| d         | e | f |\n\t *\t\t+---+---+---+---+---+\n\t *\n\t * So cell \"d\" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).\n\t *\n\t * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder\n\t * will be left to the original cell:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a         |\n\t *\t\t+---+---+---+\n\t *\t\t| b | c | d |\n\t *\t\t+---+---+---+\n\t *\n\t * Splitting cell \"a\" with `colspan=3` to 2 cells will create 1 cell with a `colspan=a` and cell \"a\" that will have `colspan=2`:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a     |   |\n\t *\t\t+---+---+---+\n\t *\t\t| b | c | d |\n\t *\t\t+---+---+---+\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {Number} numberOfCells\n\t */\n\tsplitCellVertically( tableCell, numberOfCells = 2 ) {\n\t\tconst model = this.editor.model;\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\tmodel.change( writer => {\n\t\t\t// First check - the cell spans over multiple rows so before doing anything else just split this cell.\n\t\t\tif ( colspan > 1 ) {\n\t\t\t\t// Get spans of new (inserted) cells and span to update of split cell.\n\t\t\t\tconst { newCellsSpan, updatedSpan } = breakSpanEvenly( colspan, numberOfCells );\n\n\t\t\t\tupdateNumericAttribute( 'colspan', updatedSpan, tableCell, writer );\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\t\t\t\tif ( newCellsSpan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = newCellsSpan;\n\t\t\t\t}\n\n\t\t\t\t// Copy rowspan of split cell.\n\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = rowspan;\n\t\t\t\t}\n\n\t\t\t\tconst cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;\n\t\t\t\tcreateCells( cellsToInsert, writer, writer.createPositionAfter( tableCell ), newCellsAttributes );\n\t\t\t}\n\n\t\t\t// Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.\n\t\t\tif ( colspan < numberOfCells ) {\n\t\t\t\tconst cellsToInsert = numberOfCells - colspan;\n\n\t\t\t\t// First step: expand cells on the same column as split cell.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table ) ];\n\n\t\t\t\t// Get the column index of split cell.\n\t\t\t\tconst { column: splitCellColumn } = tableMap.find( ( { cell } ) => cell === tableCell );\n\n\t\t\t\t// Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.\n\t\t\t\tconst cellsToUpdate = tableMap.filter( ( { cell, colspan, column } ) => {\n\t\t\t\t\tconst isOnSameColumn = cell !== tableCell && column === splitCellColumn;\n\t\t\t\t\tconst spansOverColumn = ( column < splitCellColumn && column + colspan > splitCellColumn );\n\n\t\t\t\t\treturn isOnSameColumn || spansOverColumn;\n\t\t\t\t} );\n\n\t\t\t\t// Expand cells vertically.\n\t\t\t\tfor ( const { cell, colspan } of cellsToUpdate ) {\n\t\t\t\t\twriter.setAttribute( 'colspan', colspan + cellsToInsert, cell );\n\t\t\t\t}\n\n\t\t\t\t// Second step: create columns after split cell.\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\n\t\t\t\t// Copy rowspan of split cell.\n\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = rowspan;\n\t\t\t\t}\n\n\t\t\t\tcreateCells( cellsToInsert, writer, writer.createPositionAfter( tableCell ), newCellsAttributes );\n\n\t\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' ) || 0;\n\n\t\t\t\t// Update heading section if split cell is in heading section.\n\t\t\t\tif ( headingColumns > splitCellColumn ) {\n\t\t\t\t\tupdateNumericAttribute( 'headingColumns', headingColumns + cellsToInsert, table, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Divides a table cell horizontally into several ones.\n\t *\n\t * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell\n\t * below.\n\t *\n\t * If in the table below cell \"b\" is split to 3 cells:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * It will result in the table below:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+   +\n\t *\t\t|   |   |   |\n\t *\t\t+   +---+   +\n\t *\t\t|   |   |   |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * So cells \"a\" and \"b\" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.\n\t *\n\t * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder\n\t * will be left to the original cell:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+---+\n\t *\t\t|   | d | e |\n\t *\t\t+   +---+---+\n\t *\t\t|   | f | g |\n\t *\t\t+   +---+---+\n\t *\t\t|   | h | i |\n\t *\t\t+---+---+---+\n\t *\n\t * Splitting cell \"a\" with `rowspan=4` to 3 cells will create 2 cells with a `rowspan=1` and cell \"a\" will have `rowspan=2`:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+---+\n\t *\t\t|   | d | e |\n\t *\t\t+---+---+---+\n\t *\t\t|   | f | g |\n\t *\t\t+---+---+---+\n\t *\t\t|   | h | i |\n\t *\t\t+---+---+---+\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {Number} numberOfCells\n\t */\n\tsplitCellHorizontally( tableCell, numberOfCells = 2 ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\t\tconst splitCellRow = table.getChildIndex( tableRow );\n\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\tmodel.change( writer => {\n\t\t\t// First check - the cell spans over multiple rows so before doing anything else just split this cell.\n\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t// Cache table map before updating table.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table, {\n\t\t\t\t\tstartRow: splitCellRow,\n\t\t\t\t\tendRow: splitCellRow + rowspan - 1,\n\t\t\t\t\tincludeSpanned: true\n\t\t\t\t} ) ];\n\n\t\t\t\t// Get spans of new (inserted) cells and span to update of split cell.\n\t\t\t\tconst { newCellsSpan, updatedSpan } = breakSpanEvenly( rowspan, numberOfCells );\n\n\t\t\t\tupdateNumericAttribute( 'rowspan', updatedSpan, tableCell, writer );\n\n\t\t\t\tconst { column: cellColumn } = tableMap.find( ( { cell } ) => cell === tableCell );\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\t\t\t\tif ( newCellsSpan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = newCellsSpan;\n\t\t\t\t}\n\n\t\t\t\t// Copy colspan of split cell.\n\t\t\t\tif ( colspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = colspan;\n\t\t\t\t}\n\n\t\t\t\tfor ( const { column, row, cellIndex } of tableMap ) {\n\t\t\t\t\t// As both newly created cells and the split cell might have rowspan,\n\t\t\t\t\t// the insertion of new cells must go to appropriate rows:\n\t\t\t\t\t//\n\t\t\t\t\t// 1. It's a row after split cell + it's height.\n\t\t\t\t\tconst isAfterSplitCell = row >= splitCellRow + updatedSpan;\n\t\t\t\t\t// 2. Is on the same column.\n\t\t\t\t\tconst isOnSameColumn = column === cellColumn;\n\t\t\t\t\t// 3. And it's row index is after previous cell height.\n\t\t\t\t\tconst isInEvenlySplitRow = ( row + splitCellRow + updatedSpan ) % newCellsSpan === 0;\n\n\t\t\t\t\tif ( isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow ) {\n\t\t\t\t\t\tconst position = writer.createPositionAt( table.getChild( row ), cellIndex );\n\n\t\t\t\t\t\tcreateCells( 1, writer, position, newCellsAttributes );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.\n\t\t\tif ( rowspan < numberOfCells ) {\n\t\t\t\t// We already split the cell in check one so here we split to the remaining number of cells only.\n\t\t\t\tconst cellsToInsert = numberOfCells - rowspan;\n\n\t\t\t\t// This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table, { startRow: 0, endRow: splitCellRow } ) ];\n\n\t\t\t\t// First step: expand cells.\n\t\t\t\tfor ( const { cell, rowspan, row } of tableMap ) {\n\t\t\t\t\t// Expand rowspan of cells that are either:\n\t\t\t\t\t// - on the same row as current cell,\n\t\t\t\t\t// - or are below split cell row and overlaps that row.\n\t\t\t\t\tif ( cell !== tableCell && row + rowspan > splitCellRow ) {\n\t\t\t\t\t\tconst rowspanToSet = rowspan + cellsToInsert;\n\n\t\t\t\t\t\twriter.setAttribute( 'rowspan', rowspanToSet, cell );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Second step: create rows with single cell below split cell.\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Copy colspan of split cell.\n\t\t\t\tif ( colspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = colspan;\n\t\t\t\t}\n\n\t\t\t\tcreateEmptyRows( writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes );\n\n\t\t\t\t// Update heading section if split cell is in heading section.\n\t\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t\tif ( headingRows > splitCellRow ) {\n\t\t\t\t\tupdateNumericAttribute( 'headingRows', headingRows + cellsToInsert, table, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the number of columns for a given table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).getColumns( table );\n\t *\n\t * @param {module:engine/model/element~Element} table The table to analyze.\n\t * @returns {Number}\n\t */\n\tgetColumns( table ) {\n\t\t// Analyze first row only as all the rows should have the same width.\n\t\tconst row = table.getChild( 0 );\n\n\t\treturn [ ...row.getChildren() ].reduce( ( columns, row ) => {\n\t\t\tconst columnWidth = parseInt( row.getAttribute( 'colspan' ) || 1 );\n\n\t\t\treturn columns + columnWidth;\n\t\t}, 0 );\n\t}\n}\n\n// Creates empty rows at the given index in an existing table.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/element~Element} table\n// @param {Number} insertAt Row index of row insertion.\n// @param {Number} rows Number of rows to create.\n// @param {Number} tableCellToInsert Number of cells to insert in each row.\nfunction createEmptyRows( writer, table, insertAt, rows, tableCellToInsert, attributes = {} ) {\n\tfor ( let i = 0; i < rows; i++ ) {\n\t\tconst tableRow = writer.createElement( 'tableRow' );\n\n\t\twriter.insert( tableRow, table, insertAt );\n\n\t\tcreateCells( tableCellToInsert, writer, writer.createPositionAt( tableRow, 'end' ), attributes );\n\t}\n}\n\n// Creates cells at a given position.\n//\n// @param {Number} columns Number of columns to create\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/position~Position} insertPosition\nfunction createCells( cells, writer, insertPosition, attributes = {} ) {\n\tfor ( let i = 0; i < cells; i++ ) {\n\t\tcreateEmptyTableCell( writer, insertPosition, attributes );\n\t}\n}\n\n// Evenly distributes the span of a cell to a number of provided cells.\n// The resulting spans will always be integer values.\n//\n// For instance breaking a span of 7 into 3 cells will return:\n//\n//\t\t{ newCellsSpan: 2, updatedSpan: 3 }\n//\n// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.\n//\n// @param {Number} span Span value do break.\n// @param {Number} numberOfCells Number of resulting spans.\n// @returns {{newCellsSpan: Number, updatedSpan: Number}}\nfunction breakSpanEvenly( span, numberOfCells ) {\n\tif ( span < numberOfCells ) {\n\t\treturn { newCellsSpan: 1, updatedSpan: 1 };\n\t}\n\n\tconst newCellsSpan = Math.floor( span / numberOfCells );\n\tconst updatedSpan = ( span - newCellsSpan * numberOfCells ) + newCellsSpan;\n\n\treturn { newCellsSpan, updatedSpan };\n}\n"]},"metadata":{},"sourceType":"module"}