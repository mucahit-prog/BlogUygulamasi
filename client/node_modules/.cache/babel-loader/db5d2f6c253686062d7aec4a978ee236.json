{"ast":null,"code":"// @flow\nimport { CharacterMetadata, EditorState, ContentState } from 'draft-js'; // @flow\n\nvar ATOMIC = \"atomic\";\nvar UNSTYLED = \"unstyled\";\nvar UNORDERED_LIST_ITEM = \"unordered-list-item\";\nvar ORDERED_LIST_ITEM = \"ordered-list-item\";\nvar IMAGE = \"IMAGE\"; // @flow\n\n/**\n * Creates atomic blocks where they would be required for a block-level entity\n * to work correctly, when such an entity exists.\n * Note: at the moment, this is only useful for IMAGE entities that Draft.js\n * injects on arbitrary blocks on paste.\n */\n\nvar preserveAtomicBlocks = function preserveAtomicBlocks(content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var perservedBlocks = blockMap.filter(function (block) {\n    var text = block.getText();\n    var entityKey = block.getEntityAt(0);\n    var shouldPreserve = entityKey && [\"ðŸ“·\", \" \", \"ðŸ“· \"].includes(text);\n    return shouldPreserve;\n  }).map(function (block) {\n    return block.set(\"type\", ATOMIC);\n  });\n\n  if (perservedBlocks.size !== 0) {\n    return content.merge({\n      blockMap: blockMap.merge(perservedBlocks)\n    });\n  }\n\n  return content;\n};\n/**\n * Resets atomic blocks to have a single-space char and no styles.\n * This is how they are stored by Draft.js by default.\n */\n\n\nvar resetAtomicBlocks = function resetAtomicBlocks(content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap;\n  var normalisedBlocks = blocks.filter(function (block) {\n    return block.getType() === ATOMIC && (block.getText() !== \" \" || block.getInlineStyleAt(0).size !== 0);\n  }).map(function (block) {\n    // Retain only the first character, and remove all of its styles.\n    var chars = block.getCharacterList().slice(0, 1).map(function (char) {\n      var newChar = char;\n      char.getStyle().forEach(function (type) {\n        newChar = CharacterMetadata.removeStyle(newChar, type);\n      });\n      return newChar;\n    });\n    return block.merge({\n      text: \" \",\n      characterList: chars\n    });\n  });\n\n  if (normalisedBlocks.size !== 0) {\n    blocks = blocks.merge(normalisedBlocks);\n  }\n\n  return content.merge({\n    blockMap: blocks\n  });\n};\n/**\n * Removes atomic blocks for which the entity type isn't allowed.\n */\n\n\nvar removeInvalidAtomicBlocks = function removeInvalidAtomicBlocks(allowlist\n/*: $ReadOnlyArray<{ type: string }>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n\n  var isValidAtomicBlock = function isValidAtomicBlock(block) {\n    if (block.getType() !== ATOMIC) {\n      return true;\n    }\n\n    var entityKey = block.getEntityAt(0);\n    var isValid;\n\n    if (entityKey) {\n      var type = content.getEntity(entityKey).getType();\n      isValid = allowlist.some(function (t) {\n        return t.type === type;\n      });\n    } else {\n      isValid = false;\n    }\n\n    return isValid;\n  };\n\n  var filteredBlocks = blockMap.filter(isValidAtomicBlock);\n\n  if (filteredBlocks.size !== blockMap.size) {\n    return content.merge({\n      blockMap: filteredBlocks\n    });\n  }\n\n  return content;\n}; // @flow\n\n/**\n * Removes blocks that have a non-zero depth, and aren't list items.\n * Happens with Apple Pages inserting `unstyled` items between list items.\n */\n\n\nvar removeInvalidDepthBlocks = function removeInvalidDepthBlocks(content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n\n  var isValidDepthBlock = function isValidDepthBlock(block) {\n    var isListBlock = [UNORDERED_LIST_ITEM, ORDERED_LIST_ITEM].includes(block.getType());\n    return isListBlock || block.getDepth() === 0;\n  };\n\n  var filteredBlocks = blockMap.filter(isValidDepthBlock);\n\n  if (filteredBlocks.size !== blockMap.size) {\n    return content.merge({\n      blockMap: filteredBlocks\n    });\n  }\n\n  return content;\n};\n/**\n * Changes block type and depth based on the block's text. â€“ some word processors\n * add a specific prefix within the text, eg. \"Â· Bulleted list\" in Word 2010.\n * Also removes the matched text.\n * This is meant first and foremost for list items where the list bullet or numeral\n * ends up in the text. Other use cases may not be well covered.\n */\n\n\nvar preserveBlockByText = function preserveBlockByText(rules\n/*: $ReadOnlyArray<{\n    test: string,\n    type: string,\n    depth: number,\n  }>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap.filter(function (block) {\n    return block.getType() === \"unstyled\";\n  }).map(function (block) {\n    var text = block.getText();\n    var newBlock = block;\n    var match;\n    var matchingRule = rules.find(function (rule) {\n      match = new RegExp(rule.test).exec(text);\n      return match !== null;\n    });\n\n    if (matchingRule && match && match[0]) {\n      var _text = block.getText();\n\n      var entity = block.getEntityAt(0); // Special case â€“ do not convert the block if there is an entity at the start, and the matching text is the full blockâ€™s text.\n      // This can happen in Word for equations, which are injected as images with text \"ðŸ“· \".\n\n      if (entity && match[0] === _text) {\n        return newBlock;\n      } // Unicode gotcha:\n      // At the moment, Draft.js stores one CharacterMetadata in the character list\n      // for each \"character\" in an astral symbol. \"ðŸ“·\" has a length of 2, is stored with two CharacterMetadata instances.\n      // What matters is that we remove the correct number of chars from both\n      // the text and the List<CharacterMetadata>. So â€“ we want to use the ES5 way of counting\n      // a string length.\n      // See https://mathiasbynens.be/notes/javascript-unicode.\n\n\n      var sliceOffset = match[0].length; // Maintain persistence in the list while removing chars from the start.\n      // https://github.com/facebook/draft-js/blob/788595984da7c1e00d1071ea82b063ff87140be4/src/model/transaction/removeRangeFromContentState.js#L333\n\n      var chars = block.getCharacterList();\n      var startOffset = 0;\n\n      while (startOffset < sliceOffset) {\n        chars = chars.shift();\n        startOffset++;\n      }\n\n      newBlock = newBlock.merge({\n        type: matchingRule.type,\n        depth: matchingRule.depth,\n        text: _text.slice(sliceOffset),\n        characterList: chars\n      });\n    }\n\n    return newBlock;\n  });\n  return blocks.size === 0 ? content : content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n/**\n * Resets the depth of all the content to at most max.\n */\n\n\nvar limitBlockDepth = function limitBlockDepth(max\n/*: number*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var changedBlocks = blockMap.filter(function (block) {\n    return block.getDepth() > max;\n  }).map(function (block) {\n    return block.set(\"depth\", max);\n  });\n  return changedBlocks.size === 0 ? content : content.merge({\n    blockMap: blockMap.merge(changedBlocks)\n  });\n};\n/**\n * Converts all block types not present in the list to unstyled.\n * Also sets depth to 0 (for potentially nested list items).\n */\n\n\nvar filterBlockTypes = function filterBlockTypes(allowlist\n/*: $ReadOnlyArray<string>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var changedBlocks = blockMap.filter(function (block) {\n    return !allowlist.includes(block.getType());\n  }).map(function (block) {\n    return block.merge({\n      type: UNSTYLED,\n      depth: 0\n    });\n  });\n  return changedBlocks.size === 0 ? content : content.merge({\n    blockMap: blockMap.merge(changedBlocks)\n  });\n}; // @flow\n\n/**\n * Removes all styles not present in the list.\n */\n\n\nvar filterInlineStyles = function filterInlineStyles(allowlist\n/*: $ReadOnlyArray<string>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap.map(function (block) {\n    var altered = false;\n    var chars = block.getCharacterList().map(function (char) {\n      var newChar = char;\n      char.getStyle().filter(function (type) {\n        return !allowlist.includes(type);\n      }).forEach(function (type) {\n        altered = true;\n        newChar = CharacterMetadata.removeStyle(newChar, type);\n      });\n      return newChar;\n    });\n    return altered ? block.set(\"characterList\", chars) : block;\n  });\n  return content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n}; // @flow\n\n/**\n * Clones entities in the entityMap, so each range points to its own entity instance.\n * This only clones entities as necessary â€“ if an entity is only referenced\n * in a single range, it won't be changed.\n */\n\n\nvar cloneEntities = function cloneEntities(content\n/*: ContentState*/\n) {\n  var newContent = content;\n  var blockMap = newContent.getBlockMap();\n  var encounteredEntities = []; // Marks ranges that need cloning, because their entity has been encountered previously.\n\n  var shouldCloneEntity = function shouldCloneEntity(firstChar) {\n    var key = firstChar.getEntity();\n\n    if (key) {\n      if (encounteredEntities.includes(key)) {\n        return true;\n      }\n\n      encounteredEntities.push(key);\n    }\n\n    return false;\n  }; // We're going to update blocks that contain ranges pointing at the same entity as other ranges.\n\n\n  var blocks = blockMap.map(function (block) {\n    var newChars = block.getCharacterList();\n    var altered = false; // Updates ranges for which the entity needs to be cloned.\n\n    var updateRangeWithClone = function updateRangeWithClone(start, end) {\n      var key = newChars.get(start).getEntity();\n      var entity = newContent.getEntity(key);\n      newContent = newContent.createEntity(entity.getType(), entity.getMutability(), entity.getData());\n      var newKey = newContent.getLastCreatedEntityKey(); // Update all of the chars in the range with the new entity.\n\n      newChars = newChars.map(function (char, i) {\n        if (start <= i && i <= end) {\n          return CharacterMetadata.applyEntity(char, newKey);\n        }\n\n        return char;\n      });\n      altered = true;\n    };\n\n    block.findEntityRanges(shouldCloneEntity, updateRangeWithClone);\n    return altered ? block.set(\"characterList\", newChars) : block;\n  });\n  return newContent.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n/*:: import type { BlockNode } from \"draft-js/lib/BlockNode.js.flow\" */\n\n/**\n * Filters entity ranges (where entities are applied on text) based on the result of\n * the callback function. Returning true keeps the entity range, false removes it.\n * Draft.js automatically removes entities if they are not applied on any text.\n */\n\n\nvar filterEntityRanges = function filterEntityRanges(filterFn\n/*: (\n    content: ContentState,\n    entityKey: string,\n    block: BlockNode,\n  ) => boolean*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  /*\n   * Removes entities from the character list if the entity isn't enabled.\n   * Also removes image entities placed outside of atomic blocks, which can happen\n   * on paste.\n   * A better approach would probably be to split the block where the image is and\n   * create an atomic block there, but that's another story. This is what Draft.js\n   * does when the copy-paste is all within one editor.\n   */\n\n  var blocks = blockMap.map(function (block) {\n    var altered = false;\n    var chars = block.getCharacterList().map(function (char) {\n      var entityKey = char.getEntity();\n\n      if (entityKey) {\n        var shouldRemove = !filterFn(content, entityKey, block);\n\n        if (shouldRemove) {\n          altered = true;\n          return CharacterMetadata.applyEntity(char, null);\n        }\n      }\n\n      return char;\n    });\n    return altered ? block.set(\"characterList\", chars) : block;\n  });\n  return content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n/**\n * Keeps all entity types (images, links, documents, embeds) that are enabled.\n */\n\n\nvar shouldKeepEntityType = function shouldKeepEntityType(allowlist\n/*: $ReadOnlyArray<{ type: string }>*/\n, type\n/*: string*/\n) {\n  return allowlist.some(function (e) {\n    return e.type === type;\n  });\n};\n/**\n * Removes invalid images â€“ they should only be in atomic blocks.\n * This only removes the image entity, not the camera emoji (ðŸ“·) that Draft.js inserts.\n */\n\n\nvar shouldRemoveImageEntity = function shouldRemoveImageEntity(entityType\n/*: string*/\n, blockType\n/*: string*/\n) {\n  return entityType === IMAGE && blockType !== ATOMIC;\n};\n/**\n * Filters entities based on the data they contain.\n */\n\n\nvar shouldKeepEntityByAttribute = function shouldKeepEntityByAttribute(entityTypes\n/*: $ReadOnlyArray<{\n    type: string,\n    allowlist?: {\n      [attribute: string]: string | boolean,\n    },\n    // Deprecated. Use allowlist instead. Will be removed in a future release.\n    whitelist?: {\n      [attribute: string]: string | boolean,\n    },\n  }>*/\n, entityType\n/*: string*/\n, data\n/*: {}*/\n) {\n  var config = entityTypes.find(function (t) {\n    return t.type === entityType;\n  }); // If no allowlist is defined, the filter keeps the entity.\n\n  var allowlist = config && config.allowlist ? config.allowlist : config && config.whitelist ? config.whitelist : {};\n  var isValid = Object.keys(allowlist).every(function (attr) {\n    var check = allowlist[attr];\n\n    if (typeof check === \"boolean\") {\n      var hasData = data.hasOwnProperty(attr);\n      return check ? hasData : !hasData;\n    }\n\n    return new RegExp(check).test(data[attr]);\n  });\n  return isValid;\n};\n/**\n * Filters data on an entity to only retain what is allowed.\n * This is crucial for IMAGE and LINK, where Draft.js adds a lot\n * of unneeded attributes (width, height, etc).\n */\n\n\nvar filterEntityData = function filterEntityData(entityTypes\n/*: $ReadOnlyArray<{\n    type: string,\n    attributes?: $ReadOnlyArray<string>,\n  }>*/\n, content\n/*: ContentState*/\n) {\n  var newContent = content;\n  var entities = {};\n  newContent.getBlockMap().forEach(function (block) {\n    block.findEntityRanges(function (char) {\n      var entityKey = char.getEntity();\n\n      if (entityKey) {\n        var entity = newContent.getEntity(entityKey);\n        entities[entityKey] = entity;\n      }\n    });\n  });\n  Object.keys(entities).forEach(function (key) {\n    var entity = entities[key];\n    var data = entity.getData();\n    var config = entityTypes.find(function (t) {\n      return t.type === entity.getType();\n    });\n    var allowlist = config ? config.attributes : null; // If no allowlist is defined, keep all of the data.\n\n    if (!allowlist) {\n      return data;\n    }\n\n    var newData = allowlist.reduce(function (attrs, attr) {\n      // We do not want to include undefined values if there is no data.\n      if (data.hasOwnProperty(attr)) {\n        attrs[attr] = data[attr];\n      }\n\n      return attrs;\n    }, {});\n    newContent = newContent.replaceEntityData(key, newData);\n  });\n  return newContent;\n}; // @flow\n\n/**\n * Replaces the given characters by their equivalent length of spaces, in all blocks.\n */\n\n\nvar replaceTextBySpaces = function replaceTextBySpaces(characters\n/*: $ReadOnlyArray<string>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap.map(function (block) {\n    var text = block.getText(); // Only replaces the character(s) with as many spaces as their length,\n    // so that style and entity ranges are left undisturbed.\n    // If we want to completely remove the character, we also need to filter\n    // the corresponding CharacterMetadata entities.\n\n    var newText = characters.reduce(function (txt, char) {\n      return txt.replace(new RegExp(char, \"g\"), \" \".repeat(char.length));\n    }, text);\n    return text !== newText ? block.set(\"text\", newText) : block;\n  });\n  return content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n}; // @flow\n\n/**\n * Applies the new content to the editor state, optionally moving the selection\n * to be on a valid block, inserting one if needed.\n * See https://github.com/thibaudcolas/draftjs-filters/issues/27.\n */\n\n\nvar applyContentWithSelection = function applyContentWithSelection(editorState\n/*: EditorState*/\n, content\n/*: ContentState*/\n, nextContent\n/*: ContentState*/\n) {\n  // If the content is the same before/after, return the state unaltered.\n  if (nextContent === content) {\n    return editorState;\n  } // If the block map is empty, insert a new unstyled block and put the selection on it.\n\n\n  if (nextContent.getBlockMap().size === 0) {\n    return EditorState.moveFocusToEnd(EditorState.set(editorState, {\n      currentContent: ContentState.createFromText(\"\")\n    }));\n  }\n\n  var nextState = EditorState.set(editorState, {\n    currentContent: nextContent\n  });\n  var selection = editorState.getSelection();\n  var anchorKey = selection.getAnchorKey();\n  var anchorBlock = nextContent.getBlockForKey(anchorKey); // We only support moving collapsed selections, which is the only behavior of selections after paste.\n  // And if the anchor block is valid, no need to move the selection.\n\n  var shouldKeepSelection = !selection.isCollapsed() || !!anchorBlock;\n\n  if (shouldKeepSelection) {\n    return nextState;\n  }\n\n  var nextKeys = nextContent.getBlockMap().keySeq(); // Find the first key whose successor is different in the old content (because a block was removed).\n  // Starting from the end so the selection is preserved towards the last preserved block in the filtered region.\n\n  var nextAnchorKey = nextKeys.reverse().find(function (k) {\n    return content.getKeyAfter(k) !== nextContent.getKeyAfter(k);\n  }); // If the selection was already misplaced before paste, we do not move it.\n\n  if (nextAnchorKey) {\n    var nextSelectedBlock = nextContent.getBlockForKey(nextAnchorKey);\n    var blockEndOffset = nextSelectedBlock.getText().length;\n    var nextSelection = selection.merge({\n      anchorKey: nextAnchorKey,\n      focusKey: nextAnchorKey,\n      anchorOffset: blockEndOffset,\n      focusOffset: blockEndOffset\n    });\n    return EditorState.acceptSelection(nextState, nextSelection);\n  }\n\n  return nextState;\n}; // @flow\n\n/*:: import type { EditorState as EditorStateType } from \"draft-js\"*/\n\n/*:: type FilterOptions = {\n  // List of allowed block types. unstyled and atomic are always included.\n  blocks: $ReadOnlyArray<string>,\n  // List of allowed inline styles.\n  styles: $ReadOnlyArray<string>,\n  // List of allowed entities.\n  entities: $ReadOnlyArray<{\n    // Entity type, eg. \"LINK\"\n    type: string,\n    // Allowed attributes. Other attributes will be removed. If this is omitted, all attributes are kept.\n    attributes?: $ReadOnlyArray<string>,\n    // Refine which entities are kept by matching acceptable values with regular expression patterns.\n    // It's also possible to use \"true\" to signify that a field is required to be present,\n    // and \"false\" for fields required to be absent.\n    // If this is omitted, all entities are kept.\n    allowlist?: {\n      [attribute: string]: string | boolean,\n    },\n    // Deprecated. Use allowlist instead. Will be removed in a future release.\n    whitelist?: {\n      [attribute: string]: string | boolean,\n    },\n  }>,\n  // Maximum amount of depth for lists (0 = no nesting).\n  maxNesting: number,\n  // Characters to replace with whitespace.\n  whitespacedCharacters: Array<string>,\n  // Optional: Rules used to automatically convert blocks from one type to another\n  // based on the blockâ€™s text. Also supports setting the block depth.\n  // Defaults to the filtersâ€™ built-in block prefix rules.\n  blockTextRules?: $ReadOnlyArray<{\n    // A regex as a string, to match against block text, e.g. \"^(â—¦|o |o\\t)\".\n    test: string,\n    // The type to convert the block to if the test regex matches.\n    type: string,\n    // The depth to set (e.g. for list items with different prefixes per depth).\n    depth: number,\n  }>,\n}*/\n\n\nvar BLOCK_PREFIX_RULES = [{\n  // https://regexper.com/#%5E(%C2%B7%20%7C%E2%80%A2%5Ct%7C%E2%80%A2%7C%F0%9F%93%B7%20%7C%5Ct%7C%20%5Ct)\n  test: \"^(Â· |â€¢\\t|â€¢|ðŸ“· |\\t| \\t)\",\n  type: \"unordered-list-item\",\n  depth: 0\n}, // https://regexper.com/#%5E(%E2%97%A6%7Co%20%7Co%5Ct)\n{\n  test: \"^(â—¦|o |o\\t)\",\n  type: \"unordered-list-item\",\n  depth: 1\n}, // https://regexper.com/#%5E(%C2%A7%20%7C%EF%82%A7%5Ct%7C%E2%97%BE)\n{\n  test: \"^(Â§ |ï‚§\\t|â—¾)\",\n  type: \"unordered-list-item\",\n  depth: 2\n}, {\n  // https://regexper.com/#%5E1%7B0%2C1%7D%5Cd%5C.%5B%20%5Ct%5D\n  test: \"^1{0,1}\\\\d\\\\.[ \\t]\",\n  type: \"ordered-list-item\",\n  depth: 0\n}, {\n  // Roman numerals from I to XX.\n  // https://regexper.com/#%5Ex%7B0%2C1%7D(i%7Cii%7Ciii%7Civ%7Cv%7Cvi%7Cvii%7Cviii%7Cix%7Cx)%5C.%5B%20%5Ct%5D\n  test: \"^x{0,1}(i|ii|iii|iv|v|vi|vii|viii|ix|x)\\\\.[ \\t]\",\n  type: \"ordered-list-item\",\n  depth: 2\n}, {\n  // There is a clash between this and the i., v., x. roman numerals.\n  // Those tests are executed in order though, so the roman numerals take priority.\n  // We do not want to match too many letters (say aa.), because those could be actual text.\n  // https://regexper.com/#%5E%5Ba-z%5D%5C.%5B%20%5Ct%5D\n  test: \"^[a-z]\\\\.[ \\t]\",\n  type: \"ordered-list-item\",\n  depth: 1\n}];\n/**\n * Applies filtering and preservation operations to the editor content,\n * to restrict it to supported patterns.\n * Will not alter the editor state if there are no changes to make.\n */\n\nvar filterEditorState = function filterEditorState(options\n/*: FilterOptions*/\n, editorState\n/*: EditorStateType*/\n) {\n  var blocks = options.blocks,\n      styles = options.styles,\n      entities = options.entities,\n      maxNesting = options.maxNesting,\n      whitespacedCharacters = options.whitespacedCharacters,\n      _options$blockTextRul = options.blockTextRules,\n      blockTextRules = _options$blockTextRul === void 0 ? BLOCK_PREFIX_RULES : _options$blockTextRul;\n\n  var shouldKeepEntityRange = function shouldKeepEntityRange(content, entityKey, block) {\n    var entity = content.getEntity(entityKey);\n    var entityData = entity.getData();\n    var entityType = entity.getType();\n    var blockType = block.getType();\n    return shouldKeepEntityType(entities, entityType) && shouldKeepEntityByAttribute(entities, entityType, entityData) && !shouldRemoveImageEntity(entityType, blockType);\n  }; // Order matters. Some filters may need the information filtered out by others.\n\n\n  var filters = [// 1. clean up blocks.\n  removeInvalidDepthBlocks, preserveBlockByText.bind(null, blockTextRules), limitBlockDepth.bind(null, maxNesting), // 2. reset styles and blocks.\n  filterInlineStyles.bind(null, styles), // Add block types that are always enabled in Draft.js.\n  filterBlockTypes.bind(null, blocks.concat([UNSTYLED, ATOMIC])), // 4. Process atomic blocks before processing entities.\n  preserveAtomicBlocks, resetAtomicBlocks, // 5. Remove entity ranges (and linked entities)\n  filterEntityRanges.bind(null, shouldKeepEntityRange), // 6. Remove/filter entity-related matters.\n  removeInvalidAtomicBlocks.bind(null, entities), filterEntityData.bind(null, entities), // 7. Clone entities for which it is necessary.\n  cloneEntities, // 8. Finally, do text operations.\n  replaceTextBySpaces.bind(null, whitespacedCharacters)];\n  var content = editorState.getCurrentContent();\n  var nextContent = filters.reduce(function (c, filter\n  /*: (ContentState) => ContentState*/\n  ) {\n    return filter(c);\n  }, content);\n  return applyContentWithSelection(editorState, content, nextContent);\n};\n\nexport { applyContentWithSelection, cloneEntities, filterBlockTypes, filterEditorState, filterEntityData, filterEntityRanges, filterInlineStyles, limitBlockDepth, preserveAtomicBlocks, preserveBlockByText, removeInvalidAtomicBlocks, removeInvalidDepthBlocks, replaceTextBySpaces, resetAtomicBlocks, shouldKeepEntityByAttribute, shouldKeepEntityType, shouldRemoveImageEntity };","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/draftjs-filters/dist/draftjs-filters.esm.js"],"names":["CharacterMetadata","EditorState","ContentState","ATOMIC","UNSTYLED","UNORDERED_LIST_ITEM","ORDERED_LIST_ITEM","IMAGE","preserveAtomicBlocks","content","blockMap","getBlockMap","perservedBlocks","filter","block","text","getText","entityKey","getEntityAt","shouldPreserve","includes","map","set","size","merge","resetAtomicBlocks","blocks","normalisedBlocks","getType","getInlineStyleAt","chars","getCharacterList","slice","char","newChar","getStyle","forEach","type","removeStyle","characterList","removeInvalidAtomicBlocks","allowlist","isValidAtomicBlock","isValid","getEntity","some","t","filteredBlocks","removeInvalidDepthBlocks","isValidDepthBlock","isListBlock","getDepth","preserveBlockByText","rules","newBlock","match","matchingRule","find","rule","RegExp","test","exec","_text","entity","sliceOffset","length","startOffset","shift","depth","limitBlockDepth","max","changedBlocks","filterBlockTypes","filterInlineStyles","altered","cloneEntities","newContent","encounteredEntities","shouldCloneEntity","firstChar","key","push","newChars","updateRangeWithClone","start","end","get","createEntity","getMutability","getData","newKey","getLastCreatedEntityKey","i","applyEntity","findEntityRanges","filterEntityRanges","filterFn","shouldRemove","shouldKeepEntityType","e","shouldRemoveImageEntity","entityType","blockType","shouldKeepEntityByAttribute","entityTypes","data","config","whitelist","Object","keys","every","attr","check","hasData","hasOwnProperty","filterEntityData","entities","attributes","newData","reduce","attrs","replaceEntityData","replaceTextBySpaces","characters","newText","txt","replace","repeat","applyContentWithSelection","editorState","nextContent","moveFocusToEnd","currentContent","createFromText","nextState","selection","getSelection","anchorKey","getAnchorKey","anchorBlock","getBlockForKey","shouldKeepSelection","isCollapsed","nextKeys","keySeq","nextAnchorKey","reverse","k","getKeyAfter","nextSelectedBlock","blockEndOffset","nextSelection","focusKey","anchorOffset","focusOffset","acceptSelection","BLOCK_PREFIX_RULES","filterEditorState","options","styles","maxNesting","whitespacedCharacters","_options$blockTextRul","blockTextRules","shouldKeepEntityRange","entityData","filters","bind","concat","getCurrentContent","c"],"mappings":"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","sourcesContent":["// @flow\nimport { CharacterMetadata, EditorState, ContentState } from 'draft-js';\n\n// @flow\nvar ATOMIC = \"atomic\";\nvar UNSTYLED = \"unstyled\";\nvar UNORDERED_LIST_ITEM = \"unordered-list-item\";\nvar ORDERED_LIST_ITEM = \"ordered-list-item\";\nvar IMAGE = \"IMAGE\";\n\n// @flow\n/**\n * Creates atomic blocks where they would be required for a block-level entity\n * to work correctly, when such an entity exists.\n * Note: at the moment, this is only useful for IMAGE entities that Draft.js\n * injects on arbitrary blocks on paste.\n */\n\nvar preserveAtomicBlocks = function preserveAtomicBlocks(content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var perservedBlocks = blockMap.filter(function (block) {\n    var text = block.getText();\n    var entityKey = block.getEntityAt(0);\n    var shouldPreserve = entityKey && [\"ðŸ“·\", \" \", \"ðŸ“· \"].includes(text);\n    return shouldPreserve;\n  }).map(function (block) {\n    return block.set(\"type\", ATOMIC);\n  });\n\n  if (perservedBlocks.size !== 0) {\n    return content.merge({\n      blockMap: blockMap.merge(perservedBlocks)\n    });\n  }\n\n  return content;\n};\n/**\n * Resets atomic blocks to have a single-space char and no styles.\n * This is how they are stored by Draft.js by default.\n */\n\nvar resetAtomicBlocks = function resetAtomicBlocks(content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap;\n  var normalisedBlocks = blocks.filter(function (block) {\n    return block.getType() === ATOMIC && (block.getText() !== \" \" || block.getInlineStyleAt(0).size !== 0);\n  }).map(function (block) {\n    // Retain only the first character, and remove all of its styles.\n    var chars = block.getCharacterList().slice(0, 1).map(function (char) {\n      var newChar = char;\n      char.getStyle().forEach(function (type) {\n        newChar = CharacterMetadata.removeStyle(newChar, type);\n      });\n      return newChar;\n    });\n    return block.merge({\n      text: \" \",\n      characterList: chars\n    });\n  });\n\n  if (normalisedBlocks.size !== 0) {\n    blocks = blocks.merge(normalisedBlocks);\n  }\n\n  return content.merge({\n    blockMap: blocks\n  });\n};\n/**\n * Removes atomic blocks for which the entity type isn't allowed.\n */\n\nvar removeInvalidAtomicBlocks = function removeInvalidAtomicBlocks(allowlist\n/*: $ReadOnlyArray<{ type: string }>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n\n  var isValidAtomicBlock = function isValidAtomicBlock(block) {\n    if (block.getType() !== ATOMIC) {\n      return true;\n    }\n\n    var entityKey = block.getEntityAt(0);\n    var isValid;\n\n    if (entityKey) {\n      var type = content.getEntity(entityKey).getType();\n      isValid = allowlist.some(function (t) {\n        return t.type === type;\n      });\n    } else {\n      isValid = false;\n    }\n\n    return isValid;\n  };\n\n  var filteredBlocks = blockMap.filter(isValidAtomicBlock);\n\n  if (filteredBlocks.size !== blockMap.size) {\n    return content.merge({\n      blockMap: filteredBlocks\n    });\n  }\n\n  return content;\n};\n\n// @flow\n/**\n * Removes blocks that have a non-zero depth, and aren't list items.\n * Happens with Apple Pages inserting `unstyled` items between list items.\n */\n\nvar removeInvalidDepthBlocks = function removeInvalidDepthBlocks(content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n\n  var isValidDepthBlock = function isValidDepthBlock(block) {\n    var isListBlock = [UNORDERED_LIST_ITEM, ORDERED_LIST_ITEM].includes(block.getType());\n    return isListBlock || block.getDepth() === 0;\n  };\n\n  var filteredBlocks = blockMap.filter(isValidDepthBlock);\n\n  if (filteredBlocks.size !== blockMap.size) {\n    return content.merge({\n      blockMap: filteredBlocks\n    });\n  }\n\n  return content;\n};\n/**\n * Changes block type and depth based on the block's text. â€“ some word processors\n * add a specific prefix within the text, eg. \"Â· Bulleted list\" in Word 2010.\n * Also removes the matched text.\n * This is meant first and foremost for list items where the list bullet or numeral\n * ends up in the text. Other use cases may not be well covered.\n */\n\nvar preserveBlockByText = function preserveBlockByText(rules\n/*: $ReadOnlyArray<{\n    test: string,\n    type: string,\n    depth: number,\n  }>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap.filter(function (block) {\n    return block.getType() === \"unstyled\";\n  }).map(function (block) {\n    var text = block.getText();\n    var newBlock = block;\n    var match;\n    var matchingRule = rules.find(function (rule) {\n      match = new RegExp(rule.test).exec(text);\n      return match !== null;\n    });\n\n    if (matchingRule && match && match[0]) {\n      var _text = block.getText();\n\n      var entity = block.getEntityAt(0); // Special case â€“ do not convert the block if there is an entity at the start, and the matching text is the full blockâ€™s text.\n      // This can happen in Word for equations, which are injected as images with text \"ðŸ“· \".\n\n      if (entity && match[0] === _text) {\n        return newBlock;\n      } // Unicode gotcha:\n      // At the moment, Draft.js stores one CharacterMetadata in the character list\n      // for each \"character\" in an astral symbol. \"ðŸ“·\" has a length of 2, is stored with two CharacterMetadata instances.\n      // What matters is that we remove the correct number of chars from both\n      // the text and the List<CharacterMetadata>. So â€“ we want to use the ES5 way of counting\n      // a string length.\n      // See https://mathiasbynens.be/notes/javascript-unicode.\n\n\n      var sliceOffset = match[0].length; // Maintain persistence in the list while removing chars from the start.\n      // https://github.com/facebook/draft-js/blob/788595984da7c1e00d1071ea82b063ff87140be4/src/model/transaction/removeRangeFromContentState.js#L333\n\n      var chars = block.getCharacterList();\n      var startOffset = 0;\n\n      while (startOffset < sliceOffset) {\n        chars = chars.shift();\n        startOffset++;\n      }\n\n      newBlock = newBlock.merge({\n        type: matchingRule.type,\n        depth: matchingRule.depth,\n        text: _text.slice(sliceOffset),\n        characterList: chars\n      });\n    }\n\n    return newBlock;\n  });\n  return blocks.size === 0 ? content : content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n/**\n * Resets the depth of all the content to at most max.\n */\n\nvar limitBlockDepth = function limitBlockDepth(max\n/*: number*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var changedBlocks = blockMap.filter(function (block) {\n    return block.getDepth() > max;\n  }).map(function (block) {\n    return block.set(\"depth\", max);\n  });\n  return changedBlocks.size === 0 ? content : content.merge({\n    blockMap: blockMap.merge(changedBlocks)\n  });\n};\n/**\n * Converts all block types not present in the list to unstyled.\n * Also sets depth to 0 (for potentially nested list items).\n */\n\nvar filterBlockTypes = function filterBlockTypes(allowlist\n/*: $ReadOnlyArray<string>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var changedBlocks = blockMap.filter(function (block) {\n    return !allowlist.includes(block.getType());\n  }).map(function (block) {\n    return block.merge({\n      type: UNSTYLED,\n      depth: 0\n    });\n  });\n  return changedBlocks.size === 0 ? content : content.merge({\n    blockMap: blockMap.merge(changedBlocks)\n  });\n};\n\n// @flow\n/**\n * Removes all styles not present in the list.\n */\n\nvar filterInlineStyles = function filterInlineStyles(allowlist\n/*: $ReadOnlyArray<string>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap.map(function (block) {\n    var altered = false;\n    var chars = block.getCharacterList().map(function (char) {\n      var newChar = char;\n      char.getStyle().filter(function (type) {\n        return !allowlist.includes(type);\n      }).forEach(function (type) {\n        altered = true;\n        newChar = CharacterMetadata.removeStyle(newChar, type);\n      });\n      return newChar;\n    });\n    return altered ? block.set(\"characterList\", chars) : block;\n  });\n  return content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n\n// @flow\n/**\n * Clones entities in the entityMap, so each range points to its own entity instance.\n * This only clones entities as necessary â€“ if an entity is only referenced\n * in a single range, it won't be changed.\n */\n\nvar cloneEntities = function cloneEntities(content\n/*: ContentState*/\n) {\n  var newContent = content;\n  var blockMap = newContent.getBlockMap();\n  var encounteredEntities = []; // Marks ranges that need cloning, because their entity has been encountered previously.\n\n  var shouldCloneEntity = function shouldCloneEntity(firstChar) {\n    var key = firstChar.getEntity();\n\n    if (key) {\n      if (encounteredEntities.includes(key)) {\n        return true;\n      }\n\n      encounteredEntities.push(key);\n    }\n\n    return false;\n  }; // We're going to update blocks that contain ranges pointing at the same entity as other ranges.\n\n\n  var blocks = blockMap.map(function (block) {\n    var newChars = block.getCharacterList();\n    var altered = false; // Updates ranges for which the entity needs to be cloned.\n\n    var updateRangeWithClone = function updateRangeWithClone(start, end) {\n      var key = newChars.get(start).getEntity();\n      var entity = newContent.getEntity(key);\n      newContent = newContent.createEntity(entity.getType(), entity.getMutability(), entity.getData());\n      var newKey = newContent.getLastCreatedEntityKey(); // Update all of the chars in the range with the new entity.\n\n      newChars = newChars.map(function (char, i) {\n        if (start <= i && i <= end) {\n          return CharacterMetadata.applyEntity(char, newKey);\n        }\n\n        return char;\n      });\n      altered = true;\n    };\n\n    block.findEntityRanges(shouldCloneEntity, updateRangeWithClone);\n    return altered ? block.set(\"characterList\", newChars) : block;\n  });\n  return newContent.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n/*:: import type { BlockNode } from \"draft-js/lib/BlockNode.js.flow\" */\n\n/**\n * Filters entity ranges (where entities are applied on text) based on the result of\n * the callback function. Returning true keeps the entity range, false removes it.\n * Draft.js automatically removes entities if they are not applied on any text.\n */\n\nvar filterEntityRanges = function filterEntityRanges(filterFn\n/*: (\n    content: ContentState,\n    entityKey: string,\n    block: BlockNode,\n  ) => boolean*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  /*\n   * Removes entities from the character list if the entity isn't enabled.\n   * Also removes image entities placed outside of atomic blocks, which can happen\n   * on paste.\n   * A better approach would probably be to split the block where the image is and\n   * create an atomic block there, but that's another story. This is what Draft.js\n   * does when the copy-paste is all within one editor.\n   */\n\n  var blocks = blockMap.map(function (block) {\n    var altered = false;\n    var chars = block.getCharacterList().map(function (char) {\n      var entityKey = char.getEntity();\n\n      if (entityKey) {\n        var shouldRemove = !filterFn(content, entityKey, block);\n\n        if (shouldRemove) {\n          altered = true;\n          return CharacterMetadata.applyEntity(char, null);\n        }\n      }\n\n      return char;\n    });\n    return altered ? block.set(\"characterList\", chars) : block;\n  });\n  return content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n/**\n * Keeps all entity types (images, links, documents, embeds) that are enabled.\n */\n\nvar shouldKeepEntityType = function shouldKeepEntityType(allowlist\n/*: $ReadOnlyArray<{ type: string }>*/\n, type\n/*: string*/\n) {\n  return allowlist.some(function (e) {\n    return e.type === type;\n  });\n};\n/**\n * Removes invalid images â€“ they should only be in atomic blocks.\n * This only removes the image entity, not the camera emoji (ðŸ“·) that Draft.js inserts.\n */\n\nvar shouldRemoveImageEntity = function shouldRemoveImageEntity(entityType\n/*: string*/\n, blockType\n/*: string*/\n) {\n  return entityType === IMAGE && blockType !== ATOMIC;\n};\n/**\n * Filters entities based on the data they contain.\n */\n\nvar shouldKeepEntityByAttribute = function shouldKeepEntityByAttribute(entityTypes\n/*: $ReadOnlyArray<{\n    type: string,\n    allowlist?: {\n      [attribute: string]: string | boolean,\n    },\n    // Deprecated. Use allowlist instead. Will be removed in a future release.\n    whitelist?: {\n      [attribute: string]: string | boolean,\n    },\n  }>*/\n, entityType\n/*: string*/\n, data\n/*: {}*/\n) {\n  var config = entityTypes.find(function (t) {\n    return t.type === entityType;\n  }); // If no allowlist is defined, the filter keeps the entity.\n\n  var allowlist = config && config.allowlist ? config.allowlist : config && config.whitelist ? config.whitelist : {};\n  var isValid = Object.keys(allowlist).every(function (attr) {\n    var check = allowlist[attr];\n\n    if (typeof check === \"boolean\") {\n      var hasData = data.hasOwnProperty(attr);\n      return check ? hasData : !hasData;\n    }\n\n    return new RegExp(check).test(data[attr]);\n  });\n  return isValid;\n};\n/**\n * Filters data on an entity to only retain what is allowed.\n * This is crucial for IMAGE and LINK, where Draft.js adds a lot\n * of unneeded attributes (width, height, etc).\n */\n\nvar filterEntityData = function filterEntityData(entityTypes\n/*: $ReadOnlyArray<{\n    type: string,\n    attributes?: $ReadOnlyArray<string>,\n  }>*/\n, content\n/*: ContentState*/\n) {\n  var newContent = content;\n  var entities = {};\n  newContent.getBlockMap().forEach(function (block) {\n    block.findEntityRanges(function (char) {\n      var entityKey = char.getEntity();\n\n      if (entityKey) {\n        var entity = newContent.getEntity(entityKey);\n        entities[entityKey] = entity;\n      }\n    });\n  });\n  Object.keys(entities).forEach(function (key) {\n    var entity = entities[key];\n    var data = entity.getData();\n    var config = entityTypes.find(function (t) {\n      return t.type === entity.getType();\n    });\n    var allowlist = config ? config.attributes : null; // If no allowlist is defined, keep all of the data.\n\n    if (!allowlist) {\n      return data;\n    }\n\n    var newData = allowlist.reduce(function (attrs, attr) {\n      // We do not want to include undefined values if there is no data.\n      if (data.hasOwnProperty(attr)) {\n        attrs[attr] = data[attr];\n      }\n\n      return attrs;\n    }, {});\n    newContent = newContent.replaceEntityData(key, newData);\n  });\n  return newContent;\n};\n\n// @flow\n/**\n * Replaces the given characters by their equivalent length of spaces, in all blocks.\n */\n\nvar replaceTextBySpaces = function replaceTextBySpaces(characters\n/*: $ReadOnlyArray<string>*/\n, content\n/*: ContentState*/\n) {\n  var blockMap = content.getBlockMap();\n  var blocks = blockMap.map(function (block) {\n    var text = block.getText(); // Only replaces the character(s) with as many spaces as their length,\n    // so that style and entity ranges are left undisturbed.\n    // If we want to completely remove the character, we also need to filter\n    // the corresponding CharacterMetadata entities.\n\n    var newText = characters.reduce(function (txt, char) {\n      return txt.replace(new RegExp(char, \"g\"), \" \".repeat(char.length));\n    }, text);\n    return text !== newText ? block.set(\"text\", newText) : block;\n  });\n  return content.merge({\n    blockMap: blockMap.merge(blocks)\n  });\n};\n\n// @flow\n/**\n * Applies the new content to the editor state, optionally moving the selection\n * to be on a valid block, inserting one if needed.\n * See https://github.com/thibaudcolas/draftjs-filters/issues/27.\n */\n\nvar applyContentWithSelection = function applyContentWithSelection(editorState\n/*: EditorState*/\n, content\n/*: ContentState*/\n, nextContent\n/*: ContentState*/\n) {\n  // If the content is the same before/after, return the state unaltered.\n  if (nextContent === content) {\n    return editorState;\n  } // If the block map is empty, insert a new unstyled block and put the selection on it.\n\n\n  if (nextContent.getBlockMap().size === 0) {\n    return EditorState.moveFocusToEnd(EditorState.set(editorState, {\n      currentContent: ContentState.createFromText(\"\")\n    }));\n  }\n\n  var nextState = EditorState.set(editorState, {\n    currentContent: nextContent\n  });\n  var selection = editorState.getSelection();\n  var anchorKey = selection.getAnchorKey();\n  var anchorBlock = nextContent.getBlockForKey(anchorKey); // We only support moving collapsed selections, which is the only behavior of selections after paste.\n  // And if the anchor block is valid, no need to move the selection.\n\n  var shouldKeepSelection = !selection.isCollapsed() || !!anchorBlock;\n\n  if (shouldKeepSelection) {\n    return nextState;\n  }\n\n  var nextKeys = nextContent.getBlockMap().keySeq(); // Find the first key whose successor is different in the old content (because a block was removed).\n  // Starting from the end so the selection is preserved towards the last preserved block in the filtered region.\n\n  var nextAnchorKey = nextKeys.reverse().find(function (k) {\n    return content.getKeyAfter(k) !== nextContent.getKeyAfter(k);\n  }); // If the selection was already misplaced before paste, we do not move it.\n\n  if (nextAnchorKey) {\n    var nextSelectedBlock = nextContent.getBlockForKey(nextAnchorKey);\n    var blockEndOffset = nextSelectedBlock.getText().length;\n    var nextSelection = selection.merge({\n      anchorKey: nextAnchorKey,\n      focusKey: nextAnchorKey,\n      anchorOffset: blockEndOffset,\n      focusOffset: blockEndOffset\n    });\n    return EditorState.acceptSelection(nextState, nextSelection);\n  }\n\n  return nextState;\n};\n\n// @flow\n/*:: import type { EditorState as EditorStateType } from \"draft-js\"*/\n\n/*:: type FilterOptions = {\n  // List of allowed block types. unstyled and atomic are always included.\n  blocks: $ReadOnlyArray<string>,\n  // List of allowed inline styles.\n  styles: $ReadOnlyArray<string>,\n  // List of allowed entities.\n  entities: $ReadOnlyArray<{\n    // Entity type, eg. \"LINK\"\n    type: string,\n    // Allowed attributes. Other attributes will be removed. If this is omitted, all attributes are kept.\n    attributes?: $ReadOnlyArray<string>,\n    // Refine which entities are kept by matching acceptable values with regular expression patterns.\n    // It's also possible to use \"true\" to signify that a field is required to be present,\n    // and \"false\" for fields required to be absent.\n    // If this is omitted, all entities are kept.\n    allowlist?: {\n      [attribute: string]: string | boolean,\n    },\n    // Deprecated. Use allowlist instead. Will be removed in a future release.\n    whitelist?: {\n      [attribute: string]: string | boolean,\n    },\n  }>,\n  // Maximum amount of depth for lists (0 = no nesting).\n  maxNesting: number,\n  // Characters to replace with whitespace.\n  whitespacedCharacters: Array<string>,\n  // Optional: Rules used to automatically convert blocks from one type to another\n  // based on the blockâ€™s text. Also supports setting the block depth.\n  // Defaults to the filtersâ€™ built-in block prefix rules.\n  blockTextRules?: $ReadOnlyArray<{\n    // A regex as a string, to match against block text, e.g. \"^(â—¦|o |o\\t)\".\n    test: string,\n    // The type to convert the block to if the test regex matches.\n    type: string,\n    // The depth to set (e.g. for list items with different prefixes per depth).\n    depth: number,\n  }>,\n}*/\n\nvar BLOCK_PREFIX_RULES = [{\n  // https://regexper.com/#%5E(%C2%B7%20%7C%E2%80%A2%5Ct%7C%E2%80%A2%7C%F0%9F%93%B7%20%7C%5Ct%7C%20%5Ct)\n  test: \"^(Â· |â€¢\\t|â€¢|ðŸ“· |\\t| \\t)\",\n  type: \"unordered-list-item\",\n  depth: 0\n}, // https://regexper.com/#%5E(%E2%97%A6%7Co%20%7Co%5Ct)\n{\n  test: \"^(â—¦|o |o\\t)\",\n  type: \"unordered-list-item\",\n  depth: 1\n}, // https://regexper.com/#%5E(%C2%A7%20%7C%EF%82%A7%5Ct%7C%E2%97%BE)\n{\n  test: \"^(Â§ |ï‚§\\t|â—¾)\",\n  type: \"unordered-list-item\",\n  depth: 2\n}, {\n  // https://regexper.com/#%5E1%7B0%2C1%7D%5Cd%5C.%5B%20%5Ct%5D\n  test: \"^1{0,1}\\\\d\\\\.[ \\t]\",\n  type: \"ordered-list-item\",\n  depth: 0\n}, {\n  // Roman numerals from I to XX.\n  // https://regexper.com/#%5Ex%7B0%2C1%7D(i%7Cii%7Ciii%7Civ%7Cv%7Cvi%7Cvii%7Cviii%7Cix%7Cx)%5C.%5B%20%5Ct%5D\n  test: \"^x{0,1}(i|ii|iii|iv|v|vi|vii|viii|ix|x)\\\\.[ \\t]\",\n  type: \"ordered-list-item\",\n  depth: 2\n}, {\n  // There is a clash between this and the i., v., x. roman numerals.\n  // Those tests are executed in order though, so the roman numerals take priority.\n  // We do not want to match too many letters (say aa.), because those could be actual text.\n  // https://regexper.com/#%5E%5Ba-z%5D%5C.%5B%20%5Ct%5D\n  test: \"^[a-z]\\\\.[ \\t]\",\n  type: \"ordered-list-item\",\n  depth: 1\n}];\n/**\n * Applies filtering and preservation operations to the editor content,\n * to restrict it to supported patterns.\n * Will not alter the editor state if there are no changes to make.\n */\n\nvar filterEditorState = function filterEditorState(options\n/*: FilterOptions*/\n, editorState\n/*: EditorStateType*/\n) {\n  var blocks = options.blocks,\n      styles = options.styles,\n      entities = options.entities,\n      maxNesting = options.maxNesting,\n      whitespacedCharacters = options.whitespacedCharacters,\n      _options$blockTextRul = options.blockTextRules,\n      blockTextRules = _options$blockTextRul === void 0 ? BLOCK_PREFIX_RULES : _options$blockTextRul;\n\n  var shouldKeepEntityRange = function shouldKeepEntityRange(content, entityKey, block) {\n    var entity = content.getEntity(entityKey);\n    var entityData = entity.getData();\n    var entityType = entity.getType();\n    var blockType = block.getType();\n    return shouldKeepEntityType(entities, entityType) && shouldKeepEntityByAttribute(entities, entityType, entityData) && !shouldRemoveImageEntity(entityType, blockType);\n  }; // Order matters. Some filters may need the information filtered out by others.\n\n\n  var filters = [// 1. clean up blocks.\n  removeInvalidDepthBlocks, preserveBlockByText.bind(null, blockTextRules), limitBlockDepth.bind(null, maxNesting), // 2. reset styles and blocks.\n  filterInlineStyles.bind(null, styles), // Add block types that are always enabled in Draft.js.\n  filterBlockTypes.bind(null, blocks.concat([UNSTYLED, ATOMIC])), // 4. Process atomic blocks before processing entities.\n  preserveAtomicBlocks, resetAtomicBlocks, // 5. Remove entity ranges (and linked entities)\n  filterEntityRanges.bind(null, shouldKeepEntityRange), // 6. Remove/filter entity-related matters.\n  removeInvalidAtomicBlocks.bind(null, entities), filterEntityData.bind(null, entities), // 7. Clone entities for which it is necessary.\n  cloneEntities, // 8. Finally, do text operations.\n  replaceTextBySpaces.bind(null, whitespacedCharacters)];\n  var content = editorState.getCurrentContent();\n  var nextContent = filters.reduce(function (c, filter\n  /*: (ContentState) => ContentState*/\n  ) {\n    return filter(c);\n  }, content);\n  return applyContentWithSelection(editorState, content, nextContent);\n};\n\nexport { applyContentWithSelection, cloneEntities, filterBlockTypes, filterEditorState, filterEntityData, filterEntityRanges, filterInlineStyles, limitBlockDepth, preserveAtomicBlocks, preserveBlockByText, removeInvalidAtomicBlocks, removeInvalidDepthBlocks, replaceTextBySpaces, resetAtomicBlocks, shouldKeepEntityByAttribute, shouldKeepEntityType, shouldRemoveImageEntity };\n"]},"metadata":{},"sourceType":"module"}