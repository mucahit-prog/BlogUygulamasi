{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/imageuploadediting\n */\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport Notification from '@ckeditor/ckeditor5-ui/src/notification/notification';\nimport UpcastWriter from '@ckeditor/ckeditor5-engine/src/view/upcastwriter';\nimport ImageUploadCommand from '../../src/imageupload/imageuploadcommand';\nimport { isImageType, isLocalImage, fetchLocalImage } from '../../src/imageupload/utils';\n/**\n * The editing part of the image upload feature. It registers the `'imageUpload'` command.\n *\n * @extends module:core/plugin~Plugin\n */\n\nexport default class ImageUploadEditing extends Plugin {\n  /**\n   * @inheritDoc\n   */\n  static get requires() {\n    return [FileRepository, Notification];\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  init() {\n    const editor = this.editor;\n    const doc = editor.model.document;\n    const schema = editor.model.schema;\n    const conversion = editor.conversion;\n    const fileRepository = editor.plugins.get(FileRepository); // Setup schema to allow uploadId and uploadStatus for images.\n\n    schema.extend('image', {\n      allowAttributes: ['uploadId', 'uploadStatus']\n    }); // Register imageUpload command.\n\n    editor.commands.add('imageUpload', new ImageUploadCommand(editor)); // Register upcast converter for uploadId.\n\n    conversion.for('upcast').attributeToAttribute({\n      view: {\n        name: 'img',\n        key: 'uploadId'\n      },\n      model: 'uploadId'\n    }); // Handle pasted images.\n    // For every image file, a new file loader is created and a placeholder image is\n    // inserted into the content. Then, those images are uploaded once they appear in the model\n    // (see Document#change listener below).\n\n    this.listenTo(editor.editing.view.document, 'clipboardInput', (evt, data) => {\n      // Skip if non empty HTML data is included.\n      // https://github.com/ckeditor/ckeditor5-upload/issues/68\n      if (isHtmlIncluded(data.dataTransfer)) {\n        return;\n      }\n\n      const images = Array.from(data.dataTransfer.files).filter(file => {\n        // See https://github.com/ckeditor/ckeditor5-image/pull/254.\n        if (!file) {\n          return false;\n        }\n\n        return isImageType(file);\n      });\n      const ranges = data.targetRanges.map(viewRange => editor.editing.mapper.toModelRange(viewRange));\n      editor.model.change(writer => {\n        // Set selection to paste target.\n        writer.setSelection(ranges);\n\n        if (images.length) {\n          evt.stop(); // Upload images after the selection has changed in order to ensure the command's state is refreshed.\n\n          editor.model.enqueueChange('default', () => {\n            editor.execute('imageUpload', {\n              file: images\n            });\n          });\n        }\n      });\n    }); // Handle HTML pasted with images with base64 or blob sources.\n    // For every image file, a new file loader is created and a placeholder image is\n    // inserted into the content. Then, those images are uploaded once they appear in the model\n    // (see Document#change listener below).\n\n    if (editor.plugins.has('Clipboard')) {\n      this.listenTo(editor.plugins.get('Clipboard'), 'inputTransformation', (evt, data) => {\n        const fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).filter(value => isLocalImage(value.item) && !value.item.getAttribute('uploadProcessed')).map(value => {\n          return {\n            promise: fetchLocalImage(value.item),\n            imageElement: value.item\n          };\n        });\n\n        if (!fetchableImages.length) {\n          return;\n        }\n\n        const writer = new UpcastWriter();\n\n        for (const fetchableImage of fetchableImages) {\n          // Set attribute marking that the image was processed already.\n          writer.setAttribute('uploadProcessed', true, fetchableImage.imageElement);\n          const loader = fileRepository.createLoader(fetchableImage.promise);\n\n          if (loader) {\n            writer.setAttribute('src', '', fetchableImage.imageElement);\n            writer.setAttribute('uploadId', loader.id, fetchableImage.imageElement);\n          }\n        }\n      });\n    } // Prevents from the browser redirecting to the dropped image.\n\n\n    editor.editing.view.document.on('dragover', (evt, data) => {\n      data.preventDefault();\n    }); // Upload placeholder images that appeared in the model.\n\n    doc.on('change', () => {\n      const changes = doc.differ.getChanges({\n        includeChangesInGraveyard: true\n      });\n\n      for (const entry of changes) {\n        if (entry.type == 'insert' && entry.name == 'image') {\n          const item = entry.position.nodeAfter;\n          const isInGraveyard = entry.position.root.rootName == '$graveyard'; // Check if the image element still has upload id.\n\n          const uploadId = item.getAttribute('uploadId');\n\n          if (!uploadId) {\n            continue;\n          } // Check if the image is loaded on this client.\n\n\n          const loader = fileRepository.loaders.get(uploadId);\n\n          if (!loader) {\n            continue;\n          }\n\n          if (isInGraveyard) {\n            // If the image was inserted to the graveyard - abort the loading process.\n            loader.abort();\n          } else if (loader.status == 'idle') {\n            // If the image was inserted into content and has not been loaded yet, start loading it.\n            this._readAndUpload(loader, item);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Read and upload an image.\n   *\n   * The image is read from the disk and as a base64 encoded string it is set temporarily to\n   * `image[src]`. When the image is successfully uploaded the temporary data is replaced with the target\n   * image's URL (the URL to the uploaded image on the server).\n   *\n   * @protected\n   * @param {module:upload/filerepository~FileLoader} loader\n   * @param {module:engine/model/element~Element} imageElement\n   * @returns {Promise}\n   */\n\n\n  _readAndUpload(loader, imageElement) {\n    const editor = this.editor;\n    const model = editor.model;\n    const t = editor.locale.t;\n    const fileRepository = editor.plugins.get(FileRepository);\n    const notification = editor.plugins.get(Notification);\n    model.enqueueChange('transparent', writer => {\n      writer.setAttribute('uploadStatus', 'reading', imageElement);\n    });\n    return loader.read().then(data => {\n      const viewFigure = editor.editing.mapper.toViewElement(imageElement);\n      const viewImg = viewFigure.getChild(0);\n      const promise = loader.upload();\n      editor.editing.view.change(writer => {\n        writer.setAttribute('src', data, viewImg);\n      });\n      model.enqueueChange('transparent', writer => {\n        writer.setAttribute('uploadStatus', 'uploading', imageElement);\n      });\n      return promise;\n    }).then(data => {\n      model.enqueueChange('transparent', writer => {\n        writer.setAttributes({\n          uploadStatus: 'complete',\n          src: data.default\n        }, imageElement);\n\n        this._parseAndSetSrcsetAttributeOnImage(data, imageElement, writer);\n      });\n      clean();\n    }).catch(error => {\n      // If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n      // it might be generic error and it would be real pain to find what is going on.\n      if (loader.status !== 'error' && loader.status !== 'aborted') {\n        throw error;\n      } // Might be 'aborted'.\n\n\n      if (loader.status == 'error' && error) {\n        notification.showWarning(error, {\n          title: t('Upload failed'),\n          namespace: 'upload'\n        });\n      }\n\n      clean(); // Permanently remove image from insertion batch.\n\n      model.enqueueChange('transparent', writer => {\n        writer.remove(imageElement);\n      });\n    });\n\n    function clean() {\n      model.enqueueChange('transparent', writer => {\n        writer.removeAttribute('uploadId', imageElement);\n        writer.removeAttribute('uploadStatus', imageElement);\n      });\n      fileRepository.destroyLoader(loader);\n    }\n  }\n  /**\n   * Creates `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.\n   *\n   * @protected\n   * @param {Object} data Data object from which `srcset` will be created.\n   * @param {module:engine/model/element~Element} image The image element on which `srcset` attribute will be set.\n   * @param {module:engine/model/writer~Writer} writer\n   */\n\n\n  _parseAndSetSrcsetAttributeOnImage(data, image, writer) {\n    // Srcset attribute for responsive images support.\n    let maxWidth = 0;\n    const srcsetAttribute = Object.keys(data) // Filter out keys that are not integers.\n    .filter(key => {\n      const width = parseInt(key, 10);\n\n      if (!isNaN(width)) {\n        maxWidth = Math.max(maxWidth, width);\n        return true;\n      }\n    }) // Convert each key to srcset entry.\n    .map(key => `${data[key]} ${key}w`) // Join all entries.\n    .join(', ');\n\n    if (srcsetAttribute != '') {\n      writer.setAttribute('srcset', {\n        data: srcsetAttribute,\n        width: maxWidth\n      }, image);\n    }\n  }\n\n} // Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\n\nexport function isHtmlIncluded(dataTransfer) {\n  return Array.from(dataTransfer.types).includes('text/html') && dataTransfer.getData('text/html') !== '';\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadediting.js"],"names":["Plugin","FileRepository","Notification","UpcastWriter","ImageUploadCommand","isImageType","isLocalImage","fetchLocalImage","ImageUploadEditing","requires","init","editor","doc","model","document","schema","conversion","fileRepository","plugins","get","extend","allowAttributes","commands","add","for","attributeToAttribute","view","name","key","listenTo","editing","evt","data","isHtmlIncluded","dataTransfer","images","Array","from","files","filter","file","ranges","targetRanges","map","viewRange","mapper","toModelRange","change","writer","setSelection","length","stop","enqueueChange","execute","has","fetchableImages","createRangeIn","content","value","item","getAttribute","promise","imageElement","fetchableImage","setAttribute","loader","createLoader","id","on","preventDefault","changes","differ","getChanges","includeChangesInGraveyard","entry","type","position","nodeAfter","isInGraveyard","root","rootName","uploadId","loaders","abort","status","_readAndUpload","t","locale","notification","read","then","viewFigure","toViewElement","viewImg","getChild","upload","setAttributes","uploadStatus","src","default","_parseAndSetSrcsetAttributeOnImage","clean","catch","error","showWarning","title","namespace","remove","removeAttribute","destroyLoader","image","maxWidth","srcsetAttribute","Object","keys","width","parseInt","isNaN","Math","max","join","types","includes","getData"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module image/imageupload/imageuploadediting\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\nimport FileRepository from '@ckeditor/ckeditor5-upload/src/filerepository';\nimport Notification from '@ckeditor/ckeditor5-ui/src/notification/notification';\nimport UpcastWriter from '@ckeditor/ckeditor5-engine/src/view/upcastwriter';\n\nimport ImageUploadCommand from '../../src/imageupload/imageuploadcommand';\nimport { isImageType, isLocalImage, fetchLocalImage } from '../../src/imageupload/utils';\n\n/**\n * The editing part of the image upload feature. It registers the `'imageUpload'` command.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class ImageUploadEditing extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get requires() {\n\t\treturn [ FileRepository, Notification ];\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tinit() {\n\t\tconst editor = this.editor;\n\t\tconst doc = editor.model.document;\n\t\tconst schema = editor.model.schema;\n\t\tconst conversion = editor.conversion;\n\t\tconst fileRepository = editor.plugins.get( FileRepository );\n\n\t\t// Setup schema to allow uploadId and uploadStatus for images.\n\t\tschema.extend( 'image', {\n\t\t\tallowAttributes: [ 'uploadId', 'uploadStatus' ]\n\t\t} );\n\n\t\t// Register imageUpload command.\n\t\teditor.commands.add( 'imageUpload', new ImageUploadCommand( editor ) );\n\n\t\t// Register upcast converter for uploadId.\n\t\tconversion.for( 'upcast' )\n\t\t\t.attributeToAttribute( {\n\t\t\t\tview: {\n\t\t\t\t\tname: 'img',\n\t\t\t\t\tkey: 'uploadId'\n\t\t\t\t},\n\t\t\t\tmodel: 'uploadId'\n\t\t\t} );\n\n\t\t// Handle pasted images.\n\t\t// For every image file, a new file loader is created and a placeholder image is\n\t\t// inserted into the content. Then, those images are uploaded once they appear in the model\n\t\t// (see Document#change listener below).\n\t\tthis.listenTo( editor.editing.view.document, 'clipboardInput', ( evt, data ) => {\n\t\t\t// Skip if non empty HTML data is included.\n\t\t\t// https://github.com/ckeditor/ckeditor5-upload/issues/68\n\t\t\tif ( isHtmlIncluded( data.dataTransfer ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst images = Array.from( data.dataTransfer.files ).filter( file => {\n\t\t\t\t// See https://github.com/ckeditor/ckeditor5-image/pull/254.\n\t\t\t\tif ( !file ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn isImageType( file );\n\t\t\t} );\n\n\t\t\tconst ranges = data.targetRanges.map( viewRange => editor.editing.mapper.toModelRange( viewRange ) );\n\n\t\t\teditor.model.change( writer => {\n\t\t\t\t// Set selection to paste target.\n\t\t\t\twriter.setSelection( ranges );\n\n\t\t\t\tif ( images.length ) {\n\t\t\t\t\tevt.stop();\n\n\t\t\t\t\t// Upload images after the selection has changed in order to ensure the command's state is refreshed.\n\t\t\t\t\teditor.model.enqueueChange( 'default', () => {\n\t\t\t\t\t\teditor.execute( 'imageUpload', { file: images } );\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\n\t\t// Handle HTML pasted with images with base64 or blob sources.\n\t\t// For every image file, a new file loader is created and a placeholder image is\n\t\t// inserted into the content. Then, those images are uploaded once they appear in the model\n\t\t// (see Document#change listener below).\n\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n\t\t\tthis.listenTo( editor.plugins.get( 'Clipboard' ), 'inputTransformation', ( evt, data ) => {\n\t\t\t\tconst fetchableImages = Array.from( editor.editing.view.createRangeIn( data.content ) )\n\t\t\t\t\t.filter( value => isLocalImage( value.item ) && !value.item.getAttribute( 'uploadProcessed' ) )\n\t\t\t\t\t.map( value => { return { promise: fetchLocalImage( value.item ), imageElement: value.item }; } );\n\n\t\t\t\tif ( !fetchableImages.length ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst writer = new UpcastWriter();\n\n\t\t\t\tfor ( const fetchableImage of fetchableImages ) {\n\t\t\t\t\t// Set attribute marking that the image was processed already.\n\t\t\t\t\twriter.setAttribute( 'uploadProcessed', true, fetchableImage.imageElement );\n\n\t\t\t\t\tconst loader = fileRepository.createLoader( fetchableImage.promise );\n\n\t\t\t\t\tif ( loader ) {\n\t\t\t\t\t\twriter.setAttribute( 'src', '', fetchableImage.imageElement );\n\t\t\t\t\t\twriter.setAttribute( 'uploadId', loader.id, fetchableImage.imageElement );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Prevents from the browser redirecting to the dropped image.\n\t\teditor.editing.view.document.on( 'dragover', ( evt, data ) => {\n\t\t\tdata.preventDefault();\n\t\t} );\n\n\t\t// Upload placeholder images that appeared in the model.\n\t\tdoc.on( 'change', () => {\n\t\t\tconst changes = doc.differ.getChanges( { includeChangesInGraveyard: true } );\n\n\t\t\tfor ( const entry of changes ) {\n\t\t\t\tif ( entry.type == 'insert' && entry.name == 'image' ) {\n\t\t\t\t\tconst item = entry.position.nodeAfter;\n\t\t\t\t\tconst isInGraveyard = entry.position.root.rootName == '$graveyard';\n\n\t\t\t\t\t// Check if the image element still has upload id.\n\t\t\t\t\tconst uploadId = item.getAttribute( 'uploadId' );\n\n\t\t\t\t\tif ( !uploadId ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if the image is loaded on this client.\n\t\t\t\t\tconst loader = fileRepository.loaders.get( uploadId );\n\n\t\t\t\t\tif ( !loader ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isInGraveyard ) {\n\t\t\t\t\t\t// If the image was inserted to the graveyard - abort the loading process.\n\t\t\t\t\t\tloader.abort();\n\t\t\t\t\t} else if ( loader.status == 'idle' ) {\n\t\t\t\t\t\t// If the image was inserted into content and has not been loaded yet, start loading it.\n\t\t\t\t\t\tthis._readAndUpload( loader, item );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Read and upload an image.\n\t *\n\t * The image is read from the disk and as a base64 encoded string it is set temporarily to\n\t * `image[src]`. When the image is successfully uploaded the temporary data is replaced with the target\n\t * image's URL (the URL to the uploaded image on the server).\n\t *\n\t * @protected\n\t * @param {module:upload/filerepository~FileLoader} loader\n\t * @param {module:engine/model/element~Element} imageElement\n\t * @returns {Promise}\n\t */\n\t_readAndUpload( loader, imageElement ) {\n\t\tconst editor = this.editor;\n\t\tconst model = editor.model;\n\t\tconst t = editor.locale.t;\n\t\tconst fileRepository = editor.plugins.get( FileRepository );\n\t\tconst notification = editor.plugins.get( Notification );\n\n\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setAttribute( 'uploadStatus', 'reading', imageElement );\n\t\t} );\n\n\t\treturn loader.read()\n\t\t\t.then( data => {\n\t\t\t\tconst viewFigure = editor.editing.mapper.toViewElement( imageElement );\n\t\t\t\tconst viewImg = viewFigure.getChild( 0 );\n\t\t\t\tconst promise = loader.upload();\n\n\t\t\t\teditor.editing.view.change( writer => {\n\t\t\t\t\twriter.setAttribute( 'src', data, viewImg );\n\t\t\t\t} );\n\n\t\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\t\twriter.setAttribute( 'uploadStatus', 'uploading', imageElement );\n\t\t\t\t} );\n\n\t\t\t\treturn promise;\n\t\t\t} )\n\t\t\t.then( data => {\n\t\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\t\twriter.setAttributes( { uploadStatus: 'complete', src: data.default }, imageElement );\n\t\t\t\t\tthis._parseAndSetSrcsetAttributeOnImage( data, imageElement, writer );\n\t\t\t\t} );\n\n\t\t\t\tclean();\n\t\t\t} )\n\t\t\t.catch( error => {\n\t\t\t\t// If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,\n\t\t\t\t// it might be generic error and it would be real pain to find what is going on.\n\t\t\t\tif ( loader.status !== 'error' && loader.status !== 'aborted' ) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\t// Might be 'aborted'.\n\t\t\t\tif ( loader.status == 'error' && error ) {\n\t\t\t\t\tnotification.showWarning( error, {\n\t\t\t\t\t\ttitle: t( 'Upload failed' ),\n\t\t\t\t\t\tnamespace: 'upload'\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tclean();\n\n\t\t\t\t// Permanently remove image from insertion batch.\n\t\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\t\twriter.remove( imageElement );\n\t\t\t\t} );\n\t\t\t} );\n\n\t\tfunction clean() {\n\t\t\tmodel.enqueueChange( 'transparent', writer => {\n\t\t\t\twriter.removeAttribute( 'uploadId', imageElement );\n\t\t\t\twriter.removeAttribute( 'uploadStatus', imageElement );\n\t\t\t} );\n\n\t\t\tfileRepository.destroyLoader( loader );\n\t\t}\n\t}\n\n\t/**\n\t * Creates `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.\n\t *\n\t * @protected\n\t * @param {Object} data Data object from which `srcset` will be created.\n\t * @param {module:engine/model/element~Element} image The image element on which `srcset` attribute will be set.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\t_parseAndSetSrcsetAttributeOnImage( data, image, writer ) {\n\t\t// Srcset attribute for responsive images support.\n\t\tlet maxWidth = 0;\n\n\t\tconst srcsetAttribute = Object.keys( data )\n\t\t// Filter out keys that are not integers.\n\t\t\t.filter( key => {\n\t\t\t\tconst width = parseInt( key, 10 );\n\n\t\t\t\tif ( !isNaN( width ) ) {\n\t\t\t\t\tmaxWidth = Math.max( maxWidth, width );\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// Convert each key to srcset entry.\n\t\t\t.map( key => `${ data[ key ] } ${ key }w` )\n\n\t\t\t// Join all entries.\n\t\t\t.join( ', ' );\n\n\t\tif ( srcsetAttribute != '' ) {\n\t\t\twriter.setAttribute( 'srcset', {\n\t\t\t\tdata: srcsetAttribute,\n\t\t\t\twidth: maxWidth\n\t\t\t}, image );\n\t\t}\n\t}\n}\n\n// Returns `true` if non-empty `text/html` is included in the data transfer.\n//\n// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer\n// @returns {Boolean}\nexport function isHtmlIncluded( dataTransfer ) {\n\treturn Array.from( dataTransfer.types ).includes( 'text/html' ) && dataTransfer.getData( 'text/html' ) !== '';\n}\n"]},"metadata":{},"sourceType":"module"}