{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\n/* globals console */\nimport CKEditorError, { attachLinkToDocumentation } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\n\nexport default class PluginCollection {\n  /**\n   * Creates an instance of the PluginCollection class.\n   * Allows loading and initializing plugins and their dependencies.\n   *\n   * @param {module:core/editor/editor~Editor} editor\n   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n   * when {@link module:core/plugincollection~PluginCollection#init} is used with plugin names (strings, instead of constructors).\n   * Usually, the editor will pass its built-in plugins to the collection so they can later be\n   * used in `config.plugins` or `config.removePlugins` by names.\n   */\n  constructor(editor, availablePlugins = []) {\n    /**\n     * @protected\n     * @member {module:core/editor/editor~Editor} module:core/plugin~PluginCollection#_editor\n     */\n    this._editor = editor;\n    /**\n     * Map of plugin constructors which can be retrieved by their names.\n     *\n     * @protected\n     * @member {Map.<String|Function,Function>} module:core/plugin~PluginCollection#_availablePlugins\n     */\n\n    this._availablePlugins = new Map();\n    /**\n     * @protected\n     * @member {Map} module:core/plugin~PluginCollection#_plugins\n     */\n\n    this._plugins = new Map();\n\n    for (const PluginConstructor of availablePlugins) {\n      this._availablePlugins.set(PluginConstructor, PluginConstructor);\n\n      if (PluginConstructor.pluginName) {\n        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);\n      }\n    }\n  }\n  /**\n   * Iterable interface.\n   *\n   * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n   *\n   * @returns {Iterable.<Array>}\n   */\n\n\n  *[Symbol.iterator]() {\n    for (const entry of this._plugins) {\n      if (typeof entry[0] == 'function') {\n        yield entry;\n      }\n    }\n  }\n  /**\n   * Gets the plugin instance by its constructor or name.\n   *\n   *\t\t// Check if 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n   *\t\t\t// Get clipboard plugin instance\n   *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n   *\n   *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n   *\t\t\t\t// Do something on clipboard input.\n   *\t\t\t} );\n   *\t\t}\n   *\n   * **Note**: This method will throw error if plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n   * to check if plugin is available.\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {module:core/plugin~PluginInterface}\n   */\n\n\n  get(key) {\n    const plugin = this._plugins.get(key);\n\n    if (!plugin) {\n      /**\n       * The plugin is not loaded and could not be obtained.\n       *\n       * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n       * the plugin collection.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n       * to check if plugin was loaded.\n       *\n       * @error plugincollection-plugin-not-loaded\n       * @param {String} plugin The name of the plugin which is not loaded.\n       */\n      const errorMsg = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';\n      let pluginName = key;\n\n      if (typeof key == 'function') {\n        pluginName = key.pluginName || key.name;\n      }\n\n      throw new CKEditorError(errorMsg, this._editor, {\n        plugin: pluginName\n      });\n    }\n\n    return plugin;\n  }\n  /**\n   * Checks if plugin is loaded.\n   *\n   *\t\t// Check if 'Clipboard' plugin was loaded.\n   *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n   *\t\t\t// Now use clipboard plugin instance:\n   *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n   *\n   *\t\t\t// ...\n   *\t\t}\n   *\n   * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n   * @returns {Boolean}\n   */\n\n\n  has(key) {\n    return this._plugins.has(key);\n  }\n  /**\n   * Initializes a set of plugins and adds them to the collection.\n   *\n   * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n   * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if\n   * `availablePlugins` were passed to the {@link #constructor}.\n   * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors\n   * that should not be loaded (despite being specified in the `plugins` array).\n   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n   * and available in the collection.\n   */\n\n\n  init(plugins, removePlugins = []) {\n    const that = this;\n    const editor = this._editor;\n    const loading = new Set();\n    const loaded = [];\n    const pluginConstructors = mapToAvailableConstructors(plugins);\n    const removePluginConstructors = mapToAvailableConstructors(removePlugins);\n    const missingPlugins = getMissingPluginNames(plugins);\n\n    if (missingPlugins) {\n      /**\n       * Some plugins are not available and could not be loaded.\n       *\n       * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n       * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n       * property.\n       *\n       * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n       * that you try to enable a plugin which was not included in that build. This may be due to a typo\n       * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n       * read more about {@glink builds/guides/development/custom-builds custom builds}.\n       *\n       * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n       * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n       * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n       * provide each plugin through reference (as a constructor function). Check out the examples in\n       * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n       *\n       * @error plugincollection-plugin-not-found\n       * @param {Array.<String>} plugins The name of the plugins which could not be loaded.\n       */\n      const errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.'; // Log the error so it's more visible on the console. Hopefully, for better DX.\n\n      console.error(attachLinkToDocumentation(errorMsg), {\n        plugins: missingPlugins\n      });\n      return Promise.reject(new CKEditorError(errorMsg, this._editor, {\n        plugins: missingPlugins\n      }));\n    }\n\n    return Promise.all(pluginConstructors.map(loadPlugin)).then(() => initPlugins(loaded, 'init')).then(() => initPlugins(loaded, 'afterInit')).then(() => loaded);\n\n    function loadPlugin(PluginConstructor) {\n      if (removePluginConstructors.includes(PluginConstructor)) {\n        return;\n      } // The plugin is already loaded or being loaded - do nothing.\n\n\n      if (that._plugins.has(PluginConstructor) || loading.has(PluginConstructor)) {\n        return;\n      }\n\n      return instantiatePlugin(PluginConstructor).catch(err => {\n        /**\n         * It was not possible to load the plugin.\n         *\n         * This is a generic error logged to the console when a JavaSript error is thrown during the initialization\n         * of one of the plugins.\n         *\n         * If you correctly handled the promise returned by the editor's `create()` method (like shown below)\n         * you will find the original error logged to the console, too:\n         *\n         *\t\tClassicEditor.create( document.getElementById( 'editor' ) )\n         *\t\t\t.then( editor => {\n         *\t\t\t\t// ...\n         * \t\t\t} )\n         *\t\t\t.catch( error => {\n         *\t\t\t\tconsole.error( error );\n         *\t\t\t} );\n         *\n         * @error plugincollection-load\n         * @param {String} plugin The name of the plugin that could not be loaded.\n         */\n        console.error(attachLinkToDocumentation('plugincollection-load: It was not possible to load the plugin.'), {\n          plugin: PluginConstructor\n        });\n        throw err;\n      });\n    }\n\n    function initPlugins(loadedPlugins, method) {\n      return loadedPlugins.reduce((promise, plugin) => {\n        if (!plugin[method]) {\n          return promise;\n        }\n\n        return promise.then(plugin[method].bind(plugin));\n      }, Promise.resolve());\n    }\n\n    function instantiatePlugin(PluginConstructor) {\n      return new Promise(resolve => {\n        loading.add(PluginConstructor);\n\n        if (PluginConstructor.requires) {\n          PluginConstructor.requires.forEach(RequiredPluginConstructorOrName => {\n            const RequiredPluginConstructor = getPluginConstructor(RequiredPluginConstructorOrName);\n\n            if (removePlugins.includes(RequiredPluginConstructor)) {\n              /**\n               * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n               *\n               * @error plugincollection-required\n               * @param {Function} plugin The required plugin.\n               * @param {Function} requiredBy The parent plugin.\n               */\n              throw new CKEditorError('plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' + 'the `removePlugins` option.', editor, {\n                plugin: RequiredPluginConstructor,\n                requiredBy: PluginConstructor\n              });\n            }\n\n            loadPlugin(RequiredPluginConstructor);\n          });\n        }\n\n        const plugin = new PluginConstructor(editor);\n\n        that._add(PluginConstructor, plugin);\n\n        loaded.push(plugin);\n        resolve();\n      });\n    }\n\n    function getPluginConstructor(PluginConstructorOrName) {\n      if (typeof PluginConstructorOrName == 'function') {\n        return PluginConstructorOrName;\n      }\n\n      return that._availablePlugins.get(PluginConstructorOrName);\n    }\n\n    function getMissingPluginNames(plugins) {\n      const missingPlugins = [];\n\n      for (const pluginNameOrConstructor of plugins) {\n        if (!getPluginConstructor(pluginNameOrConstructor)) {\n          missingPlugins.push(pluginNameOrConstructor);\n        }\n      }\n\n      return missingPlugins.length ? missingPlugins : null;\n    }\n\n    function mapToAvailableConstructors(plugins) {\n      return plugins.map(pluginNameOrConstructor => getPluginConstructor(pluginNameOrConstructor)).filter(PluginConstructor => !!PluginConstructor);\n    }\n  }\n  /**\n   * Destroys all loaded plugins.\n   *\n   * @returns {Promise}\n   */\n\n\n  destroy() {\n    const promises = Array.from(this).map(([, pluginInstance]) => pluginInstance).filter(pluginInstance => typeof pluginInstance.destroy == 'function').map(pluginInstance => pluginInstance.destroy());\n    return Promise.all(promises);\n  }\n  /**\n   * Adds the plugin to the collection. Exposed mainly for testing purposes.\n   *\n   * @protected\n   * @param {Function} PluginConstructor The plugin constructor.\n   * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n   */\n\n\n  _add(PluginConstructor, plugin) {\n    this._plugins.set(PluginConstructor, plugin);\n\n    const pluginName = PluginConstructor.pluginName;\n\n    if (!pluginName) {\n      return;\n    }\n\n    if (this._plugins.has(pluginName)) {\n      /**\n       * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n       * This will lead to runtime conflicts between these plugins.\n       *\n       * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n       * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n       * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n       *\n       * Check your import paths and the list of plugins passed to\n       * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n       * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n       *\n       * The second option is that your `node_modules/` directory contains duplicated versions of the same\n       * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n       * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n       * of packages, their dependencies may need to be installed in more than one version which may lead to this\n       * warning.\n       *\n       * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n       * dependencies of this plugin are being duplicated.\n       * They are already built into that editor build and now get added for the second time as dependencies\n       * of the plugin you are installing.\n       *\n       * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n       *\n       * @error plugincollection-plugin-name-conflict\n       * @param {String} pluginName The duplicated plugin name.\n       * @param {Function} plugin1 The first plugin constructor.\n       * @param {Function} plugin2 The second plugin constructor.\n       */\n      throw new CKEditorError('plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.', null, {\n        pluginName,\n        plugin1: this._plugins.get(pluginName).constructor,\n        plugin2: PluginConstructor\n      });\n    }\n\n    this._plugins.set(pluginName, plugin);\n  }\n\n}\nmix(PluginCollection, EmitterMixin);","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js"],"names":["CKEditorError","attachLinkToDocumentation","EmitterMixin","mix","PluginCollection","constructor","editor","availablePlugins","_editor","_availablePlugins","Map","_plugins","PluginConstructor","set","pluginName","Symbol","iterator","entry","get","key","plugin","errorMsg","name","has","init","plugins","removePlugins","that","loading","Set","loaded","pluginConstructors","mapToAvailableConstructors","removePluginConstructors","missingPlugins","getMissingPluginNames","console","error","Promise","reject","all","map","loadPlugin","then","initPlugins","includes","instantiatePlugin","catch","err","loadedPlugins","method","reduce","promise","bind","resolve","add","requires","forEach","RequiredPluginConstructorOrName","RequiredPluginConstructor","getPluginConstructor","requiredBy","_add","push","PluginConstructorOrName","pluginNameOrConstructor","length","filter","destroy","promises","Array","from","pluginInstance","plugin1","plugin2"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module core/plugincollection\n */\n\n/* globals console */\n\nimport CKEditorError, { attachLinkToDocumentation } from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n */\nexport default class PluginCollection {\n\t/**\n\t * Creates an instance of the PluginCollection class.\n\t * Allows loading and initializing plugins and their dependencies.\n\t *\n\t * @param {module:core/editor/editor~Editor} editor\n\t * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use\n\t * when {@link module:core/plugincollection~PluginCollection#init} is used with plugin names (strings, instead of constructors).\n\t * Usually, the editor will pass its built-in plugins to the collection so they can later be\n\t * used in `config.plugins` or `config.removePlugins` by names.\n\t */\n\tconstructor( editor, availablePlugins = [] ) {\n\t\t/**\n\t\t * @protected\n\t\t * @member {module:core/editor/editor~Editor} module:core/plugin~PluginCollection#_editor\n\t\t */\n\t\tthis._editor = editor;\n\n\t\t/**\n\t\t * Map of plugin constructors which can be retrieved by their names.\n\t\t *\n\t\t * @protected\n\t\t * @member {Map.<String|Function,Function>} module:core/plugin~PluginCollection#_availablePlugins\n\t\t */\n\t\tthis._availablePlugins = new Map();\n\n\t\t/**\n\t\t * @protected\n\t\t * @member {Map} module:core/plugin~PluginCollection#_plugins\n\t\t */\n\t\tthis._plugins = new Map();\n\n\t\tfor ( const PluginConstructor of availablePlugins ) {\n\t\t\tthis._availablePlugins.set( PluginConstructor, PluginConstructor );\n\n\t\t\tif ( PluginConstructor.pluginName ) {\n\t\t\t\tthis._availablePlugins.set( PluginConstructor.pluginName, PluginConstructor );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Returns `[ PluginConstructor, pluginInstance ]` pairs.\n\t *\n\t * @returns {Iterable.<Array>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tfor ( const entry of this._plugins ) {\n\t\t\tif ( typeof entry[ 0 ] == 'function' ) {\n\t\t\t\tyield entry;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the plugin instance by its constructor or name.\n\t *\n\t *\t\t// Check if 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n\t *\t\t\t// Get clipboard plugin instance\n\t *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n\t *\n\t *\t\t\tthis.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {\n\t *\t\t\t\t// Do something on clipboard input.\n\t *\t\t\t} );\n\t *\t\t}\n\t *\n\t * **Note**: This method will throw error if plugin is not loaded. Use `{@link #has editor.plugins.has()}`\n\t * to check if plugin is available.\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {module:core/plugin~PluginInterface}\n\t */\n\tget( key ) {\n\t\tconst plugin = this._plugins.get( key );\n\n\t\tif ( !plugin ) {\n\t\t\t/**\n\t\t\t * The plugin is not loaded and could not be obtained.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from\n\t\t\t * the plugin collection.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`\n\t\t\t * to check if plugin was loaded.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-loaded\n\t\t\t * @param {String} plugin The name of the plugin which is not loaded.\n\t\t\t */\n\t\t\tconst errorMsg = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';\n\n\t\t\tlet pluginName = key;\n\n\t\t\tif ( typeof key == 'function' ) {\n\t\t\t\tpluginName = key.pluginName || key.name;\n\t\t\t}\n\n\t\t\tthrow new CKEditorError( errorMsg, this._editor, { plugin: pluginName } );\n\t\t}\n\n\t\treturn plugin;\n\t}\n\n\t/**\n\t * Checks if plugin is loaded.\n\t *\n\t *\t\t// Check if 'Clipboard' plugin was loaded.\n\t *\t\tif ( editor.plugins.has( 'Clipboard' ) ) {\n\t *\t\t\t// Now use clipboard plugin instance:\n\t *\t\t\tconst clipboard = editor.plugins.get( 'Clipboard' );\n\t *\n\t *\t\t\t// ...\n\t *\t\t}\n\t *\n\t * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.\n\t * @returns {Boolean}\n\t */\n\thas( key ) {\n\t\treturn this._plugins.has( key );\n\t}\n\n\t/**\n\t * Initializes a set of plugins and adds them to the collection.\n\t *\n\t * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}\n\t * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if\n\t * `availablePlugins` were passed to the {@link #constructor}.\n\t * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors\n\t * that should not be loaded (despite being specified in the `plugins` array).\n\t * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded\n\t * and available in the collection.\n\t */\n\tinit( plugins, removePlugins = [] ) {\n\t\tconst that = this;\n\t\tconst editor = this._editor;\n\t\tconst loading = new Set();\n\t\tconst loaded = [];\n\n\t\tconst pluginConstructors = mapToAvailableConstructors( plugins );\n\t\tconst removePluginConstructors = mapToAvailableConstructors( removePlugins );\n\t\tconst missingPlugins = getMissingPluginNames( plugins );\n\n\t\tif ( missingPlugins ) {\n\t\t\t/**\n\t\t\t * Some plugins are not available and could not be loaded.\n\t\t\t *\n\t\t\t * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.\n\t\t\t * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}\n\t\t\t * property.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means\n\t\t\t * that you try to enable a plugin which was not included in that build. This may be due to a typo\n\t\t\t * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,\n\t\t\t * read more about {@glink builds/guides/development/custom-builds custom builds}.\n\t\t\t *\n\t\t\t * **If you see this warning when using one of the editor creators directly** (not a build), then it means\n\t\t\t * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a \"plugin loader\".\n\t\t\t * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to\n\t\t\t * provide each plugin through reference (as a constructor function). Check out the examples in\n\t\t\t * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source \"Building from source\"}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-not-found\n\t\t\t * @param {Array.<String>} plugins The name of the plugins which could not be loaded.\n\t\t\t */\n\t\t\tconst errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.';\n\n\t\t\t// Log the error so it's more visible on the console. Hopefully, for better DX.\n\t\t\tconsole.error( attachLinkToDocumentation( errorMsg ), { plugins: missingPlugins } );\n\n\t\t\treturn Promise.reject( new CKEditorError( errorMsg, this._editor, { plugins: missingPlugins } ) );\n\t\t}\n\n\t\treturn Promise.all( pluginConstructors.map( loadPlugin ) )\n\t\t\t.then( () => initPlugins( loaded, 'init' ) )\n\t\t\t.then( () => initPlugins( loaded, 'afterInit' ) )\n\t\t\t.then( () => loaded );\n\n\t\tfunction loadPlugin( PluginConstructor ) {\n\t\t\tif ( removePluginConstructors.includes( PluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The plugin is already loaded or being loaded - do nothing.\n\t\t\tif ( that._plugins.has( PluginConstructor ) || loading.has( PluginConstructor ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn instantiatePlugin( PluginConstructor )\n\t\t\t\t.catch( err => {\n\t\t\t\t\t/**\n\t\t\t\t\t * It was not possible to load the plugin.\n\t\t\t\t\t *\n\t\t\t\t\t * This is a generic error logged to the console when a JavaSript error is thrown during the initialization\n\t\t\t\t\t * of one of the plugins.\n\t\t\t\t\t *\n\t\t\t\t\t * If you correctly handled the promise returned by the editor's `create()` method (like shown below)\n\t\t\t\t\t * you will find the original error logged to the console, too:\n\t\t\t\t\t *\n\t\t\t\t\t *\t\tClassicEditor.create( document.getElementById( 'editor' ) )\n\t\t\t\t\t *\t\t\t.then( editor => {\n\t\t\t\t\t *\t\t\t\t// ...\n\t\t\t\t\t * \t\t\t} )\n\t\t\t\t\t *\t\t\t.catch( error => {\n\t\t\t\t\t *\t\t\t\tconsole.error( error );\n\t\t\t\t\t *\t\t\t} );\n\t\t\t\t\t *\n\t\t\t\t\t * @error plugincollection-load\n\t\t\t\t\t * @param {String} plugin The name of the plugin that could not be loaded.\n\t\t\t\t\t */\n\t\t\t\t\tconsole.error( attachLinkToDocumentation(\n\t\t\t\t\t\t'plugincollection-load: It was not possible to load the plugin.'\n\t\t\t\t\t), { plugin: PluginConstructor } );\n\n\t\t\t\t\tthrow err;\n\t\t\t\t} );\n\t\t}\n\n\t\tfunction initPlugins( loadedPlugins, method ) {\n\t\t\treturn loadedPlugins.reduce( ( promise, plugin ) => {\n\t\t\t\tif ( !plugin[ method ] ) {\n\t\t\t\t\treturn promise;\n\t\t\t\t}\n\n\t\t\t\treturn promise.then( plugin[ method ].bind( plugin ) );\n\t\t\t}, Promise.resolve() );\n\t\t}\n\n\t\tfunction instantiatePlugin( PluginConstructor ) {\n\t\t\treturn new Promise( resolve => {\n\t\t\t\tloading.add( PluginConstructor );\n\n\t\t\t\tif ( PluginConstructor.requires ) {\n\t\t\t\t\tPluginConstructor.requires.forEach( RequiredPluginConstructorOrName => {\n\t\t\t\t\t\tconst RequiredPluginConstructor = getPluginConstructor( RequiredPluginConstructorOrName );\n\n\t\t\t\t\t\tif ( removePlugins.includes( RequiredPluginConstructor ) ) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.\n\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t * @error plugincollection-required\n\t\t\t\t\t\t\t * @param {Function} plugin The required plugin.\n\t\t\t\t\t\t\t * @param {Function} requiredBy The parent plugin.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t\t\t\t'plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' +\n\t\t\t\t\t\t\t\t'the `removePlugins` option.',\n\t\t\t\t\t\t\t\teditor,\n\t\t\t\t\t\t\t\t{ plugin: RequiredPluginConstructor, requiredBy: PluginConstructor }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadPlugin( RequiredPluginConstructor );\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\tconst plugin = new PluginConstructor( editor );\n\t\t\t\tthat._add( PluginConstructor, plugin );\n\t\t\t\tloaded.push( plugin );\n\n\t\t\t\tresolve();\n\t\t\t} );\n\t\t}\n\n\t\tfunction getPluginConstructor( PluginConstructorOrName ) {\n\t\t\tif ( typeof PluginConstructorOrName == 'function' ) {\n\t\t\t\treturn PluginConstructorOrName;\n\t\t\t}\n\n\t\t\treturn that._availablePlugins.get( PluginConstructorOrName );\n\t\t}\n\n\t\tfunction getMissingPluginNames( plugins ) {\n\t\t\tconst missingPlugins = [];\n\n\t\t\tfor ( const pluginNameOrConstructor of plugins ) {\n\t\t\t\tif ( !getPluginConstructor( pluginNameOrConstructor ) ) {\n\t\t\t\t\tmissingPlugins.push( pluginNameOrConstructor );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn missingPlugins.length ? missingPlugins : null;\n\t\t}\n\n\t\tfunction mapToAvailableConstructors( plugins ) {\n\t\t\treturn plugins\n\t\t\t\t.map( pluginNameOrConstructor => getPluginConstructor( pluginNameOrConstructor ) )\n\t\t\t\t.filter( PluginConstructor => !!PluginConstructor );\n\t\t}\n\t}\n\n\t/**\n\t * Destroys all loaded plugins.\n\t *\n\t * @returns {Promise}\n\t */\n\tdestroy() {\n\t\tconst promises = Array.from( this )\n\t\t\t.map( ( [ , pluginInstance ] ) => pluginInstance )\n\t\t\t.filter( pluginInstance => typeof pluginInstance.destroy == 'function' )\n\t\t\t.map( pluginInstance => pluginInstance.destroy() );\n\n\t\treturn Promise.all( promises );\n\t}\n\n\t/**\n\t * Adds the plugin to the collection. Exposed mainly for testing purposes.\n\t *\n\t * @protected\n\t * @param {Function} PluginConstructor The plugin constructor.\n\t * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.\n\t */\n\t_add( PluginConstructor, plugin ) {\n\t\tthis._plugins.set( PluginConstructor, plugin );\n\n\t\tconst pluginName = PluginConstructor.pluginName;\n\n\t\tif ( !pluginName ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this._plugins.has( pluginName ) ) {\n\t\t\t/**\n\t\t\t * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.\n\t\t\t * This will lead to runtime conflicts between these plugins.\n\t\t\t *\n\t\t\t * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.\n\t\t\t * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),\n\t\t\t * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.\n\t\t\t *\n\t\t\t * Check your import paths and the list of plugins passed to\n\t\t\t * {@link module:core/editor/editor~Editor.create `Editor.create()`}\n\t\t\t * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.\n\t\t\t *\n\t\t\t * The second option is that your `node_modules/` directory contains duplicated versions of the same\n\t\t\t * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so\n\t\t\t * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions\n\t\t\t * of packages, their dependencies may need to be installed in more than one version which may lead to this\n\t\t\t * warning.\n\t\t\t *\n\t\t\t * Technically speaking, this error occurs because after adding a plugin to an existing editor build\n\t\t\t * dependencies of this plugin are being duplicated.\n\t\t\t * They are already built into that editor build and now get added for the second time as dependencies\n\t\t\t * of the plugin you are installing.\n\t\t\t *\n\t\t\t * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.\n\t\t\t *\n\t\t\t * @error plugincollection-plugin-name-conflict\n\t\t\t * @param {String} pluginName The duplicated plugin name.\n\t\t\t * @param {Function} plugin1 The first plugin constructor.\n\t\t\t * @param {Function} plugin2 The second plugin constructor.\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.',\n\t\t\t\tnull,\n\t\t\t\t{ pluginName, plugin1: this._plugins.get( pluginName ).constructor, plugin2: PluginConstructor }\n\t\t\t);\n\t\t}\n\n\t\tthis._plugins.set( pluginName, plugin );\n\t}\n}\n\nmix( PluginCollection, EmitterMixin );\n"]},"metadata":{},"sourceType":"module"}