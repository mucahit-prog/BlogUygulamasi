{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options Positioning options object.\n * @returns {module:utils/dom/position~Position}\n */\n\nexport function getOptimalPosition({\n  element,\n  target,\n  positions,\n  limiter,\n  fitInViewport\n}) {\n  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-utils/issues/157\n  if (isFunction(target)) {\n    target = target();\n  } // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n  // https://github.com/ckeditor/ckeditor5-ui/issues/260\n\n\n  if (isFunction(limiter)) {\n    limiter = limiter();\n  }\n\n  const positionedElementAncestor = getPositionedAncestor(element.parentElement);\n  const elementRect = new Rect(element);\n  const targetRect = new Rect(target);\n  let bestPosition;\n  let name; // If there are no limits, just grab the very first position and be done with that drama.\n\n  if (!limiter && !fitInViewport) {\n    [name, bestPosition] = getPosition(positions[0], targetRect, elementRect);\n  } else {\n    const limiterRect = limiter && new Rect(limiter).getVisible();\n    const viewportRect = fitInViewport && new Rect(global.window);\n    [name, bestPosition] = getBestPosition(positions, targetRect, elementRect, limiterRect, viewportRect) || // If there's no best position found, i.e. when all intersections have no area because\n    // rects have no width or height, then just use the first available position.\n    getPosition(positions[0], targetRect, elementRect);\n  }\n\n  let {\n    left,\n    top\n  } = getAbsoluteRectCoordinates(bestPosition);\n\n  if (positionedElementAncestor) {\n    const ancestorPosition = getAbsoluteRectCoordinates(new Rect(positionedElementAncestor));\n    const ancestorBorderWidths = getBorderWidths(positionedElementAncestor); // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n    // If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n    // consideration. `Rect` is always relative to the viewport while `position: absolute` works\n    // with respect to that positioned ancestor.\n\n    left -= ancestorPosition.left;\n    top -= ancestorPosition.top; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n    // If there's some positioned ancestor of the panel, not only its position must be taken into\n    // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n    // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n    // must compensate that scrolling.\n\n    left += positionedElementAncestor.scrollLeft;\n    top += positionedElementAncestor.scrollTop; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n    // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n    // while `position: absolute` positioning does not consider it.\n    // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n    // not upper-left corner of its border.\n\n    left -= ancestorBorderWidths.left;\n    top -= ancestorBorderWidths.top;\n  }\n\n  return {\n    left,\n    top,\n    name\n  };\n} // For given position function, returns a corresponding `Rect` instance.\n//\n// @private\n// @param {Function} position A function returning {@link module:utils/dom/position~Position}.\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.\n// @returns {Array} An array containing position name and its Rect.\n\nfunction getPosition(position, targetRect, elementRect) {\n  const {\n    left,\n    top,\n    name\n  } = position(targetRect, elementRect);\n  return [name, elementRect.clone().moveTo(left, top)];\n} // For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position} to be checked, in the order of preference.\n// @param {utils/dom/rect~Rect} targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} viewportRect A rect of the viewport.\n// @returns {Array} An array containing the name of the position and it's rect.\n\n\nfunction getBestPosition(positions, targetRect, elementRect, limiterRect, viewportRect) {\n  let maxLimiterIntersectArea = 0;\n  let maxViewportIntersectArea = 0;\n  let bestPositionRect;\n  let bestPositionName; // This is when element is fully visible.\n\n  const elementRectArea = elementRect.getArea();\n  positions.some(position => {\n    const [positionName, positionRect] = getPosition(position, targetRect, elementRect);\n    let limiterIntersectArea;\n    let viewportIntersectArea;\n\n    if (limiterRect) {\n      if (viewportRect) {\n        // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n        const limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);\n\n        if (limiterViewportIntersectRect) {\n          // If the limiter is within the viewport, then check the intersection between that part of the\n          // limiter and actual position.\n          limiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea(positionRect);\n        } else {\n          limiterIntersectArea = 0;\n        }\n      } else {\n        limiterIntersectArea = limiterRect.getIntersectionArea(positionRect);\n      }\n    }\n\n    if (viewportRect) {\n      viewportIntersectArea = viewportRect.getIntersectionArea(positionRect);\n    } // The only criterion: intersection with the viewport.\n\n\n    if (viewportRect && !limiterRect) {\n      if (viewportIntersectArea > maxViewportIntersectArea) {\n        setBestPosition();\n      }\n    } // The only criterion: intersection with the limiter.\n    else if (!viewportRect && limiterRect) {\n        if (limiterIntersectArea > maxLimiterIntersectArea) {\n          setBestPosition();\n        }\n      } // Two criteria: intersection with the viewport and the limiter visible in the viewport.\n      else {\n          if (viewportIntersectArea > maxViewportIntersectArea && limiterIntersectArea >= maxLimiterIntersectArea) {\n            setBestPosition();\n          } else if (viewportIntersectArea >= maxViewportIntersectArea && limiterIntersectArea > maxLimiterIntersectArea) {\n            setBestPosition();\n          }\n        }\n\n    function setBestPosition() {\n      maxViewportIntersectArea = viewportIntersectArea;\n      maxLimiterIntersectArea = limiterIntersectArea;\n      bestPositionRect = positionRect;\n      bestPositionName = positionName;\n    } // If a such position is found that element is fully container by the limiter then, obviously,\n    // there will be no better one, so finishing.\n\n\n    return limiterIntersectArea === elementRectArea;\n  });\n  return bestPositionRect ? [bestPositionName, bestPositionRect] : null;\n} // DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\n\n\nfunction getAbsoluteRectCoordinates({\n  left,\n  top\n}) {\n  const {\n    scrollX,\n    scrollY\n  } = global.window;\n  return {\n    left: left + scrollX,\n    top: top + scrollY\n  };\n}\n/**\n * The `getOptimalPosition` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #target\n */\n\n/**\n * An array of functions which return {@link module:utils/dom/position~Position} relative\n * to the `target`, in the order of preference.\n *\n * @member {Array.<Function>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * An object describing a position in `position: absolute` coordinate\n * system, along with position name.\n *\n * @typedef {Object} module:utils/dom/position~Position\n *\n * @property {Number} top Top position offset.\n * @property {Number} left Left position offset.\n * @property {String} name Name of the position.\n */","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-image/node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js"],"names":["global","Rect","getPositionedAncestor","getBorderWidths","isFunction","getOptimalPosition","element","target","positions","limiter","fitInViewport","positionedElementAncestor","parentElement","elementRect","targetRect","bestPosition","name","getPosition","limiterRect","getVisible","viewportRect","window","getBestPosition","left","top","getAbsoluteRectCoordinates","ancestorPosition","ancestorBorderWidths","scrollLeft","scrollTop","position","clone","moveTo","maxLimiterIntersectArea","maxViewportIntersectArea","bestPositionRect","bestPositionName","elementRectArea","getArea","some","positionName","positionRect","limiterIntersectArea","viewportIntersectArea","limiterViewportIntersectRect","getIntersection","getIntersectionArea","setBestPosition","scrollX","scrollY"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,OAAOA,MAAP,MAAmB,UAAnB;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,OAAOC,qBAAP,MAAkC,yBAAlC;AACA,OAAOC,eAAP,MAA4B,mBAA5B;AACA,SAASC,UAAT,QAA2B,WAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,kBAAT,CAA6B;AAAEC,EAAAA,OAAF;AAAWC,EAAAA,MAAX;AAAmBC,EAAAA,SAAnB;AAA8BC,EAAAA,OAA9B;AAAuCC,EAAAA;AAAvC,CAA7B,EAAsF;AAC5F;AACA;AACA,MAAKN,UAAU,CAAEG,MAAF,CAAf,EAA4B;AAC3BA,IAAAA,MAAM,GAAGA,MAAM,EAAf;AACA,GAL2F,CAO5F;AACA;;;AACA,MAAKH,UAAU,CAAEK,OAAF,CAAf,EAA6B;AAC5BA,IAAAA,OAAO,GAAGA,OAAO,EAAjB;AACA;;AAED,QAAME,yBAAyB,GAAGT,qBAAqB,CAAEI,OAAO,CAACM,aAAV,CAAvD;AACA,QAAMC,WAAW,GAAG,IAAIZ,IAAJ,CAAUK,OAAV,CAApB;AACA,QAAMQ,UAAU,GAAG,IAAIb,IAAJ,CAAUM,MAAV,CAAnB;AAEA,MAAIQ,YAAJ;AACA,MAAIC,IAAJ,CAlB4F,CAoB5F;;AACA,MAAK,CAACP,OAAD,IAAY,CAACC,aAAlB,EAAkC;AACjC,KAAEM,IAAF,EAAQD,YAAR,IAAyBE,WAAW,CAAET,SAAS,CAAE,CAAF,CAAX,EAAkBM,UAAlB,EAA8BD,WAA9B,CAApC;AACA,GAFD,MAEO;AACN,UAAMK,WAAW,GAAGT,OAAO,IAAI,IAAIR,IAAJ,CAAUQ,OAAV,EAAoBU,UAApB,EAA/B;AACA,UAAMC,YAAY,GAAGV,aAAa,IAAI,IAAIT,IAAJ,CAAUD,MAAM,CAACqB,MAAjB,CAAtC;AAEA,KAAEL,IAAF,EAAQD,YAAR,IACCO,eAAe,CAAEd,SAAF,EAAaM,UAAb,EAAyBD,WAAzB,EAAsCK,WAAtC,EAAmDE,YAAnD,CAAf,IACA;AACA;AACAH,IAAAA,WAAW,CAAET,SAAS,CAAE,CAAF,CAAX,EAAkBM,UAAlB,EAA8BD,WAA9B,CAJZ;AAKA;;AAED,MAAI;AAAEU,IAAAA,IAAF;AAAQC,IAAAA;AAAR,MAAgBC,0BAA0B,CAAEV,YAAF,CAA9C;;AAEA,MAAKJ,yBAAL,EAAiC;AAChC,UAAMe,gBAAgB,GAAGD,0BAA0B,CAAE,IAAIxB,IAAJ,CAAUU,yBAAV,CAAF,CAAnD;AACA,UAAMgB,oBAAoB,GAAGxB,eAAe,CAAEQ,yBAAF,CAA5C,CAFgC,CAIhC;AACA;AACA;AACA;;AACAY,IAAAA,IAAI,IAAIG,gBAAgB,CAACH,IAAzB;AACAC,IAAAA,GAAG,IAAIE,gBAAgB,CAACF,GAAxB,CATgC,CAWhC;AACA;AACA;AACA;AACA;;AACAD,IAAAA,IAAI,IAAIZ,yBAAyB,CAACiB,UAAlC;AACAJ,IAAAA,GAAG,IAAIb,yBAAyB,CAACkB,SAAjC,CAjBgC,CAmBhC;AACA;AACA;AACA;AACA;;AACAN,IAAAA,IAAI,IAAII,oBAAoB,CAACJ,IAA7B;AACAC,IAAAA,GAAG,IAAIG,oBAAoB,CAACH,GAA5B;AACA;;AAED,SAAO;AAAED,IAAAA,IAAF;AAAQC,IAAAA,GAAR;AAAaR,IAAAA;AAAb,GAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAsBa,QAAtB,EAAgChB,UAAhC,EAA4CD,WAA5C,EAA0D;AACzD,QAAM;AAAEU,IAAAA,IAAF;AAAQC,IAAAA,GAAR;AAAaR,IAAAA;AAAb,MAAsBc,QAAQ,CAAEhB,UAAF,EAAcD,WAAd,CAApC;AAEA,SAAO,CAAEG,IAAF,EAAQH,WAAW,CAACkB,KAAZ,GAAoBC,MAApB,CAA4BT,IAA5B,EAAkCC,GAAlC,CAAR,CAAP;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,eAAT,CAA0Bd,SAA1B,EAAqCM,UAArC,EAAiDD,WAAjD,EAA8DK,WAA9D,EAA2EE,YAA3E,EAA0F;AACzF,MAAIa,uBAAuB,GAAG,CAA9B;AACA,MAAIC,wBAAwB,GAAG,CAA/B;AACA,MAAIC,gBAAJ;AACA,MAAIC,gBAAJ,CAJyF,CAMzF;;AACA,QAAMC,eAAe,GAAGxB,WAAW,CAACyB,OAAZ,EAAxB;AAEA9B,EAAAA,SAAS,CAAC+B,IAAV,CAAgBT,QAAQ,IAAI;AAC3B,UAAM,CAAEU,YAAF,EAAgBC,YAAhB,IAAiCxB,WAAW,CAAEa,QAAF,EAAYhB,UAAZ,EAAwBD,WAAxB,CAAlD;AACA,QAAI6B,oBAAJ;AACA,QAAIC,qBAAJ;;AAEA,QAAKzB,WAAL,EAAmB;AAClB,UAAKE,YAAL,EAAoB;AACnB;AACA,cAAMwB,4BAA4B,GAAG1B,WAAW,CAAC2B,eAAZ,CAA6BzB,YAA7B,CAArC;;AAEA,YAAKwB,4BAAL,EAAoC;AACnC;AACA;AACAF,UAAAA,oBAAoB,GAAGE,4BAA4B,CAACE,mBAA7B,CAAkDL,YAAlD,CAAvB;AACA,SAJD,MAIO;AACNC,UAAAA,oBAAoB,GAAG,CAAvB;AACA;AACD,OAXD,MAWO;AACNA,QAAAA,oBAAoB,GAAGxB,WAAW,CAAC4B,mBAAZ,CAAiCL,YAAjC,CAAvB;AACA;AACD;;AAED,QAAKrB,YAAL,EAAoB;AACnBuB,MAAAA,qBAAqB,GAAGvB,YAAY,CAAC0B,mBAAb,CAAkCL,YAAlC,CAAxB;AACA,KAxB0B,CA0B3B;;;AACA,QAAKrB,YAAY,IAAI,CAACF,WAAtB,EAAoC;AACnC,UAAKyB,qBAAqB,GAAGT,wBAA7B,EAAwD;AACvDa,QAAAA,eAAe;AACf;AACD,KAJD,CAKA;AALA,SAMK,IAAK,CAAC3B,YAAD,IAAiBF,WAAtB,EAAoC;AACxC,YAAKwB,oBAAoB,GAAGT,uBAA5B,EAAsD;AACrDc,UAAAA,eAAe;AACf;AACD,OAJI,CAKL;AALK,WAMA;AACJ,cAAKJ,qBAAqB,GAAGT,wBAAxB,IAAoDQ,oBAAoB,IAAIT,uBAAjF,EAA2G;AAC1Gc,YAAAA,eAAe;AACf,WAFD,MAEO,IAAKJ,qBAAqB,IAAIT,wBAAzB,IAAqDQ,oBAAoB,GAAGT,uBAAjF,EAA2G;AACjHc,YAAAA,eAAe;AACf;AACD;;AAED,aAASA,eAAT,GAA2B;AAC1Bb,MAAAA,wBAAwB,GAAGS,qBAA3B;AACAV,MAAAA,uBAAuB,GAAGS,oBAA1B;AACAP,MAAAA,gBAAgB,GAAGM,YAAnB;AACAL,MAAAA,gBAAgB,GAAGI,YAAnB;AACA,KApD0B,CAsD3B;AACA;;;AACA,WAAOE,oBAAoB,KAAKL,eAAhC;AACA,GAzDD;AA2DA,SAAOF,gBAAgB,GAAG,CAAEC,gBAAF,EAAoBD,gBAApB,CAAH,GAA4C,IAAnE;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASV,0BAAT,CAAqC;AAAEF,EAAAA,IAAF;AAAQC,EAAAA;AAAR,CAArC,EAAqD;AACpD,QAAM;AAAEwB,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuBjD,MAAM,CAACqB,MAApC;AAEA,SAAO;AACNE,IAAAA,IAAI,EAAEA,IAAI,GAAGyB,OADP;AAENxB,IAAAA,GAAG,EAAEA,GAAG,GAAGyB;AAFL,GAAP;AAIA;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/position\n */\n\nimport global from './global';\nimport Rect from './rect';\nimport getPositionedAncestor from './getpositionedancestor';\nimport getBorderWidths from './getborderwidths';\nimport { isFunction } from 'lodash-es';\n\n/**\n * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the\n * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry\n * into consideration.\n *\n *\t\t// The element which is to be positioned.\n *\t\tconst element = document.body.querySelector( '#toolbar' );\n *\n *\t\t// A target to which the element is positioned relatively.\n *\t\tconst target = document.body.querySelector( '#container' );\n *\n *\t\t// Finding the optimal coordinates for the positioning.\n *\t\tconst { left, top, name } = getOptimalPosition( {\n *\t\t\telement: element,\n *\t\t\ttarget: target,\n *\n * \t\t\t// The algorithm will chose among these positions to meet the requirements such\n * \t\t\t// as \"limiter\" element or \"fitInViewport\", set below. The positions are considered\n * \t\t\t// in the order of the array.\n *\t\t\tpositions: [\n *\t\t\t\t//\n *\t\t\t \t//\t[ Target ]\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\n *\t\t\t\ttargetRect => ( {\n *\t\t\t\t\ttop: targetRect.bottom,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'mySouthEastPosition'\n *\t\t\t\t} ),\n *\n *\t\t\t\t//\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t|     Element     |\n *\t\t\t\t//\t+-----------------+\n *\t\t\t\t//\t[ Target ]\n *\t\t\t\t//\n *\t\t\t\t( targetRect, elementRect ) => ( {\n *\t\t\t\t\ttop: targetRect.top - elementRect.height,\n *\t\t\t\t\tleft: targetRect.left,\n *\t\t\t\t\tname: 'myNorthEastPosition'\n *\t\t\t\t} )\n *\t\t\t],\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of <body>.\n *\t\t\tlimiter: document.body,\n *\n *\t\t\t// Find a position such guarantees the element remains within visible boundaries of the browser viewport.\n *\t\t\tfitInViewport: true\n *\t\t} );\n *\n *\t\t// The best position which fits into document.body and the viewport. May be useful\n *\t\t// to set proper class on the `element`.\n *\t\tconsole.log( name ); // -> \"myNorthEastPosition\"\n *\n *\t\t// Using the absolute coordinates which has been found to position the element\n *\t\t// as in the diagram depicting the \"myNorthEastPosition\" position.\n *\t\telement.style.top = top;\n *\t\telement.style.left = left;\n *\n * @param {module:utils/dom/position~Options} options Positioning options object.\n * @returns {module:utils/dom/position~Position}\n */\nexport function getOptimalPosition( { element, target, positions, limiter, fitInViewport } ) {\n\t// If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-utils/issues/157\n\tif ( isFunction( target ) ) {\n\t\ttarget = target();\n\t}\n\n\t// If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.\n\t// https://github.com/ckeditor/ckeditor5-ui/issues/260\n\tif ( isFunction( limiter ) ) {\n\t\tlimiter = limiter();\n\t}\n\n\tconst positionedElementAncestor = getPositionedAncestor( element.parentElement );\n\tconst elementRect = new Rect( element );\n\tconst targetRect = new Rect( target );\n\n\tlet bestPosition;\n\tlet name;\n\n\t// If there are no limits, just grab the very first position and be done with that drama.\n\tif ( !limiter && !fitInViewport ) {\n\t\t[ name, bestPosition ] = getPosition( positions[ 0 ], targetRect, elementRect );\n\t} else {\n\t\tconst limiterRect = limiter && new Rect( limiter ).getVisible();\n\t\tconst viewportRect = fitInViewport && new Rect( global.window );\n\n\t\t[ name, bestPosition ] =\n\t\t\tgetBestPosition( positions, targetRect, elementRect, limiterRect, viewportRect ) ||\n\t\t\t// If there's no best position found, i.e. when all intersections have no area because\n\t\t\t// rects have no width or height, then just use the first available position.\n\t\t\tgetPosition( positions[ 0 ], targetRect, elementRect );\n\t}\n\n\tlet { left, top } = getAbsoluteRectCoordinates( bestPosition );\n\n\tif ( positionedElementAncestor ) {\n\t\tconst ancestorPosition = getAbsoluteRectCoordinates( new Rect( positionedElementAncestor ) );\n\t\tconst ancestorBorderWidths = getBorderWidths( positionedElementAncestor );\n\n\t\t// (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)\n\t\t// If there's some positioned ancestor of the panel, then its `Rect` must be taken into\n\t\t// consideration. `Rect` is always relative to the viewport while `position: absolute` works\n\t\t// with respect to that positioned ancestor.\n\t\tleft -= ancestorPosition.left;\n\t\ttop -= ancestorPosition.top;\n\n\t\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t\t// If there's some positioned ancestor of the panel, not only its position must be taken into\n\t\t// consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`\n\t\t// is relative to the viewport (it doesn't care about scrolling), while `position: absolute`\n\t\t// must compensate that scrolling.\n\t\tleft += positionedElementAncestor.scrollLeft;\n\t\ttop += positionedElementAncestor.scrollTop;\n\n\t\t// (https://github.com/ckeditor/ckeditor5-utils/issues/139)\n\t\t// If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`\n\t\t// while `position: absolute` positioning does not consider it.\n\t\t// E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,\n\t\t// not upper-left corner of its border.\n\t\tleft -= ancestorBorderWidths.left;\n\t\ttop -= ancestorBorderWidths.top;\n\t}\n\n\treturn { left, top, name };\n}\n\n// For given position function, returns a corresponding `Rect` instance.\n//\n// @private\n// @param {Function} position A function returning {@link module:utils/dom/position~Position}.\n// @param {utils/dom/rect~Rect} targetRect A rect of the target.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.\n// @returns {Array} An array containing position name and its Rect.\nfunction getPosition( position, targetRect, elementRect ) {\n\tconst { left, top, name } = position( targetRect, elementRect );\n\n\treturn [ name, elementRect.clone().moveTo( left, top ) ];\n}\n\n// For a given array of positioning functions, returns such that provides the best\n// fit of the `elementRect` into the `limiterRect` and `viewportRect`.\n//\n// @private\n// @param {module:utils/dom/position~Options#positions} positions Functions returning\n// {@link module:utils/dom/position~Position} to be checked, in the order of preference.\n// @param {utils/dom/rect~Rect} targetRect A rect of the {@link module:utils/dom/position~Options#target}.\n// @param {utils/dom/rect~Rect} elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.\n// @param {utils/dom/rect~Rect} limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.\n// @param {utils/dom/rect~Rect} viewportRect A rect of the viewport.\n// @returns {Array} An array containing the name of the position and it's rect.\nfunction getBestPosition( positions, targetRect, elementRect, limiterRect, viewportRect ) {\n\tlet maxLimiterIntersectArea = 0;\n\tlet maxViewportIntersectArea = 0;\n\tlet bestPositionRect;\n\tlet bestPositionName;\n\n\t// This is when element is fully visible.\n\tconst elementRectArea = elementRect.getArea();\n\n\tpositions.some( position => {\n\t\tconst [ positionName, positionRect ] = getPosition( position, targetRect, elementRect );\n\t\tlet limiterIntersectArea;\n\t\tlet viewportIntersectArea;\n\n\t\tif ( limiterRect ) {\n\t\t\tif ( viewportRect ) {\n\t\t\t\t// Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.\n\t\t\t\tconst limiterViewportIntersectRect = limiterRect.getIntersection( viewportRect );\n\n\t\t\t\tif ( limiterViewportIntersectRect ) {\n\t\t\t\t\t// If the limiter is within the viewport, then check the intersection between that part of the\n\t\t\t\t\t// limiter and actual position.\n\t\t\t\t\tlimiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea( positionRect );\n\t\t\t\t} else {\n\t\t\t\t\tlimiterIntersectArea = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlimiterIntersectArea = limiterRect.getIntersectionArea( positionRect );\n\t\t\t}\n\t\t}\n\n\t\tif ( viewportRect ) {\n\t\t\tviewportIntersectArea = viewportRect.getIntersectionArea( positionRect );\n\t\t}\n\n\t\t// The only criterion: intersection with the viewport.\n\t\tif ( viewportRect && !limiterRect ) {\n\t\t\tif ( viewportIntersectArea > maxViewportIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t}\n\t\t}\n\t\t// The only criterion: intersection with the limiter.\n\t\telse if ( !viewportRect && limiterRect ) {\n\t\t\tif ( limiterIntersectArea > maxLimiterIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t}\n\t\t}\n\t\t// Two criteria: intersection with the viewport and the limiter visible in the viewport.\n\t\telse {\n\t\t\tif ( viewportIntersectArea > maxViewportIntersectArea && limiterIntersectArea >= maxLimiterIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t} else if ( viewportIntersectArea >= maxViewportIntersectArea && limiterIntersectArea > maxLimiterIntersectArea ) {\n\t\t\t\tsetBestPosition();\n\t\t\t}\n\t\t}\n\n\t\tfunction setBestPosition() {\n\t\t\tmaxViewportIntersectArea = viewportIntersectArea;\n\t\t\tmaxLimiterIntersectArea = limiterIntersectArea;\n\t\t\tbestPositionRect = positionRect;\n\t\t\tbestPositionName = positionName;\n\t\t}\n\n\t\t// If a such position is found that element is fully container by the limiter then, obviously,\n\t\t// there will be no better one, so finishing.\n\t\treturn limiterIntersectArea === elementRectArea;\n\t} );\n\n\treturn bestPositionRect ? [ bestPositionName, bestPositionRect ] : null;\n}\n\n// DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.\n// This function converts Rect to `position: absolute` coordinates.\n//\n// @private\n// @param {utils/dom/rect~Rect} rect A rect to be converted.\n// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.\nfunction getAbsoluteRectCoordinates( { left, top } ) {\n\tconst { scrollX, scrollY } = global.window;\n\n\treturn {\n\t\tleft: left + scrollX,\n\t\ttop: top + scrollY,\n\t};\n}\n\n/**\n * The `getOptimalPosition` helper options.\n *\n * @interface module:utils/dom/position~Options\n */\n\n/**\n * Element that is to be positioned.\n *\n * @member {HTMLElement} #element\n */\n\n/**\n * Target with respect to which the `element` is to be positioned.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #target\n */\n\n/**\n * An array of functions which return {@link module:utils/dom/position~Position} relative\n * to the `target`, in the order of preference.\n *\n * @member {Array.<Function>} #positions\n */\n\n/**\n * When set, the algorithm will chose position which fits the most in the\n * limiter's bounding rect.\n *\n * @member {HTMLElement|Range|ClientRect|Rect|Function} #limiter\n */\n\n/**\n * When set, the algorithm will chose such a position which fits `element`\n * the most inside visible viewport.\n *\n * @member {Boolean} #fitInViewport\n */\n\n/**\n * An object describing a position in `position: absolute` coordinate\n * system, along with position name.\n *\n * @typedef {Object} module:utils/dom/position~Position\n *\n * @property {Number} top Top position offset.\n * @property {Number} left Left position offset.\n * @property {String} name Name of the position.\n */\n"]},"metadata":{},"sourceType":"module"}