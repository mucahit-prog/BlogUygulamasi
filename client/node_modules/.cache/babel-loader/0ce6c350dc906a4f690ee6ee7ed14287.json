{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, isBlockFiller, isInlineFiller, startsWithFiller, getDataWithoutFiller } from './filler';\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\n\nexport default class DomConverter {\n  /**\n   * Creates DOM converter.\n   *\n   * @param {Object} options Object with configuration options.\n   * @param {Function} [options.blockFiller=module:engine/view/filler~BR_FILLER] Block filler creator.\n   */\n  constructor(options = {}) {\n    // Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM\n    // will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced\n    // will be also removed, isn't it brilliant?\n    //\n    // Yes, PJ. It is.\n    //\n    // You guys so smart.\n    //\n    // I've been here. Seen stuff. Afraid of code now.\n\n    /**\n     * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n     * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n     *\n     * @readonly\n     * @member {Function} module:engine/view/domconverter~DomConverter#blockFiller\n     */\n    this.blockFiller = options.blockFiller || BR_FILLER;\n    /**\n     * Tag names of DOM `Element`s which are considered pre-formatted elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n     */\n\n    this.preElements = ['pre'];\n    /**\n     * Tag names of DOM `Element`s which are considered block elements.\n     *\n     * @readonly\n     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n     */\n\n    this.blockElements = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n    /**\n     * DOM to View mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n     */\n\n    this._domToViewMapping = new WeakMap();\n    /**\n     * View to DOM mapping.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n     */\n\n    this._viewToDomMapping = new WeakMap();\n    /**\n     * Holds mapping between fake selection containers and corresponding view selections.\n     *\n     * @private\n     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n     */\n\n    this._fakeSelectionMapping = new WeakMap();\n  }\n  /**\n   * Binds given DOM element that represents fake selection to {@link module:engine/view/documentselection~DocumentSelection\n   * document selection}. Document selection copy is stored and can be retrieved by\n   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n   *\n   * @param {HTMLElement} domElement\n   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n   */\n\n\n  bindFakeSelection(domElement, viewDocumentSelection) {\n    this._fakeSelectionMapping.set(domElement, new ViewSelection(viewDocumentSelection));\n  }\n  /**\n   * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n   * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n   *\n   * @param {HTMLElement} domElement\n   * @returns {module:engine/view/selection~Selection|undefined}\n   */\n\n\n  fakeSelectionToView(domElement) {\n    return this._fakeSelectionMapping.get(domElement);\n  }\n  /**\n   * Binds DOM and View elements, so it will be possible to get corresponding elements using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {HTMLElement} domElement DOM element to bind.\n   * @param {module:engine/view/element~Element} viewElement View element to bind.\n   */\n\n\n  bindElements(domElement, viewElement) {\n    this._domToViewMapping.set(domElement, viewElement);\n\n    this._viewToDomMapping.set(viewElement, domElement);\n  }\n  /**\n   * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n   * `domElement` will be unbound too.\n   *\n   * @param {HTMLElement} domElement DOM element to unbind.\n   */\n\n\n  unbindDomElement(domElement) {\n    const viewElement = this._domToViewMapping.get(domElement);\n\n    if (viewElement) {\n      this._domToViewMapping.delete(domElement);\n\n      this._viewToDomMapping.delete(viewElement); // Use Array.from because of MS Edge (#923).\n\n\n      for (const child of Array.from(domElement.childNodes)) {\n        this.unbindDomElement(child);\n      }\n    }\n  }\n  /**\n   * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n   * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n   * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n   *\n   * @param {DocumentFragment} domFragment DOM document fragment to bind.\n   * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n   */\n\n\n  bindDocumentFragments(domFragment, viewFragment) {\n    this._domToViewMapping.set(domFragment, viewFragment);\n\n    this._viewToDomMapping.set(viewFragment, domFragment);\n  }\n  /**\n   * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments function will return corresponding items.\n   *\n   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View node or document fragment to transform.\n   * @param {Document} domDocument Document which will be used to create DOM nodes.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n   */\n\n\n  viewToDom(viewNode, domDocument, options = {}) {\n    if (viewNode.is('text')) {\n      const textData = this._processDataFromViewText(viewNode);\n\n      return domDocument.createTextNode(textData);\n    } else {\n      if (this.mapViewToDom(viewNode)) {\n        return this.mapViewToDom(viewNode);\n      }\n\n      let domElement;\n\n      if (viewNode.is('documentFragment')) {\n        // Create DOM document fragment.\n        domElement = domDocument.createDocumentFragment();\n\n        if (options.bind) {\n          this.bindDocumentFragments(domElement, viewNode);\n        }\n      } else if (viewNode.is('uiElement')) {\n        // UIElement has its own render() method (see #799).\n        domElement = viewNode.render(domDocument);\n\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        }\n\n        return domElement;\n      } else {\n        // Create DOM element.\n        domElement = domDocument.createElement(viewNode.name);\n\n        if (options.bind) {\n          this.bindElements(domElement, viewNode);\n        } // Copy element's attributes.\n\n\n        for (const key of viewNode.getAttributeKeys()) {\n          domElement.setAttribute(key, viewNode.getAttribute(key));\n        }\n      }\n\n      if (options.withChildren || options.withChildren === undefined) {\n        for (const child of this.viewChildrenToDom(viewNode, domDocument, options)) {\n          domElement.appendChild(child);\n        }\n      }\n\n      return domElement;\n    }\n  }\n  /**\n   * Converts children of the view element to DOM using the\n   * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n   * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n   * @param {Document} domDocument Document which will be used to create DOM nodes.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n   * @returns {Iterable.<Node>} DOM nodes.\n   */\n\n\n  *viewChildrenToDom(viewElement, domDocument, options = {}) {\n    const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n    let offset = 0;\n\n    for (const childView of viewElement.getChildren()) {\n      if (fillerPositionOffset === offset) {\n        yield this.blockFiller(domDocument);\n      }\n\n      yield this.viewToDom(childView, domDocument, options);\n      offset++;\n    }\n\n    if (fillerPositionOffset === offset) {\n      yield this.blockFiller(domDocument);\n    }\n  }\n  /**\n   * Converts view {@link module:engine/view/range~Range} to DOM range.\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   *\n   * @param {module:engine/view/range~Range} viewRange View range.\n   * @returns {Range} DOM range.\n   */\n\n\n  viewRangeToDom(viewRange) {\n    const domStart = this.viewPositionToDom(viewRange.start);\n    const domEnd = this.viewPositionToDom(viewRange.end);\n    const domRange = document.createRange();\n    domRange.setStart(domStart.parent, domStart.offset);\n    domRange.setEnd(domEnd.parent, domEnd.offset);\n    return domRange;\n  }\n  /**\n   * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n   *\n   * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n   * If the converted position is directly before inline filler it is moved inside the filler.\n   *\n   * @param {module:engine/view/position~Position} viewPosition View position.\n   * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n   * @returns {Node} position.parent DOM position parent.\n   * @returns {Number} position.offset DOM position offset.\n   */\n\n\n  viewPositionToDom(viewPosition) {\n    const viewParent = viewPosition.parent;\n\n    if (viewParent.is('text')) {\n      const domParent = this.findCorrespondingDomText(viewParent);\n\n      if (!domParent) {\n        // Position is in a view text node that has not been rendered to DOM yet.\n        return null;\n      }\n\n      let offset = viewPosition.offset;\n\n      if (startsWithFiller(domParent)) {\n        offset += INLINE_FILLER_LENGTH;\n      }\n\n      return {\n        parent: domParent,\n        offset\n      };\n    } else {\n      // viewParent is instance of ViewElement.\n      let domParent, domBefore, domAfter;\n\n      if (viewPosition.offset === 0) {\n        domParent = this.mapViewToDom(viewParent);\n\n        if (!domParent) {\n          // Position is in a view element that has not been rendered to DOM yet.\n          return null;\n        }\n\n        domAfter = domParent.childNodes[0];\n      } else {\n        const nodeBefore = viewPosition.nodeBefore;\n        domBefore = nodeBefore.is('text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(viewPosition.nodeBefore);\n\n        if (!domBefore) {\n          // Position is after a view element that has not been rendered to DOM yet.\n          return null;\n        }\n\n        domParent = domBefore.parentNode;\n        domAfter = domBefore.nextSibling;\n      } // If there is an inline filler at position return position inside the filler. We should never return\n      // the position before the inline filler.\n\n\n      if (isText(domAfter) && startsWithFiller(domAfter)) {\n        return {\n          parent: domAfter,\n          offset: INLINE_FILLER_LENGTH\n        };\n      }\n\n      const offset = domBefore ? indexOf(domBefore) + 1 : 0;\n      return {\n        parent: domParent,\n        offset\n      };\n    }\n  }\n  /**\n   * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n   * be created. For bound elements and document fragments function will return corresponding items. For\n   * {@link module:engine/view/filler fillers} `null` will be returned.\n   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n   * @param {Object} [options] Conversion options.\n   * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n   * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n   * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n   * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n   * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n   */\n\n\n  domToView(domNode, options = {}) {\n    if (isBlockFiller(domNode, this.blockFiller)) {\n      return null;\n    } // When node is inside UIElement return that UIElement as it's view representation.\n\n\n    const uiElement = this.getParentUIElement(domNode, this._domToViewMapping);\n\n    if (uiElement) {\n      return uiElement;\n    }\n\n    if (isText(domNode)) {\n      if (isInlineFiller(domNode)) {\n        return null;\n      } else {\n        const textData = this._processDataFromDomText(domNode);\n\n        return textData === '' ? null : new ViewText(textData);\n      }\n    } else if (this.isComment(domNode)) {\n      return null;\n    } else {\n      if (this.mapDomToView(domNode)) {\n        return this.mapDomToView(domNode);\n      }\n\n      let viewElement;\n\n      if (this.isDocumentFragment(domNode)) {\n        // Create view document fragment.\n        viewElement = new ViewDocumentFragment();\n\n        if (options.bind) {\n          this.bindDocumentFragments(domNode, viewElement);\n        }\n      } else {\n        // Create view element.\n        const viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n        viewElement = new ViewElement(viewName);\n\n        if (options.bind) {\n          this.bindElements(domNode, viewElement);\n        } // Copy element's attributes.\n\n\n        const attrs = domNode.attributes;\n\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          viewElement._setAttribute(attrs[i].name, attrs[i].value);\n        }\n      }\n\n      if (options.withChildren || options.withChildren === undefined) {\n        for (const child of this.domChildrenToView(domNode, options)) {\n          viewElement._appendChild(child);\n        }\n      }\n\n      return viewElement;\n    }\n  }\n  /**\n   * Converts children of the DOM element to view nodes using\n   * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n   * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n   *\n   * @param {HTMLElement} domElement Parent DOM element.\n   * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n   * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n   */\n\n\n  *domChildrenToView(domElement, options = {}) {\n    for (let i = 0; i < domElement.childNodes.length; i++) {\n      const domChild = domElement.childNodes[i];\n      const viewChild = this.domToView(domChild, options);\n\n      if (viewChild !== null) {\n        yield viewChild;\n      }\n    }\n  }\n  /**\n   * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n   * Ranges which cannot be converted will be omitted.\n   *\n   * @param {Selection} domSelection DOM selection.\n   * @returns {module:engine/view/selection~Selection} View selection.\n   */\n\n\n  domSelectionToView(domSelection) {\n    // DOM selection might be placed in fake selection container.\n    // If container contains fake selection - return corresponding view selection.\n    if (domSelection.rangeCount === 1) {\n      let container = domSelection.getRangeAt(0).startContainer; // The DOM selection might be moved to the text node inside the fake selection container.\n\n      if (isText(container)) {\n        container = container.parentNode;\n      }\n\n      const viewSelection = this.fakeSelectionToView(container);\n\n      if (viewSelection) {\n        return viewSelection;\n      }\n    }\n\n    const isBackward = this.isDomSelectionBackward(domSelection);\n    const viewRanges = [];\n\n    for (let i = 0; i < domSelection.rangeCount; i++) {\n      // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n      const domRange = domSelection.getRangeAt(i);\n      const viewRange = this.domRangeToView(domRange);\n\n      if (viewRange) {\n        viewRanges.push(viewRange);\n      }\n    }\n\n    return new ViewSelection(viewRanges, {\n      backward: isBackward\n    });\n  }\n  /**\n   * Converts DOM Range to view {@link module:engine/view/range~Range}.\n   * If the start or end position can not be converted `null` is returned.\n   *\n   * @param {Range} domRange DOM range.\n   * @returns {module:engine/view/range~Range|null} View range.\n   */\n\n\n  domRangeToView(domRange) {\n    const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);\n    const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);\n\n    if (viewStart && viewEnd) {\n      return new ViewRange(viewStart, viewEnd);\n    }\n\n    return null;\n  }\n  /**\n   * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n   *\n   * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n   * position of the filler will be converted and returned.\n   *\n   * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n   * that position will be converted to view position before that UIElement.\n   *\n   * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n   *\n   * @param {Node} domParent DOM position parent.\n   * @param {Number} domOffset DOM position offset.\n   * @returns {module:engine/view/position~Position} viewPosition View position.\n   */\n\n\n  domPositionToView(domParent, domOffset) {\n    if (isBlockFiller(domParent, this.blockFiller)) {\n      return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n    } // If position is somewhere inside UIElement - return position before that element.\n\n\n    const viewElement = this.mapDomToView(domParent);\n\n    if (viewElement && viewElement.is('uiElement')) {\n      return ViewPosition._createBefore(viewElement);\n    }\n\n    if (isText(domParent)) {\n      if (isInlineFiller(domParent)) {\n        return this.domPositionToView(domParent.parentNode, indexOf(domParent));\n      }\n\n      const viewParent = this.findCorrespondingViewText(domParent);\n      let offset = domOffset;\n\n      if (!viewParent) {\n        return null;\n      }\n\n      if (startsWithFiller(domParent)) {\n        offset -= INLINE_FILLER_LENGTH;\n        offset = offset < 0 ? 0 : offset;\n      }\n\n      return new ViewPosition(viewParent, offset);\n    } // domParent instanceof HTMLElement.\n    else {\n        if (domOffset === 0) {\n          const viewParent = this.mapDomToView(domParent);\n\n          if (viewParent) {\n            return new ViewPosition(viewParent, 0);\n          }\n        } else {\n          const domBefore = domParent.childNodes[domOffset - 1];\n          const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore); // TODO #663\n\n          if (viewBefore && viewBefore.parent) {\n            return new ViewPosition(viewBefore.parent, viewBefore.index + 1);\n          }\n        }\n\n        return null;\n      }\n  }\n  /**\n   * Returns corresponding view {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n   * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * to the given DOM - `undefined` is returned.\n   * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n   * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n   * Corresponding view element, document fragment or `undefined` if no element was bound.\n   */\n\n\n  mapDomToView(domElementOrDocumentFragment) {\n    return this.getParentUIElement(domElementOrDocumentFragment) || this._domToViewMapping.get(domElementOrDocumentFragment);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n   *\n   * Otherwise `null` is returned.\n   *\n   * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n   *\n   * @param {Text} domText DOM text node.\n   * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n   * corresponding node.\n   */\n\n\n  findCorrespondingViewText(domText) {\n    if (isInlineFiller(domText)) {\n      return null;\n    } // If DOM text was rendered by UIElement - return that element.\n\n\n    const uiElement = this.getParentUIElement(domText);\n\n    if (uiElement) {\n      return uiElement;\n    }\n\n    const previousSibling = domText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n    if (previousSibling) {\n      if (!this.isElement(previousSibling)) {\n        // The previous is text or comment.\n        return null;\n      }\n\n      const viewElement = this.mapDomToView(previousSibling);\n\n      if (viewElement) {\n        const nextSibling = viewElement.nextSibling; // It might be filler which has no corresponding view node.\n\n        if (nextSibling instanceof ViewText) {\n          return viewElement.nextSibling;\n        } else {\n          return null;\n        }\n      }\n    } // Try to use parent to find the corresponding text node.\n    else {\n        const viewElement = this.mapDomToView(domText.parentNode);\n\n        if (viewElement) {\n          const firstChild = viewElement.getChild(0); // It might be filler which has no corresponding view node.\n\n          if (firstChild instanceof ViewText) {\n            return firstChild;\n          } else {\n            return null;\n          }\n        }\n      }\n\n    return null;\n  }\n  /**\n   * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n   * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n   * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n   * use {@link #findCorrespondingDomText}.\n   *\n   * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n   * View element or document fragment.\n   * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n   */\n\n\n  mapViewToDom(documentFragmentOrElement) {\n    return this._viewToDomMapping.get(documentFragmentOrElement);\n  }\n  /**\n   * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n   * corresponding text node is returned based on the sibling or parent.\n   *\n   * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n   * to find the corresponding text node.\n   *\n   * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n   * element, it is used to find the corresponding text node.\n   *\n   * Otherwise `null` is returned.\n   *\n   * @param {module:engine/view/text~Text} viewText View text node.\n   * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n   */\n\n\n  findCorrespondingDomText(viewText) {\n    const previousSibling = viewText.previousSibling; // Try to use previous sibling to find the corresponding text node.\n\n    if (previousSibling && this.mapViewToDom(previousSibling)) {\n      return this.mapViewToDom(previousSibling).nextSibling;\n    } // If this is a first node, try to use parent to find the corresponding text node.\n\n\n    if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {\n      return this.mapViewToDom(viewText.parent).childNodes[0];\n    }\n\n    return null;\n  }\n  /**\n   * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n   *\n   * @param {module:engine/view/editableelement~EditableElement} viewEditable\n   */\n\n\n  focus(viewEditable) {\n    const domEditable = this.mapViewToDom(viewEditable);\n\n    if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {\n      // Save the scrollX and scrollY positions before the focus.\n      const {\n        scrollX,\n        scrollY\n      } = global.window;\n      const scrollPositions = []; // Save all scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n\n      forEachDomNodeAncestor(domEditable, node => {\n        const {\n          scrollLeft,\n          scrollTop\n        } = node;\n        scrollPositions.push([scrollLeft, scrollTop]);\n      });\n      domEditable.focus(); // Restore scrollLeft and scrollTop values starting from domEditable up to\n      // document#documentElement.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n      // https://github.com/ckeditor/ckeditor5-engine/issues/957\n\n      forEachDomNodeAncestor(domEditable, node => {\n        const [scrollLeft, scrollTop] = scrollPositions.shift();\n        node.scrollLeft = scrollLeft;\n        node.scrollTop = scrollTop;\n      }); // Restore the scrollX and scrollY positions after the focus.\n      // https://github.com/ckeditor/ckeditor5-engine/issues/951\n\n      global.window.scrollTo(scrollX, scrollY);\n    }\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isElement(node) {\n    return node && node.nodeType == Node.ELEMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isDocumentFragment(node) {\n    return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n  }\n  /**\n   * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n   *\n   * @param {Node} node Node to check.\n   * @returns {Boolean}\n   */\n\n\n  isComment(node) {\n    return node && node.nodeType == Node.COMMENT_NODE;\n  }\n  /**\n   * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n   *\n   * @param {Selection} DOM Selection instance to check.\n   * @returns {Boolean}\n   */\n\n\n  isDomSelectionBackward(selection) {\n    if (selection.isCollapsed) {\n      return false;\n    } // Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n    // we will use the fact that range will collapse if it's end is before it's start.\n\n\n    const range = document.createRange();\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(selection.focusNode, selection.focusOffset);\n    const backward = range.collapsed;\n    range.detach();\n    return backward;\n  }\n  /**\n   * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n   * parent UIElement.\n   *\n   * @param {Node} domNode\n   * @returns {module:engine/view/uielement~UIElement|null}\n   */\n\n\n  getParentUIElement(domNode) {\n    const ancestors = getAncestors(domNode); // Remove domNode from the list.\n\n    ancestors.pop();\n\n    while (ancestors.length) {\n      const domNode = ancestors.pop();\n\n      const viewNode = this._domToViewMapping.get(domNode);\n\n      if (viewNode && viewNode.is('uiElement')) {\n        return viewNode;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Checks if given selection's boundaries are at correct places.\n   *\n   * The following places are considered as incorrect for selection boundaries:\n   * * before or in the middle of the inline filler sequence,\n   * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n   *\n   * @param {Selection} domSelection DOM Selection object to be checked.\n   * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n   */\n\n\n  isDomSelectionCorrect(domSelection) {\n    return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);\n  }\n  /**\n   * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n   *\n   * @private\n   * @param {Element} domParent Position parent.\n   * @param {Number} offset Position offset.\n   * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n   */\n\n\n  _isDomSelectionPositionCorrect(domParent, offset) {\n    // If selection is before or in the middle of inline filler string, it is incorrect.\n    if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {\n      // Selection in a text node, at wrong position (before or in the middle of filler).\n      return false;\n    }\n\n    if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {\n      // Selection in an element node, before filler text node.\n      return false;\n    }\n\n    const viewParent = this.mapDomToView(domParent); // If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n    // also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\n    if (viewParent && viewParent.is('uiElement')) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n   * it is correctly displayed in the DOM.\n   *\n   * Following changes are done:\n   *\n   * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n   * element or if a previous text node ends with a space character,\n   * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container,\n   * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n   *\n   * Content of {@link #preElements} is not processed.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node View text node to process.\n   * @returns {String} Processed text data.\n   */\n\n\n  _processDataFromViewText(node) {\n    let data = node.data; // If any of node ancestors has a name which is in `preElements` array, then currently processed\n    // view text node is (will be) in preformatted element. We should not change whitespaces then.\n\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return data;\n    } // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n    // (container element boundary).\n\n\n    if (data.charAt(0) == ' ') {\n      const prevNode = this._getTouchingViewTextNode(node, false);\n\n      const prevEndsWithSpace = prevNode && this._nodeEndsWithSpace(prevNode);\n\n      if (prevEndsWithSpace || !prevNode) {\n        data = '\\u00A0' + data.substr(1);\n      }\n    } // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n    // next node (container element boundary).\n    //\n    // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n    //\n    // Foo <span>&nbsp;bar</span>  <-- bad.\n    // Foo&nbsp;<span> bar</span>  <-- good.\n    //\n    // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\n\n    if (data.charAt(data.length - 1) == ' ') {\n      const nextNode = this._getTouchingViewTextNode(node, true);\n\n      if (data.charAt(data.length - 2) == ' ' || !nextNode || nextNode.data.charAt(0) == ' ') {\n        data = data.substr(0, data.length - 1) + '\\u00A0';\n      }\n    } // 3. Create space+nbsp pairs.\n\n\n    return data.replace(/ {2}/g, ' \\u00A0');\n  }\n  /**\n   * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n   *\n   * @private\n   * @param {module:engine/view/text~Text} node Node to check.\n   * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n   */\n\n\n  _nodeEndsWithSpace(node) {\n    if (node.getAncestors().some(parent => this.preElements.includes(parent.name))) {\n      return false;\n    }\n\n    const data = this._processDataFromViewText(node);\n\n    return data.charAt(data.length - 1) == ' ';\n  }\n  /**\n   * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n   *\n   * Following changes are done:\n   *\n   * * multiple whitespaces are replaced to a single space,\n   * * space at the beginning of a text node is removed if it is the first text node in its container\n   * element or if the previous text node ends with a space character,\n   * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n   * starts with a space or if it is the last text node in its container\n   * * nbsps are converted to spaces.\n   *\n   * @param {Node} node DOM text node to process.\n   * @returns {String} Processed data.\n   * @private\n   */\n\n\n  _processDataFromDomText(node) {\n    let data = node.data;\n\n    if (_hasDomParentOfType(node, this.preElements)) {\n      return getDataWithoutFiller(node);\n    } // Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n    // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n    // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n    // We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\n\n    data = data.replace(/[ \\n\\t\\r]{1,}/g, ' ');\n\n    const prevNode = this._getTouchingInlineDomNode(node, false);\n\n    const nextNode = this._getTouchingInlineDomNode(node, true);\n\n    const shouldLeftTrim = this._checkShouldLeftTrimDomText(prevNode);\n\n    const shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode); // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n    // of this text node. Such space character is treated as a whitespace.\n\n\n    if (shouldLeftTrim) {\n      data = data.replace(/^ /, '');\n    } // If the next text node does not exist remove space character from the end of this text node.\n\n\n    if (shouldRightTrim) {\n      data = data.replace(/ $/, '');\n    } // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n    // This means that the text node starts/end with normal space instead of non-breaking space.\n    // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n    // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\n\n    data = getDataWithoutFiller(new Text(data)); // At this point we should have removed all whitespaces from DOM text data.\n    //\n    // Now, We will reverse the process that happens in `_processDataFromViewText`.\n    //\n    // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n    // First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n    // ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\n    data = data.replace(/ \\u00A0/g, '  '); // Then, let's change the last nbsp to a space.\n\n    if (/( |\\u00A0)\\u00A0$/.test(data) || !nextNode || nextNode.data && nextNode.data.charAt(0) == ' ') {\n      data = data.replace(/\\u00A0$/, ' ');\n    } // Then, change &nbsp; character that is at the beginning of the text node to space character.\n    // We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\n\n    if (shouldLeftTrim) {\n      data = data.replace(/^\\u00A0/, ' ');\n    } // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n    // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\n\n    return data;\n  }\n  /**\n   * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n   * be trimmed from the left side.\n   *\n   * @param {Node} prevNode\n   */\n\n\n  _checkShouldLeftTrimDomText(prevNode) {\n    if (!prevNode) {\n      return true;\n    }\n\n    if (isElement(prevNode)) {\n      return true;\n    }\n\n    return /[^\\S\\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));\n  }\n  /**\n   * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n   * be trimmed from the right side.\n   *\n   * @param {Node} node\n   * @param {Node} nextNode\n   */\n\n\n  _checkShouldRightTrimDomText(node, nextNode) {\n    if (nextNode) {\n      return false;\n    }\n\n    return !startsWithFiller(node);\n  }\n  /**\n   * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n   * that is contained in the same container element. If there is no such sibling, `null` is returned.\n   *\n   * @param {module:engine/view/text~Text} node Reference node.\n   * @param {Boolean} getNext\n   * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n   */\n\n\n  _getTouchingViewTextNode(node, getNext) {\n    const treeWalker = new ViewTreeWalker({\n      startPosition: getNext ? ViewPosition._createAfter(node) : ViewPosition._createBefore(node),\n      direction: getNext ? 'forward' : 'backward'\n    });\n\n    for (const value of treeWalker) {\n      // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n      // text node in its container element.\n      if (value.item.is('containerElement')) {\n        return null;\n      } // <br> found – it works like a block boundary, so do not scan further.\n      else if (value.item.is('br')) {\n          return null;\n        } // Found a text node in the same container element.\n        else if (value.item.is('textProxy')) {\n            return value.item;\n          }\n    }\n\n    return null;\n  }\n  /**\n   * Helper function. For the given text node, it finds the closest touching node which is either\n   * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n   * wasn't found so far, `null` is returned.\n   *\n   * In the following DOM structure:\n   *\n   *\t\t<p>foo<b>bar</b><br>bom</p>\n   *\n   * * `foo` doesn't have its previous touching inline node (`null` is returned),\n   * * `foo`'s next touching inline node is `bar`\n   * * `bar`'s next touching inline node is `<br>`\n   *\n   * This method returns text nodes and `<br>` elements because these types of nodes affect how\n   * spaces in the given text node need to be converted.\n   *\n   * @private\n   * @param {Text} node\n   * @param {Boolean} getNext\n   * @returns {Text|Element|null}\n   */\n\n\n  _getTouchingInlineDomNode(node, getNext) {\n    if (!node.parentNode) {\n      return null;\n    }\n\n    const direction = getNext ? 'nextNode' : 'previousNode';\n    const document = node.ownerDocument;\n    const topmostParent = getAncestors(node)[0];\n    const treeWalker = document.createTreeWalker(topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n      acceptNode(node) {\n        if (isText(node)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        if (node.tagName == 'BR') {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      }\n\n    });\n    treeWalker.currentNode = node;\n    const touchingNode = treeWalker[direction]();\n\n    if (touchingNode !== null) {\n      const lca = getCommonAncestor(node, touchingNode); // If there is common ancestor between the text node and next/prev text node,\n      // and there are no block elements on a way from the text node to that ancestor,\n      // and there are no block elements on a way from next/prev text node to that ancestor...\n\n      if (lca && !_hasDomParentOfType(node, this.blockElements, lca) && !_hasDomParentOfType(touchingNode, this.blockElements, lca)) {\n        // Then they are in the same container element.\n        return touchingNode;\n      }\n    }\n\n    return null;\n  }\n\n} // Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\n\nfunction _hasDomParentOfType(node, types, boundaryParent) {\n  let parents = getAncestors(node);\n\n  if (boundaryParent) {\n    parents = parents.slice(parents.indexOf(boundaryParent) + 1);\n  }\n\n  return parents.some(parent => parent.tagName && types.includes(parent.tagName.toLowerCase()));\n} // A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\n\n\nfunction forEachDomNodeAncestor(node, callback) {\n  while (node && node != global.document) {\n    callback(node);\n    node = node.parentNode;\n  }\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"names":["ViewText","ViewElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","BR_FILLER","INLINE_FILLER_LENGTH","isBlockFiller","isInlineFiller","startsWithFiller","getDataWithoutFiller","global","indexOf","getAncestors","getCommonAncestor","isText","isElement","DomConverter","constructor","options","blockFiller","preElements","blockElements","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","bindFakeSelection","domElement","viewDocumentSelection","set","fakeSelectionToView","get","bindElements","viewElement","unbindDomElement","delete","child","Array","from","childNodes","bindDocumentFragments","domFragment","viewFragment","viewToDom","viewNode","domDocument","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","createDocumentFragment","bind","render","createElement","name","key","getAttributeKeys","setAttribute","getAttribute","withChildren","undefined","viewChildrenToDom","appendChild","fillerPositionOffset","getFillerOffset","offset","childView","getChildren","viewRangeToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","document","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domToView","domNode","uiElement","getParentUIElement","_processDataFromDomText","isComment","mapDomToView","isDocumentFragment","viewName","keepOriginalCase","tagName","toLowerCase","attrs","attributes","i","length","_setAttribute","value","domChildrenToView","_appendChild","domChild","viewChild","domSelectionToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","push","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","firstChild","getChild","documentFragmentOrElement","viewText","focus","viewEditable","domEditable","ownerDocument","activeElement","scrollX","scrollY","window","scrollPositions","forEachDomNodeAncestor","node","scrollLeft","scrollTop","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","isDomSelectionCorrect","_isDomSelectionPositionCorrect","data","some","includes","charAt","prevNode","_getTouchingViewTextNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextNode","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","test","getNext","treeWalker","startPosition","_createAfter","direction","item","topmostParent","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","acceptNode","FILTER_ACCEPT","FILTER_SKIP","currentNode","touchingNode","lca","types","boundaryParent","parents","slice","callback"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, INLINE_FILLER_LENGTH, isBlockFiller, isInlineFiller, startsWithFiller, getDataWithoutFiller } from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates DOM converter.\n\t *\n\t * @param {Object} options Object with configuration options.\n\t * @param {Function} [options.blockFiller=module:engine/view/filler~BR_FILLER] Block filler creator.\n\t */\n\tconstructor( options = {} ) {\n\t\t// Using WeakMap prevent memory leaks: when the converter will be destroyed all referenced between View and DOM\n\t\t// will be removed. Also because it is a *Weak*Map when both view and DOM elements will be removed referenced\n\t\t// will be also removed, isn't it brilliant?\n\t\t//\n\t\t// Yes, PJ. It is.\n\t\t//\n\t\t// You guys so smart.\n\t\t//\n\t\t// I've been here. Seen stuff. Afraid of code now.\n\n\t\t/**\n\t\t * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n\t\t * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Function} module:engine/view/domconverter~DomConverter#blockFiller\n\t\t */\n\t\tthis.blockFiller = options.blockFiller || BR_FILLER;\n\n\t\t/**\n\t\t * Tag names of DOM `Element`s which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Tag names of DOM `Element`s which are considered block elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6' ];\n\n\t\t/**\n\t\t * DOM to View mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View to DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\t}\n\n\t/**\n\t * Binds given DOM element that represents fake selection to {@link module:engine/view/documentselection~DocumentSelection\n\t * document selection}. Document selection copy is stored and can be retrieved by\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n\t * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and View elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement View element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * `domElement` will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\t// Use Array.from because of MS Edge (#923).\n\t\t\tfor ( const child of Array.from( domElement.childNodes ) ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\tdomElement = viewNode.render( domDocument );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tdomElement.setAttribute( key, viewNode.getAttribute( key ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this.blockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this.blockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( 'text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( isBlockFiller( domNode, this.blockFiller ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside UIElement return that UIElement as it's view representation.\n\t\tconst uiElement = this.getParentUIElement( domNode, this._domToViewMapping );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( textData );\n\t\t\t}\n\t\t} else if ( this.isComment( domNode ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tconst viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n\t\t\t\tviewElement = new ViewElement( viewName );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} domOffset DOM position offset.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset ) {\n\t\tif ( isBlockFiller( domParent, this.blockFiller ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && viewElement.is( 'uiElement' ) ) {\n\t\t\treturn ViewPosition._createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\treturn this.getParentUIElement( domElementOrDocumentFragment ) || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by UIElement - return that element.\n\t\tconst uiElement = this.getParentUIElement( domText );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n\t * parent UIElement.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|null}\n\t */\n\tgetParentUIElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && viewNode.is( 'uiElement' ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t * * before or in the middle of the inline filler sequence,\n\t * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n\t *\n\t * @param {Selection} domSelection DOM Selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n\t\t// also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\t\tif ( viewParent && viewParent.is( 'uiElement' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingViewTextNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n\t\t// next node (container element boundary).\n\t\t//\n\t\t// Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n\t\t//\n\t\t// Foo <span>&nbsp;bar</span>  <-- bad.\n\t\t// Foo&nbsp;<span> bar</span>  <-- good.\n\t\t//\n\t\t// More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingViewTextNode( node, true );\n\n\t\t\tif ( data.charAt( data.length - 2 ) == ' ' || !nextNode || nextNode.data.charAt( 0 ) == ' ' ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\t// 3. Create space+nbsp pairs.\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container\n\t * * nbsps are converted to spaces.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set –\n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\t\t//\n\t\t// Now, We will reverse the process that happens in `_processDataFromViewText`.\n\t\t//\n\t\t// We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\t// Then, let's change the last nbsp to a space.\n\t\tif ( /( |\\u00A0)\\u00A0$/.test( data ) || !nextNode || ( nextNode.data && nextNode.data.charAt( 0 ) == ' ' ) ) {\n\t\t\tdata = data.replace( /\\u00A0$/, ' ' );\n\t\t}\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldLeftTrimDomText( prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( isElement( prevNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @param {Node} node\n\t * @param {Node} nextNode\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingViewTextNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition._createAfter( node ) : ViewPosition._createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\tif ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found – it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( 'textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n\t * wasn't found so far, `null` is returned.\n\t *\n\t * In the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst direction = getNext ? 'nextNode' : 'previousNode';\n\t\tconst document = node.ownerDocument;\n\t\tconst topmostParent = getAncestors( node )[ 0 ];\n\n\t\tconst treeWalker = document.createTreeWalker( topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode( node ) {\n\t\t\t\tif ( isText( node ) ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\tif ( node.tagName == 'BR' ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t} );\n\n\t\ttreeWalker.currentNode = node;\n\n\t\tconst touchingNode = treeWalker[ direction ]();\n\n\t\tif ( touchingNode !== null ) {\n\t\t\tconst lca = getCommonAncestor( node, touchingNode );\n\n\t\t\t// If there is common ancestor between the text node and next/prev text node,\n\t\t\t// and there are no block elements on a way from the text node to that ancestor,\n\t\t\t// and there are no block elements on a way from next/prev text node to that ancestor...\n\t\t\tif (\n\t\t\t\tlca &&\n\t\t\t\t!_hasDomParentOfType( node, this.blockElements, lca ) &&\n\t\t\t\t!_hasDomParentOfType( touchingNode, this.blockElements, lca )\n\t\t\t) {\n\t\t\t\t// Then they are in the same container element.\n\t\t\t\treturn touchingNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types, boundaryParent ) {\n\tlet parents = getAncestors( node );\n\n\tif ( boundaryParent ) {\n\t\tparents = parents.slice( parents.indexOf( boundaryParent ) + 1 );\n\t}\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}