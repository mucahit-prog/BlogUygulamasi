{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-layout-post-fixer\n */\nimport { createEmptyTableCell, findAncestor, updateNumericAttribute } from './../commands/utils';\nimport TableWalker from './../tablewalker';\n/**\n * Injects a table layout post-fixer into the model.\n *\n * The role of the table layout post-fixer is to ensure that the table rows have the correct structure\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct structure means that:\n *\n * * All table rows have the same size.\n * * None of a table cells that extend vertically beyond their section (either header or body).\n * * A table cell has always at least one element as child.\n *\n * If the table structure is not correct, the post-fixer will automatically correct it in two steps:\n *\n * 1. It will clip table cells that extends beyond it section.\n * 2. It will add empty table cells to those rows which are narrower then the widest table row.\n *\n * ## Clipping overlapping table cells\n *\n * Such situation may occur when pasting a table (or part of a table) to the editor from external sources.\n *\n * For example, see the following table which has the cell (FOO) with the rowspan attribute (2):\n *\n *\t\t<table headingRows=\"1\">\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell rowspan=\"2\"><paragraph>FOO</paragraph></tableCell>\n *\t\t\t\t<tableCell colspan=\"2\"><paragraph>BAR</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph>BAZ</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>XYZ</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * will be rendered in the view as:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * In the above example the table will be rendered as a table with two rows - one in the header and second one in the body.\n * The table cell (FOO) cannot span over multiple rows as it would expand from the header to the body section.\n * The `rowspan` attribute must be changed to (1). The value (1) is a default value of the `rowspan` attribute\n * so the `rowspan` attribute will be removed from the model.\n *\n * The table cell with BAZ contents will be in the first column of the table.\n *\n * ## Adding missing table cells\n *\n * The table post-fixer will insert empty table cells to equalize table rows sizes (number of columns).\n * The size of a table row is calculated by counting column spans of table cells - both horizontal (from the same row) and\n * vertical (from rows above).\n *\n * In the above example, the table row in the body section of the table is narrower then the row from the header - it has two cells\n * with the default colspan (1). The header row has one cell with colspan (1) and second with colspan (2).\n * The table cell (FOO) does not expand beyond the head section (and as such will be fixed in the first step of this post-fixer).\n * The post-fixer will add a missing table cell to the row in the body section of the table.\n *\n * The table from the above example will be fixed and rendered to the view as below:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * ## Collaboration & Undo - Expectations vs post-fixer results\n *\n * The table post-fixer only ensures proper structure without deeper analysis of the nature of a change. As such, it might lead\n * to a structure which was not intended by the user changes. In particular, it will also fix undo steps (in conjunction with collaboration)\n * in which editor content might not return to the original state.\n *\n * This will usually happen when one or more users changes size of the table.\n *\n * As en example see a table below:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * and user actions:\n *\n * 1. Both user have table with two rows and two columns.\n * 2. User A adds a column at the end of the table - this will insert empty table cells to two rows.\n * 3. User B adds a row at the end of the table- this will insert a row with two empty table cells.\n * 4. Both users will have a table as below:\n *\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * The last row is shorter then others so table post-fixer will add empty row to tha last row:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * Unfortunately undo doesn't know the nature of changes and depending which user will apply post-fixer changes undoing them might lead to\n * broken table. If User B will undo inserting column to a table the undo engine will undo only operations of\n * inserting empty cells to rows from initial table state (row 1 & 2) but the cell in post-fixed row will remain:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * After undo the table post-fixer will detect that two rows are shorter then other and will fix table to:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n * @param {module:engine/model/model~Model} model\n */\n\nexport default function injectTableLayoutPostFixer(model) {\n  model.document.registerPostFixer(writer => tableLayoutPostFixer(writer, model));\n} // The table layout post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n\nfunction tableLayoutPostFixer(writer, model) {\n  const changes = model.document.differ.getChanges();\n  let wasFixed = false; // Do not analyze the same table more then once - may happen for multiple changes in the same table.\n\n  const analyzedTables = new Set();\n\n  for (const entry of changes) {\n    let table;\n\n    if (entry.name == 'table' && entry.type == 'insert') {\n      table = entry.position.nodeAfter;\n    } // Fix table on adding/removing table cells and rows.\n\n\n    if (entry.name == 'tableRow' || entry.name == 'tableCell') {\n      table = findAncestor('table', entry.position);\n    } // Fix table on any table's attribute change - including attributes of table cells.\n\n\n    if (isTableAttributeEntry(entry)) {\n      table = findAncestor('table', entry.range.start);\n    }\n\n    if (table && !analyzedTables.has(table)) {\n      // Step 1: correct rowspans of table cells if necessary.\n      // The wasFixed flag should be true if any of tables in batch was fixed - might be more then one.\n      wasFixed = fixTableCellsRowspan(table, writer) || wasFixed; // Step 2: fix table rows sizes.\n\n      wasFixed = fixTableRowsSizes(table, writer) || wasFixed;\n      analyzedTables.add(table);\n    }\n  }\n\n  return wasFixed;\n} // Fixes the invalid value of the rowspan attribute because a table cell cannot vertically extend beyond the table section it belongs to.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns true if table was fixed.\n\n\nfunction fixTableCellsRowspan(table, writer) {\n  let wasFixed = false;\n  const cellsToTrim = findCellsToTrim(table);\n\n  if (cellsToTrim.length) {\n    wasFixed = true;\n\n    for (const data of cellsToTrim) {\n      updateNumericAttribute('rowspan', data.rowspan, data.cell, writer, 1);\n    }\n  }\n\n  return wasFixed;\n} // Makes all table rows in a table the same size.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns true if table was fixed.\n\n\nfunction fixTableRowsSizes(table, writer) {\n  let wasFixed = false;\n  const rowsLengths = getRowsLengths(table);\n  const tableSize = rowsLengths[0];\n  const isValid = Object.values(rowsLengths).every(length => length === tableSize);\n\n  if (!isValid) {\n    const maxColumns = Object.values(rowsLengths).reduce((prev, current) => current > prev ? current : prev, 0);\n\n    for (const [rowIndex, size] of Object.entries(rowsLengths)) {\n      const columnsToInsert = maxColumns - size;\n\n      if (columnsToInsert) {\n        for (let i = 0; i < columnsToInsert; i++) {\n          createEmptyTableCell(writer, writer.createPositionAt(table.getChild(rowIndex), 'end'));\n        }\n\n        wasFixed = true;\n      }\n    }\n  }\n\n  return wasFixed;\n} // Searches for the table cells that extends beyond the table section to which they belong to. It will return an array of objects\n// that holds table cells to be trimmed and correct value of a rowspan attribute to set.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<{{cell, rowspan}}>}\n\n\nfunction findCellsToTrim(table) {\n  const headingRows = parseInt(table.getAttribute('headingRows') || 0);\n  const maxRows = table.childCount;\n  const cellsToTrim = [];\n\n  for (const {\n    row,\n    rowspan,\n    cell\n  } of new TableWalker(table)) {\n    // Skip cells that do not expand over its row.\n    if (rowspan < 2) {\n      continue;\n    }\n\n    const isInHeader = row < headingRows; // Row limit is either end of header section or whole table as table body is after the header.\n\n    const rowLimit = isInHeader ? headingRows : maxRows; // If table cell expands over its limit reduce it height to proper value.\n\n    if (row + rowspan > rowLimit) {\n      const newRowspan = rowLimit - row;\n      cellsToTrim.push({\n        cell,\n        rowspan: newRowspan\n      });\n    }\n  }\n\n  return cellsToTrim;\n} // Returns an object with lengths of rows assigned to the corresponding row index.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Object}\n\n\nfunction getRowsLengths(table) {\n  const lengths = {};\n\n  for (const {\n    row\n  } of new TableWalker(table, {\n    includeSpanned: true\n  })) {\n    if (!lengths[row]) {\n      lengths[row] = 0;\n    }\n\n    lengths[row] += 1;\n  }\n\n  return lengths;\n} // Checks if the differ entry for an attribute change is one of table's attributes.\n//\n// @param entry\n// @returns {Boolean}\n\n\nfunction isTableAttributeEntry(entry) {\n  const isAttributeType = entry.type === 'attribute';\n  const key = entry.attributeKey;\n  return isAttributeType && (key === 'headingRows' || key === 'colspan' || key === 'rowspan');\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/converters/table-layout-post-fixer.js"],"names":["createEmptyTableCell","findAncestor","updateNumericAttribute","TableWalker","injectTableLayoutPostFixer","model","document","registerPostFixer","writer","tableLayoutPostFixer","changes","differ","getChanges","wasFixed","analyzedTables","Set","entry","table","name","type","position","nodeAfter","isTableAttributeEntry","range","start","has","fixTableCellsRowspan","fixTableRowsSizes","add","cellsToTrim","findCellsToTrim","length","data","rowspan","cell","rowsLengths","getRowsLengths","tableSize","isValid","Object","values","every","maxColumns","reduce","prev","current","rowIndex","size","entries","columnsToInsert","i","createPositionAt","getChild","headingRows","parseInt","getAttribute","maxRows","childCount","row","isInHeader","rowLimit","newRowspan","push","lengths","includeSpanned","isAttributeType","key","attributeKey"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA,SAASA,oBAAT,EAA+BC,YAA/B,EAA6CC,sBAA7C,QAA2E,qBAA3E;AACA,OAAOC,WAAP,MAAwB,kBAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,0BAAT,CAAqCC,KAArC,EAA6C;AAC3DA,EAAAA,KAAK,CAA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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/table-layout-post-fixer\n */\n\nimport { createEmptyTableCell, findAncestor, updateNumericAttribute } from './../commands/utils';\nimport TableWalker from './../tablewalker';\n\n/**\n * Injects a table layout post-fixer into the model.\n *\n * The role of the table layout post-fixer is to ensure that the table rows have the correct structure\n * after a {@link module:engine/model/model~Model#change `change()`} block was executed.\n *\n * The correct structure means that:\n *\n * * All table rows have the same size.\n * * None of a table cells that extend vertically beyond their section (either header or body).\n * * A table cell has always at least one element as child.\n *\n * If the table structure is not correct, the post-fixer will automatically correct it in two steps:\n *\n * 1. It will clip table cells that extends beyond it section.\n * 2. It will add empty table cells to those rows which are narrower then the widest table row.\n *\n * ## Clipping overlapping table cells\n *\n * Such situation may occur when pasting a table (or part of a table) to the editor from external sources.\n *\n * For example, see the following table which has the cell (FOO) with the rowspan attribute (2):\n *\n *\t\t<table headingRows=\"1\">\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell rowspan=\"2\"><paragraph>FOO</paragraph></tableCell>\n *\t\t\t\t<tableCell colspan=\"2\"><paragraph>BAR</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph>BAZ</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>XYZ</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * will be rendered in the view as:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * In the above example the table will be rendered as a table with two rows - one in the header and second one in the body.\n * The table cell (FOO) cannot span over multiple rows as it would expand from the header to the body section.\n * The `rowspan` attribute must be changed to (1). The value (1) is a default value of the `rowspan` attribute\n * so the `rowspan` attribute will be removed from the model.\n *\n * The table cell with BAZ contents will be in the first column of the table.\n *\n * ## Adding missing table cells\n *\n * The table post-fixer will insert empty table cells to equalize table rows sizes (number of columns).\n * The size of a table row is calculated by counting column spans of table cells - both horizontal (from the same row) and\n * vertical (from rows above).\n *\n * In the above example, the table row in the body section of the table is narrower then the row from the header - it has two cells\n * with the default colspan (1). The header row has one cell with colspan (1) and second with colspan (2).\n * The table cell (FOO) does not expand beyond the head section (and as such will be fixed in the first step of this post-fixer).\n * The post-fixer will add a missing table cell to the row in the body section of the table.\n *\n * The table from the above example will be fixed and rendered to the view as below:\n *\n *\t\t<table>\n *\t\t\t<thead>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td rowspan=\"2\">FOO</td>\n *\t\t\t\t\t<td colspan=\"2\">BAR</td>\n *\t\t\t\t</tr>\n *\t\t\t</thead>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>BAZ</td>\n *\t\t\t\t\t<td>XYZ</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * ## Collaboration & Undo - Expectations vs post-fixer results\n *\n * The table post-fixer only ensures proper structure without deeper analysis of the nature of a change. As such, it might lead\n * to a structure which was not intended by the user changes. In particular, it will also fix undo steps (in conjunction with collaboration)\n * in which editor content might not return to the original state.\n *\n * This will usually happen when one or more users changes size of the table.\n *\n * As en example see a table below:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * and user actions:\n *\n * 1. Both user have table with two rows and two columns.\n * 2. User A adds a column at the end of the table - this will insert empty table cells to two rows.\n * 3. User B adds a row at the end of the table- this will insert a row with two empty table cells.\n * 4. Both users will have a table as below:\n *\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * The last row is shorter then others so table post-fixer will add empty row to tha last row:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by A)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * Unfortunately undo doesn't know the nature of changes and depending which user will apply post-fixer changes undoing them might lead to\n * broken table. If User B will undo inserting column to a table the undo engine will undo only operations of\n * inserting empty cells to rows from initial table state (row 1 & 2) but the cell in post-fixed row will remain:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n *\n * After undo the table post-fixer will detect that two rows are shorter then other and will fix table to:\n *\n *\t\t<table>\n *\t\t\t<tbody>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>11</td>\n *\t\t\t\t\t<td>12</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>21</td>\n *\t\t\t\t\t<td>22</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer after undo)</td>\n *\t\t\t\t</tr>\n *\t\t\t\t<tr>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by B)</td>\n *\t\t\t\t\t<td>(empty, inserted by a post-fixer)</td>\n *\t\t\t\t</tr>\n *\t\t\t</tbody>\n *\t\t</table>\n * @param {module:engine/model/model~Model} model\n */\nexport default function injectTableLayoutPostFixer( model ) {\n\tmodel.document.registerPostFixer( writer => tableLayoutPostFixer( writer, model ) );\n}\n\n// The table layout post-fixer.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\nfunction tableLayoutPostFixer( writer, model ) {\n\tconst changes = model.document.differ.getChanges();\n\n\tlet wasFixed = false;\n\n\t// Do not analyze the same table more then once - may happen for multiple changes in the same table.\n\tconst analyzedTables = new Set();\n\n\tfor ( const entry of changes ) {\n\t\tlet table;\n\n\t\tif ( entry.name == 'table' && entry.type == 'insert' ) {\n\t\t\ttable = entry.position.nodeAfter;\n\t\t}\n\n\t\t// Fix table on adding/removing table cells and rows.\n\t\tif ( entry.name == 'tableRow' || entry.name == 'tableCell' ) {\n\t\t\ttable = findAncestor( 'table', entry.position );\n\t\t}\n\n\t\t// Fix table on any table's attribute change - including attributes of table cells.\n\t\tif ( isTableAttributeEntry( entry ) ) {\n\t\t\ttable = findAncestor( 'table', entry.range.start );\n\t\t}\n\n\t\tif ( table && !analyzedTables.has( table ) ) {\n\t\t\t// Step 1: correct rowspans of table cells if necessary.\n\t\t\t// The wasFixed flag should be true if any of tables in batch was fixed - might be more then one.\n\t\t\twasFixed = fixTableCellsRowspan( table, writer ) || wasFixed;\n\t\t\t// Step 2: fix table rows sizes.\n\t\t\twasFixed = fixTableRowsSizes( table, writer ) || wasFixed;\n\n\t\t\tanalyzedTables.add( table );\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Fixes the invalid value of the rowspan attribute because a table cell cannot vertically extend beyond the table section it belongs to.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns true if table was fixed.\nfunction fixTableCellsRowspan( table, writer ) {\n\tlet wasFixed = false;\n\n\tconst cellsToTrim = findCellsToTrim( table );\n\n\tif ( cellsToTrim.length ) {\n\t\twasFixed = true;\n\n\t\tfor ( const data of cellsToTrim ) {\n\t\t\tupdateNumericAttribute( 'rowspan', data.rowspan, data.cell, writer, 1 );\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Makes all table rows in a table the same size.\n//\n// @param {module:engine/model/element~Element} table\n// @param {module:engine/model/writer~Writer} writer\n// @returns {Boolean} Returns true if table was fixed.\nfunction fixTableRowsSizes( table, writer ) {\n\tlet wasFixed = false;\n\n\tconst rowsLengths = getRowsLengths( table );\n\tconst tableSize = rowsLengths[ 0 ];\n\n\tconst isValid = Object.values( rowsLengths ).every( length => length === tableSize );\n\n\tif ( !isValid ) {\n\t\tconst maxColumns = Object.values( rowsLengths ).reduce( ( prev, current ) => current > prev ? current : prev, 0 );\n\n\t\tfor ( const [ rowIndex, size ] of Object.entries( rowsLengths ) ) {\n\t\t\tconst columnsToInsert = maxColumns - size;\n\n\t\t\tif ( columnsToInsert ) {\n\t\t\t\tfor ( let i = 0; i < columnsToInsert; i++ ) {\n\t\t\t\t\tcreateEmptyTableCell( writer, writer.createPositionAt( table.getChild( rowIndex ), 'end' ) );\n\t\t\t\t}\n\n\t\t\t\twasFixed = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn wasFixed;\n}\n\n// Searches for the table cells that extends beyond the table section to which they belong to. It will return an array of objects\n// that holds table cells to be trimmed and correct value of a rowspan attribute to set.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Array.<{{cell, rowspan}}>}\nfunction findCellsToTrim( table ) {\n\tconst headingRows = parseInt( table.getAttribute( 'headingRows' ) || 0 );\n\tconst maxRows = table.childCount;\n\n\tconst cellsToTrim = [];\n\n\tfor ( const { row, rowspan, cell } of new TableWalker( table ) ) {\n\t\t// Skip cells that do not expand over its row.\n\t\tif ( rowspan < 2 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst isInHeader = row < headingRows;\n\n\t\t// Row limit is either end of header section or whole table as table body is after the header.\n\t\tconst rowLimit = isInHeader ? headingRows : maxRows;\n\n\t\t// If table cell expands over its limit reduce it height to proper value.\n\t\tif ( row + rowspan > rowLimit ) {\n\t\t\tconst newRowspan = rowLimit - row;\n\n\t\t\tcellsToTrim.push( { cell, rowspan: newRowspan } );\n\t\t}\n\t}\n\n\treturn cellsToTrim;\n}\n\n// Returns an object with lengths of rows assigned to the corresponding row index.\n//\n// @param {module:engine/model/element~Element} table\n// @returns {Object}\nfunction getRowsLengths( table ) {\n\tconst lengths = {};\n\n\tfor ( const { row } of new TableWalker( table, { includeSpanned: true } ) ) {\n\t\tif ( !lengths[ row ] ) {\n\t\t\tlengths[ row ] = 0;\n\t\t}\n\n\t\tlengths[ row ] += 1;\n\t}\n\n\treturn lengths;\n}\n\n// Checks if the differ entry for an attribute change is one of table's attributes.\n//\n// @param entry\n// @returns {Boolean}\nfunction isTableAttributeEntry( entry ) {\n\tconst isAttributeType = entry.type === 'attribute';\n\tconst key = entry.attributeKey;\n\n\treturn isAttributeType && ( key === 'headingRows' || key === 'colspan' || key === 'rowspan' );\n}\n"]},"metadata":{},"sourceType":"module"}