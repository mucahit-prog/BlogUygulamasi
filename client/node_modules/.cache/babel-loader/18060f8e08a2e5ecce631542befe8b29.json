{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/setheaderrowcommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport { createEmptyTableCell, findAncestor, updateNumericAttribute } from './utils';\nimport TableWalker from '../tablewalker';\n/**\n * The header row command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'setTableColumnHeader'` editor command.\n *\n * You can make the row containing the selected cell a [header](https://www.w3.org/TR/html50/tabular-data.html#the-th-element) by executing:\n *\n *\t\teditor.execute( 'setTableRowHeader' );\n *\n * **Note:** All preceding rows will also become headers. If the current row is already a header, executing this command\n * will make it a regular row back again (including the following rows).\n *\n * @extends module:core/command~Command\n */\n\nexport default class SetHeaderRowCommand extends Command {\n  /**\n   * @inheritDoc\n   */\n  refresh() {\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const position = selection.getFirstPosition();\n    const tableCell = findAncestor('tableCell', position);\n    const isInTable = !!tableCell;\n    this.isEnabled = isInTable;\n    /**\n     * Flag indicating whether the command is active. The command is active when the\n     * {@link module:engine/model/selection~Selection} is in a header row.\n     *\n     * @observable\n     * @readonly\n     * @member {Boolean} #value\n     */\n\n    this.value = isInTable && this._isInHeading(tableCell, tableCell.parent.parent);\n  }\n  /**\n   * Executes the command.\n   *\n   * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.\n   *\n   * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.\n   *\n   * @fires execute\n   */\n\n\n  execute() {\n    const model = this.editor.model;\n    const doc = model.document;\n    const selection = doc.selection;\n    const position = selection.getFirstPosition();\n    const tableCell = findAncestor('tableCell', position);\n    const tableRow = tableCell.parent;\n    const table = tableRow.parent;\n    const currentHeadingRows = table.getAttribute('headingRows') || 0;\n    const selectionRow = tableRow.index;\n    const headingRowsToSet = currentHeadingRows > selectionRow ? selectionRow : selectionRow + 1;\n    model.change(writer => {\n      if (headingRowsToSet) {\n        // Changing heading rows requires to check if any of a heading cell is overlapping vertically the table head.\n        // Any table cell that has a rowspan attribute > 1 will not exceed the table head so we need to fix it in rows below.\n        const cellsToSplit = getOverlappingCells(table, headingRowsToSet, currentHeadingRows);\n\n        for (const cell of cellsToSplit) {\n          splitHorizontally(cell, headingRowsToSet, writer);\n        }\n      }\n\n      updateNumericAttribute('headingRows', headingRowsToSet, table, writer, 0);\n    });\n  }\n  /**\n   * Checks if a table cell is in the heading section.\n   *\n   * @param {module:engine/model/element~Element} tableCell\n   * @param {module:engine/model/element~Element} table\n   * @returns {Boolean}\n   * @private\n   */\n\n\n  _isInHeading(tableCell, table) {\n    const headingRows = parseInt(table.getAttribute('headingRows') || 0);\n    return !!headingRows && tableCell.parent.index < headingRows;\n  }\n\n} // Returns cells that span beyond the new heading section.\n//\n// @param {module:engine/model/element~Element} table The table to check.\n// @param {Number} headingRowsToSet New heading rows attribute.\n// @param {Number} currentHeadingRows Current heading rows attribute.\n// @returns {Array.<module:engine/model/element~Element>}\n\nfunction getOverlappingCells(table, headingRowsToSet, currentHeadingRows) {\n  const cellsToSplit = [];\n  const startAnalysisRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0; // We're analyzing only when headingRowsToSet > 0.\n\n  const endAnalysisRow = headingRowsToSet - 1;\n  const tableWalker = new TableWalker(table, {\n    startRow: startAnalysisRow,\n    endRow: endAnalysisRow\n  });\n\n  for (const {\n    row,\n    rowspan,\n    cell\n  } of tableWalker) {\n    if (rowspan > 1 && row + rowspan > headingRowsToSet) {\n      cellsToSplit.push(cell);\n    }\n  }\n\n  return cellsToSplit;\n} // Splits the table cell horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {Number} headingRows\n// @param {module:engine/model/writer~Writer} writer\n\n\nfunction splitHorizontally(tableCell, headingRows, writer) {\n  const tableRow = tableCell.parent;\n  const table = tableRow.parent;\n  const rowIndex = tableRow.index;\n  const rowspan = parseInt(tableCell.getAttribute('rowspan'));\n  const newRowspan = headingRows - rowIndex;\n  const attributes = {};\n  const spanToSet = rowspan - newRowspan;\n\n  if (spanToSet > 1) {\n    attributes.rowspan = spanToSet;\n  }\n\n  const startRow = table.getChildIndex(tableRow);\n  const endRow = startRow + newRowspan;\n  const tableMap = [...new TableWalker(table, {\n    startRow,\n    endRow,\n    includeSpanned: true\n  })];\n  let columnIndex;\n\n  for (const {\n    row,\n    column,\n    cell,\n    colspan,\n    cellIndex\n  } of tableMap) {\n    if (cell === tableCell) {\n      columnIndex = column;\n\n      if (colspan > 1) {\n        attributes.colspan = colspan;\n      }\n    }\n\n    if (columnIndex !== undefined && columnIndex === column && row === endRow) {\n      const tableRow = table.getChild(row);\n      const tableCellPosition = writer.createPositionAt(tableRow, cellIndex);\n      createEmptyTableCell(writer, tableCellPosition, attributes);\n    }\n  } // Update the rowspan attribute after updating table.\n\n\n  updateNumericAttribute('rowspan', newRowspan, tableCell, writer);\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/commands/setheaderrowcommand.js"],"names":["Command","createEmptyTableCell","findAncestor","updateNumericAttribute","TableWalker","SetHeaderRowCommand","refresh","model","editor","doc","document","selection","position","getFirstPosition","tableCell","isInTable","isEnabled","value","_isInHeading","parent","execute","tableRow","table","currentHeadingRows","getAttribute","selectionRow","index","headingRowsToSet","change","writer","cellsToSplit","getOverlappingCells","cell","splitHorizontally","headingRows","parseInt","startAnalysisRow","endAnalysisRow","tableWalker","startRow","endRow","row","rowspan","push","rowIndex","newRowspan","attributes","spanToSet","getChildIndex","tableMap","includeSpanned","columnIndex","column","colspan","cellIndex","undefined","getChild","tableCellPosition","createPositionAt"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/commands/setheaderrowcommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\nimport { createEmptyTableCell, findAncestor, updateNumericAttribute } from './utils';\nimport TableWalker from '../tablewalker';\n\n/**\n * The header row command.\n *\n * The command is registered by {@link module:table/tableediting~TableEditing} as `'setTableColumnHeader'` editor command.\n *\n * You can make the row containing the selected cell a [header](https://www.w3.org/TR/html50/tabular-data.html#the-th-element) by executing:\n *\n *\t\teditor.execute( 'setTableRowHeader' );\n *\n * **Note:** All preceding rows will also become headers. If the current row is already a header, executing this command\n * will make it a regular row back again (including the following rows).\n *\n * @extends module:core/command~Command\n */\nexport default class SetHeaderRowCommand extends Command {\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\n\t\tconst position = selection.getFirstPosition();\n\t\tconst tableCell = findAncestor( 'tableCell', position );\n\t\tconst isInTable = !!tableCell;\n\n\t\tthis.isEnabled = isInTable;\n\n\t\t/**\n\t\t * Flag indicating whether the command is active. The command is active when the\n\t\t * {@link module:engine/model/selection~Selection} is in a header row.\n\t\t *\n\t\t * @observable\n\t\t * @readonly\n\t\t * @member {Boolean} #value\n\t\t */\n\t\tthis.value = isInTable && this._isInHeading( tableCell, tableCell.parent.parent );\n\t}\n\n\t/**\n\t * Executes the command.\n\t *\n\t * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.\n\t *\n\t * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.\n\t *\n\t * @fires execute\n\t */\n\texecute() {\n\t\tconst model = this.editor.model;\n\t\tconst doc = model.document;\n\t\tconst selection = doc.selection;\n\n\t\tconst position = selection.getFirstPosition();\n\t\tconst tableCell = findAncestor( 'tableCell', position );\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst currentHeadingRows = table.getAttribute( 'headingRows' ) || 0;\n\t\tconst selectionRow = tableRow.index;\n\n\t\tconst headingRowsToSet = currentHeadingRows > selectionRow ? selectionRow : selectionRow + 1;\n\n\t\tmodel.change( writer => {\n\t\t\tif ( headingRowsToSet ) {\n\t\t\t\t// Changing heading rows requires to check if any of a heading cell is overlapping vertically the table head.\n\t\t\t\t// Any table cell that has a rowspan attribute > 1 will not exceed the table head so we need to fix it in rows below.\n\t\t\t\tconst cellsToSplit = getOverlappingCells( table, headingRowsToSet, currentHeadingRows );\n\n\t\t\t\tfor ( const cell of cellsToSplit ) {\n\t\t\t\t\tsplitHorizontally( cell, headingRowsToSet, writer );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateNumericAttribute( 'headingRows', headingRowsToSet, table, writer, 0 );\n\t\t} );\n\t}\n\n\t/**\n\t * Checks if a table cell is in the heading section.\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {module:engine/model/element~Element} table\n\t * @returns {Boolean}\n\t * @private\n\t */\n\t_isInHeading( tableCell, table ) {\n\t\tconst headingRows = parseInt( table.getAttribute( 'headingRows' ) || 0 );\n\n\t\treturn !!headingRows && tableCell.parent.index < headingRows;\n\t}\n}\n\n// Returns cells that span beyond the new heading section.\n//\n// @param {module:engine/model/element~Element} table The table to check.\n// @param {Number} headingRowsToSet New heading rows attribute.\n// @param {Number} currentHeadingRows Current heading rows attribute.\n// @returns {Array.<module:engine/model/element~Element>}\nfunction getOverlappingCells( table, headingRowsToSet, currentHeadingRows ) {\n\tconst cellsToSplit = [];\n\n\tconst startAnalysisRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0;\n\t// We're analyzing only when headingRowsToSet > 0.\n\tconst endAnalysisRow = headingRowsToSet - 1;\n\n\tconst tableWalker = new TableWalker( table, { startRow: startAnalysisRow, endRow: endAnalysisRow } );\n\n\tfor ( const { row, rowspan, cell } of tableWalker ) {\n\t\tif ( rowspan > 1 && row + rowspan > headingRowsToSet ) {\n\t\t\tcellsToSplit.push( cell );\n\t\t}\n\t}\n\n\treturn cellsToSplit;\n}\n\n// Splits the table cell horizontally.\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {Number} headingRows\n// @param {module:engine/model/writer~Writer} writer\nfunction splitHorizontally( tableCell, headingRows, writer ) {\n\tconst tableRow = tableCell.parent;\n\tconst table = tableRow.parent;\n\tconst rowIndex = tableRow.index;\n\n\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) );\n\tconst newRowspan = headingRows - rowIndex;\n\n\tconst attributes = {};\n\n\tconst spanToSet = rowspan - newRowspan;\n\n\tif ( spanToSet > 1 ) {\n\t\tattributes.rowspan = spanToSet;\n\t}\n\n\tconst startRow = table.getChildIndex( tableRow );\n\tconst endRow = startRow + newRowspan;\n\tconst tableMap = [ ...new TableWalker( table, { startRow, endRow, includeSpanned: true } ) ];\n\n\tlet columnIndex;\n\n\tfor ( const { row, column, cell, colspan, cellIndex } of tableMap ) {\n\t\tif ( cell === tableCell ) {\n\t\t\tcolumnIndex = column;\n\n\t\t\tif ( colspan > 1 ) {\n\t\t\t\tattributes.colspan = colspan;\n\t\t\t}\n\t\t}\n\n\t\tif ( columnIndex !== undefined && columnIndex === column && row === endRow ) {\n\t\t\tconst tableRow = table.getChild( row );\n\t\t\tconst tableCellPosition = writer.createPositionAt( tableRow, cellIndex );\n\n\t\t\tcreateEmptyTableCell( writer, tableCellPosition, attributes );\n\t\t}\n\t}\n\n\t// Update the rowspan attribute after updating table.\n\tupdateNumericAttribute( 'rowspan', newRowspan, tableCell, writer );\n}\n"]},"metadata":{},"sourceType":"module"}