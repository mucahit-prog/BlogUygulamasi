{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {module:engine/model/batch~Batch} batch Batch to which the operations will be added.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n *\n * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n */\n\nexport default function deleteContent(model, selection, options = {}) {\n  if (selection.isCollapsed) {\n    return;\n  }\n\n  const selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.\n\n  if (selRange.root.rootName == '$graveyard') {\n    return;\n  }\n\n  const schema = model.schema;\n  model.change(writer => {\n    // 1. Replace the entire content with paragraph.\n    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {\n      replaceEntireContentWithParagraph(writer, selection, schema);\n      return;\n    }\n\n    const startPos = selRange.start;\n    const endPos = LivePosition.fromPosition(selRange.end, 'toNext'); // 2. Remove the content if there is any.\n\n    if (!selRange.start.isTouching(selRange.end)) {\n      writer.remove(selRange);\n    } // 3. Merge elements in the right branch to the elements in the left branch.\n    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n    //\n    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n    //\n    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n    // want to override that behavior anyway.\n\n\n    if (!options.leaveUnmerged) {\n      mergeBranches(writer, startPos, endPos); // TMP this will be replaced with a postfixer.\n      // We need to check and strip disallowed attributes in all nested nodes because after merge\n      // some attributes could end up in a path where are disallowed.\n      //\n      // e.g. bold is disallowed for <H1>\n      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\n      schema.removeDisallowedAttributes(startPos.parent.getChildren(), writer);\n    }\n\n    collapseSelectionAt(writer, selection, startPos); // 4. Add a paragraph to set selection in it.\n    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\n    if (shouldAutoparagraph(schema, startPos)) {\n      // If auto-paragraphing is off, find the closest valid selection range and collapse the selection there.\n      // If there is no valid selection range, create paragraph anyway and set selection there.\n      const validSelectionRange = schema.getNearestSelectionRange(startPos);\n\n      if (options.doNotAutoparagraph && validSelectionRange) {\n        collapseSelectionAt(writer, selection, validSelectionRange);\n      } else {\n        insertParagraph(writer, startPos, selection);\n      }\n    }\n\n    endPos.detach();\n  });\n} // This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\n\nfunction mergeBranches(writer, startPos, endPos) {\n  const startParent = startPos.parent;\n  const endParent = endPos.parent; // If both positions ended up in the same parent, then there's nothing more to merge:\n  // <$root><p>x[]</p><p>{}y</p></$root> => <$root><p>xy</p>[]{}</$root>\n\n  if (startParent == endParent) {\n    return;\n  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\n\n  if (writer.model.schema.isLimit(startParent) || writer.model.schema.isLimit(endParent)) {\n    return;\n  } // Check if operations we'll need to do won't need to cross object or limit boundaries.\n  // E.g., we can't merge endParent into startParent in this case:\n  // <limit><startParent>x[]</startParent></limit><endParent>{}</endParent>\n\n\n  if (!checkCanBeMerged(startPos, endPos, writer.model.schema)) {\n    return;\n  } // Remember next positions to merge. For example:\n  // <a><b>x[]</b></a><c><d>{}y</d></c>\n  // will become:\n  // <a><b>xy</b>[]</a><c>{}</c>\n\n\n  startPos = writer.createPositionAfter(startParent);\n  endPos = writer.createPositionBefore(endParent);\n\n  if (!endPos.isEqual(startPos)) {\n    // In this case, before we merge, we need to move `endParent` to the `startPos`:\n    // <a><b>x[]</b></a><c><d>{}y</d></c>\n    // becomes:\n    // <a><b>x</b>[]<d>y</d></a><c>{}</c>\n    writer.insert(endParent, startPos);\n  } // Merge two siblings:\n  // <a>x</a>[]<b>y</b> -> <a>xy</a> (the usual case)\n  // <a><b>x</b>[]<d>y</d></a><c></c> -> <a><b>xy</b>[]</a><c></c> (this is the \"move parent\" case shown above)\n\n\n  writer.merge(startPos); // Remove empty end ancestors:\n  // <a>fo[o</a><b><a><c>bar]</c></a></b>\n  // becomes:\n  // <a>fo[]</a><b><a>{}</a></b>\n  // So we can remove <a> and <b>.\n\n  while (endPos.parent.isEmpty) {\n    const parentToRemove = endPos.parent;\n    endPos = writer.createPositionBefore(parentToRemove);\n    writer.remove(parentToRemove);\n  } // Continue merging next level.\n\n\n  mergeBranches(writer, startPos, endPos);\n}\n\nfunction shouldAutoparagraph(schema, position) {\n  const isTextAllowed = schema.checkChild(position, '$text');\n  const isParagraphAllowed = schema.checkChild(position, 'paragraph');\n  return !isTextAllowed && isParagraphAllowed;\n} // Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\n\n\nfunction checkCanBeMerged(leftPos, rightPos, schema) {\n  const rangeToCheck = new Range(leftPos, rightPos);\n\n  for (const value of rangeToCheck.getWalker()) {\n    if (schema.isLimit(value.item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction insertParagraph(writer, position, selection) {\n  const paragraph = writer.createElement('paragraph');\n  writer.insert(paragraph, position);\n  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));\n}\n\nfunction replaceEntireContentWithParagraph(writer, selection) {\n  const limitElement = writer.model.schema.getLimitElement(selection);\n  writer.remove(writer.createRangeIn(limitElement));\n  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);\n} // We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\n\n\nfunction shouldEntireContentBeReplacedWithParagraph(schema, selection) {\n  const limitElement = schema.getLimitElement(selection);\n\n  if (!selection.containsEntireContent(limitElement)) {\n    return false;\n  }\n\n  const range = selection.getFirstRange();\n\n  if (range.start.parent == range.end.parent) {\n    return false;\n  }\n\n  return schema.checkChild(limitElement, 'paragraph');\n} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\n\n\nfunction collapseSelectionAt(writer, selection, positionOrRange) {\n  if (selection instanceof DocumentSelection) {\n    writer.setSelection(positionOrRange);\n  } else {\n    selection.setTo(positionOrRange);\n  }\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js"],"names":["LivePosition","Range","DocumentSelection","deleteContent","model","selection","options","isCollapsed","selRange","getFirstRange","root","rootName","schema","change","writer","doNotResetEntireContent","shouldEntireContentBeReplacedWithParagraph","replaceEntireContentWithParagraph","startPos","start","endPos","fromPosition","end","isTouching","remove","leaveUnmerged","mergeBranches","removeDisallowedAttributes","parent","getChildren","collapseSelectionAt","shouldAutoparagraph","validSelectionRange","getNearestSelectionRange","doNotAutoparagraph","insertParagraph","detach","startParent","endParent","isLimit","checkCanBeMerged","createPositionAfter","createPositionBefore","isEqual","insert","merge","isEmpty","parentToRemove","position","isTextAllowed","checkChild","isParagraphAllowed","leftPos","rightPos","rangeToCheck","value","getWalker","item","paragraph","createElement","createPositionAt","limitElement","getLimitElement","createRangeIn","containsEntireContent","range","positionOrRange","setSelection","setTo"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/utils/deletecontent\n */\n\nimport LivePosition from '../liveposition';\nimport Range from '../range';\nimport DocumentSelection from '../documentselection';\n\n/**\n * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n *\n * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.\n * This function is only exposed to be reusable in algorithms\n * which change the {@link module:engine/model/model~Model#deleteContent}\n * method's behavior.\n *\n * @param {module:engine/model/model~Model} model The model in context of which the insertion\n * should be performed.\n * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n * Selection of which the content should be deleted.\n * @param {module:engine/model/batch~Batch} batch Batch to which the operations will be added.\n * @param {Object} [options]\n * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n *\n * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:\n *\n * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)\n * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n *\n * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n * elements will not be merged.\n *\n * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n * paragraph when the entire content was selected.\n *\n * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:\n *\n * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).\n *\n * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n * to a place where text cannot be inserted.\n *\n * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n *\n * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n *\n * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n *\n * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n */\nexport default function deleteContent( model, selection, options = {} ) {\n\tif ( selection.isCollapsed ) {\n\t\treturn;\n\t}\n\n\tconst selRange = selection.getFirstRange();\n\n\t// If the selection is already removed, don't do anything.\n\tif ( selRange.root.rootName == '$graveyard' ) {\n\t\treturn;\n\t}\n\n\tconst schema = model.schema;\n\n\tmodel.change( writer => {\n\t\t// 1. Replace the entire content with paragraph.\n\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.\n\t\tif ( !options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph( schema, selection ) ) {\n\t\t\treplaceEntireContentWithParagraph( writer, selection, schema );\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst startPos = selRange.start;\n\t\tconst endPos = LivePosition.fromPosition( selRange.end, 'toNext' );\n\n\t\t// 2. Remove the content if there is any.\n\t\tif ( !selRange.start.isTouching( selRange.end ) ) {\n\t\t\twriter.remove( selRange );\n\t\t}\n\n\t\t// 3. Merge elements in the right branch to the elements in the left branch.\n\t\t// The only reasonable (in terms of data and selection correctness) case in which we need to do that is:\n\t\t//\n\t\t// <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>\n\t\t//\n\t\t// However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),\n\t\t// as it's hard to imagine what should actually be the default behavior. Usually, specific features will\n\t\t// want to override that behavior anyway.\n\t\tif ( !options.leaveUnmerged ) {\n\t\t\tmergeBranches( writer, startPos, endPos );\n\n\t\t\t// TMP this will be replaced with a postfixer.\n\t\t\t// We need to check and strip disallowed attributes in all nested nodes because after merge\n\t\t\t// some attributes could end up in a path where are disallowed.\n\t\t\t//\n\t\t\t// e.g. bold is disallowed for <H1>\n\t\t\t// <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.\n\t\t\tschema.removeDisallowedAttributes( startPos.parent.getChildren(), writer );\n\t\t}\n\n\t\tcollapseSelectionAt( writer, selection, startPos );\n\n\t\t// 4. Add a paragraph to set selection in it.\n\t\t// Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).\n\t\tif ( shouldAutoparagraph( schema, startPos ) ) {\n\t\t\t// If auto-paragraphing is off, find the closest valid selection range and collapse the selection there.\n\t\t\t// If there is no valid selection range, create paragraph anyway and set selection there.\n\t\t\tconst validSelectionRange = schema.getNearestSelectionRange( startPos );\n\n\t\t\tif ( options.doNotAutoparagraph && validSelectionRange ) {\n\t\t\t\tcollapseSelectionAt( writer, selection, validSelectionRange );\n\t\t\t} else {\n\t\t\t\tinsertParagraph( writer, startPos, selection );\n\t\t\t}\n\t\t}\n\n\t\tendPos.detach();\n\t} );\n}\n\n// This function is a result of reaching the Ballmer's peak for just the right amount of time.\n// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.\nfunction mergeBranches( writer, startPos, endPos ) {\n\tconst startParent = startPos.parent;\n\tconst endParent = endPos.parent;\n\n\t// If both positions ended up in the same parent, then there's nothing more to merge:\n\t// <$root><p>x[]</p><p>{}y</p></$root> => <$root><p>xy</p>[]{}</$root>\n\tif ( startParent == endParent ) {\n\t\treturn;\n\t}\n\n\t// If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.\n\tif ( writer.model.schema.isLimit( startParent ) || writer.model.schema.isLimit( endParent ) ) {\n\t\treturn;\n\t}\n\n\t// Check if operations we'll need to do won't need to cross object or limit boundaries.\n\t// E.g., we can't merge endParent into startParent in this case:\n\t// <limit><startParent>x[]</startParent></limit><endParent>{}</endParent>\n\tif ( !checkCanBeMerged( startPos, endPos, writer.model.schema ) ) {\n\t\treturn;\n\t}\n\n\t// Remember next positions to merge. For example:\n\t// <a><b>x[]</b></a><c><d>{}y</d></c>\n\t// will become:\n\t// <a><b>xy</b>[]</a><c>{}</c>\n\tstartPos = writer.createPositionAfter( startParent );\n\tendPos = writer.createPositionBefore( endParent );\n\n\tif ( !endPos.isEqual( startPos ) ) {\n\t\t// In this case, before we merge, we need to move `endParent` to the `startPos`:\n\t\t// <a><b>x[]</b></a><c><d>{}y</d></c>\n\t\t// becomes:\n\t\t// <a><b>x</b>[]<d>y</d></a><c>{}</c>\n\t\twriter.insert( endParent, startPos );\n\t}\n\n\t// Merge two siblings:\n\t// <a>x</a>[]<b>y</b> -> <a>xy</a> (the usual case)\n\t// <a><b>x</b>[]<d>y</d></a><c></c> -> <a><b>xy</b>[]</a><c></c> (this is the \"move parent\" case shown above)\n\twriter.merge( startPos );\n\n\t// Remove empty end ancestors:\n\t// <a>fo[o</a><b><a><c>bar]</c></a></b>\n\t// becomes:\n\t// <a>fo[]</a><b><a>{}</a></b>\n\t// So we can remove <a> and <b>.\n\twhile ( endPos.parent.isEmpty ) {\n\t\tconst parentToRemove = endPos.parent;\n\n\t\tendPos = writer.createPositionBefore( parentToRemove );\n\n\t\twriter.remove( parentToRemove );\n\t}\n\n\t// Continue merging next level.\n\tmergeBranches( writer, startPos, endPos );\n}\n\nfunction shouldAutoparagraph( schema, position ) {\n\tconst isTextAllowed = schema.checkChild( position, '$text' );\n\tconst isParagraphAllowed = schema.checkChild( position, 'paragraph' );\n\n\treturn !isTextAllowed && isParagraphAllowed;\n}\n\n// Check if parents of two positions can be merged by checking if there are no limit/object\n// boundaries between those two positions.\n//\n// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>\n// we'll check <p>, <bQ>, <widget> and <caption>.\n// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.\nfunction checkCanBeMerged( leftPos, rightPos, schema ) {\n\tconst rangeToCheck = new Range( leftPos, rightPos );\n\n\tfor ( const value of rangeToCheck.getWalker() ) {\n\t\tif ( schema.isLimit( value.item ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction insertParagraph( writer, position, selection ) {\n\tconst paragraph = writer.createElement( 'paragraph' );\n\n\twriter.insert( paragraph, position );\n\n\tcollapseSelectionAt( writer, selection, writer.createPositionAt( paragraph, 0 ) );\n}\n\nfunction replaceEntireContentWithParagraph( writer, selection ) {\n\tconst limitElement = writer.model.schema.getLimitElement( selection );\n\n\twriter.remove( writer.createRangeIn( limitElement ) );\n\tinsertParagraph( writer, writer.createPositionAt( limitElement, 0 ), selection );\n}\n\n// We want to replace the entire content with a paragraph when:\n// * the entire content is selected,\n// * selection contains at least two elements,\n// * whether the paragraph is allowed in schema in the common ancestor.\nfunction shouldEntireContentBeReplacedWithParagraph( schema, selection ) {\n\tconst limitElement = schema.getLimitElement( selection );\n\n\tif ( !selection.containsEntireContent( limitElement ) ) {\n\t\treturn false;\n\t}\n\n\tconst range = selection.getFirstRange();\n\n\tif ( range.start.parent == range.end.parent ) {\n\t\treturn false;\n\t}\n\n\treturn schema.checkChild( limitElement, 'paragraph' );\n}\n\n// Helper function that sets the selection. Depending whether given `selection` is a document selection or not,\n// uses a different method to set it.\nfunction collapseSelectionAt( writer, selection, positionOrRange ) {\n\tif ( selection instanceof DocumentSelection ) {\n\t\twriter.setSelection( positionOrRange );\n\t} else {\n\t\tselection.setTo( positionOrRange );\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}