{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/tablecell-post-fixer\n */\n\n/**\n * Injects a table cell post-fixer into the editing controller.\n *\n * The role of the table cell post-fixer is to ensure that the table cell contents in the editing view are properly converted.\n *\n * This post-fixer will ensure that after model changes in the editing view:\n * * single paragraphs are rendered as `<span>\n * * single paragraphs with one or more attributes are rendered as `<p>`\n * * single paragraphs in table cell with other block elements are rendered as `<p>`\n * * paragraphs in table cells with other block elements (including other paragraphs) are rendered as `<p>`.\n *\n * In the model each table cell has always at least one block element inside. If no other block was defined (empty table cell) the table\n * feature will insert empty `<paragraph>`. Similarly text nodes will be wrapped in paragraphs. Rendering in the data pipeline differs\n * from rendering in the editing pipeline - text nodes in single `<paragraph>` are rendered in the data pipeline as direct children\n * of the `<td>` or `<th>` elements. In other cases `<paragraph>` elements are rendered as `<p>` blocks.\n *\n * To ensure proper mappings between model and view elements and positions in the editing pipeline the table feature will always render\n * an element in the view: `<span>` for single or empty `<paragraph>` and `<p>` otherwise.\n *\n * Example:\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph></paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>foo</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph baz=\"bar\">foo</paragraph></tableCell>\n *\t\t\t\t<tableCell><heading2>bar</heading2><paragraph>baz</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * The editor will render in the data pipeline:\n *\n *\t\t<figure>\n *\t\t\t<table>\n *\t\t\t\t<tbody>\n *\t\t\t\t\t<tr>\n *\t\t\t\t\t\t<td></td>\n *\t\t\t\t\t\t<td>foo</td>\n *\t\t\t\t\t\t<td><p baz=\"bar\">foo</p></td>\n *\t\t\t\t\t\t<td><h3>bar</h3><p>baz</p></td>\n *\t\t\t\t\t</tr>\n *\t\t\t\t</tbody>\n *\t\t\t</table>\n *\t\t</figure>\n *\n * and in the editing view (without widget markup):\n *\n *\t\t<figure>\n *\t\t\t<table>\n *\t\t\t\t<tbody>\n *\t\t\t\t\t<tr>\n *\t\t\t\t\t\t<td><span></span></td>\n *\t\t\t\t\t\t<td><span>foo</span></td>\n *\t\t\t\t\t\t<td><p baz=\"bar\">foo</p></td>\n *\t\t\t\t\t\t<td><h3>bar</h3><p>baz</p></td>\n *\t\t\t\t\t</tr>\n *\t\t\t\t</tbody>\n *\t\t\t</table>\n *\t\t</figure>\n *\n * @param {module:engine/model/model~Model} model\n * @param {module:engine/controller/editingcontroller~EditingController} editing\n */\nexport default function injectTableCellPostFixer(model, editing) {\n  editing.view.document.registerPostFixer(writer => tableCellPostFixer(writer, model, editing.mapper, editing.view));\n} // The table cell post-fixer.\n//\n// @param {module:engine/view/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/conversion/mapper~Mapper} mapper\n\nfunction tableCellPostFixer(writer, model, mapper, view) {\n  let wasFixed = false;\n  const elementsToCheck = getElementsToCheck(view);\n\n  for (const element of elementsToCheck) {\n    wasFixed = ensureProperElementName(element, mapper, writer) || wasFixed;\n  } // Selection in the view might not be updated to renamed elements. Happens mostly when other feature inserts paragraph to the table cell\n  // (ie. when deleting table cell contents) and sets selection to it while table-post fixer changes view <p> to <span> element.\n  // The view.selection would have outdated nodes.\n\n\n  if (wasFixed && selectionNeedsFix(view.document.selection, mapper)) {\n    updateRangesInViewSelection(model.document.selection, mapper, writer);\n  }\n\n  return wasFixed;\n} // Returns view elements changed in current view.change() block.\n//\n// **Note**: Currently it uses private property of the view: _renderer to get changed view elements to check.\n//\n// @param {module:engine/view/view~View} view\n\n\nfunction getElementsToCheck(view) {\n  const elementsWithChangedAttributes = Array.from(view._renderer.markedAttributes).filter(el => !!el.parent).filter(isSpanOrP).filter(el => isTdOrTh(el.parent));\n  const changedChildren = Array.from(view._renderer.markedChildren).filter(el => !!el.parent).filter(isTdOrTh).reduce((prev, element) => {\n    const childrenToCheck = Array.from(element.getChildren()).filter(isSpanOrP);\n    return [...prev, ...childrenToCheck];\n  }, []);\n  return [...elementsWithChangedAttributes, ...changedChildren];\n} // This method checks if view element for model's <paragraph> was properly converter.\n// Paragraph should be either\n// - span: for single paragraph with no attributes.\n// - p   : in other cases.\n\n\nfunction ensureProperElementName(currentViewElement, mapper, writer) {\n  // This situation may happen if a view element was changed and removed at the same time.\n  // In this case, the view element is already unbound so the post-fixer would crash.\n  if (!currentViewElement.root.is('rootElement')) {\n    return false;\n  }\n\n  const modelParagraph = mapper.toModelElement(currentViewElement);\n  const expectedViewElementName = getExpectedElementName(modelParagraph.parent, modelParagraph);\n\n  if (currentViewElement.name !== expectedViewElementName) {\n    // Unbind current view element as it should be cleared from mapper.\n    mapper.unbindViewElement(currentViewElement);\n    const renamedViewElement = writer.rename(expectedViewElementName, currentViewElement); // Bind paragraph inside table cell to the renamed view element.\n\n    mapper.bindElements(modelParagraph, renamedViewElement);\n    return true;\n  }\n\n  return false;\n} // Expected view element name depends on model elements:\n// - <paragraph> with any attribute set should be rendered as <p>\n// - all <paragraphs> in <tableCell> that has more then one children should be rendered as <p>\n// - an only <paragraph> child with no attributes should be rendered as <span>\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {module:engine/model/element~Element} paragraph\n// @returns {String}\n\n\nfunction getExpectedElementName(tableCell, paragraph) {\n  const isOnlyChild = tableCell.childCount > 1;\n  const hasAttributes = !![...paragraph.getAttributes()].length;\n  return isOnlyChild || hasAttributes ? 'p' : 'span';\n} // Method to filter out <span> and <p> elements.\n//\n// @param {module:engine/view/element~Element} element\n\n\nfunction isSpanOrP(element) {\n  return element.is('p') || element.is('span');\n} // Method to filter out <td> and <th> elements.\n//\n// @param {module:engine/view/element~Element} element\n\n\nfunction isTdOrTh(element) {\n  return element.is('td') || element.is('th');\n} // Resets view selections based on model selection.\n\n\nfunction updateRangesInViewSelection(selection, mapper, writer) {\n  const fixedRanges = Array.from(selection.getRanges()).map(range => mapper.toViewRange(range));\n  writer.setSelection(fixedRanges, {\n    backward: selection.isBackward\n  });\n} // Checks if selection needs to be fixed by ensuring that current view selection position's parents are present in the editable view.\n//\n// @param {module:engine/view/selection~Selection} viewSelection\n\n\nfunction selectionNeedsFix(viewSelection) {\n  const anchor = viewSelection.anchor;\n  const focus = viewSelection.focus;\n  return viewSelection.rangeCount && (!anchor.root.is('rootElement') || !focus.root.is('rootElement'));\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-table/src/converters/tablecell-post-fixer.js"],"names":["injectTableCellPostFixer","model","editing","view","document","registerPostFixer","writer","tableCellPostFixer","mapper","wasFixed","elementsToCheck","getElementsToCheck","element","ensureProperElementName","selectionNeedsFix","selection","updateRangesInViewSelection","elementsWithChangedAttributes","Array","from","_renderer","markedAttributes","filter","el","parent","isSpanOrP","isTdOrTh","changedChildren","markedChildren","reduce","prev","childrenToCheck","getChildren","currentViewElement","root","is","modelParagraph","toModelElement","expectedViewElementName","getExpectedElementName","name","unbindViewElement","renamedViewElement","rename","bindElements","tableCell","paragraph","isOnlyChild","childCount","hasAttributes","getAttributes","length","fixedRanges","getRanges","map","range","toViewRange","setSelection","backward","isBackward","viewSelection","anchor","focus","rangeCount"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/converters/tablecell-post-fixer\n */\n\n/**\n * Injects a table cell post-fixer into the editing controller.\n *\n * The role of the table cell post-fixer is to ensure that the table cell contents in the editing view are properly converted.\n *\n * This post-fixer will ensure that after model changes in the editing view:\n * * single paragraphs are rendered as `<span>\n * * single paragraphs with one or more attributes are rendered as `<p>`\n * * single paragraphs in table cell with other block elements are rendered as `<p>`\n * * paragraphs in table cells with other block elements (including other paragraphs) are rendered as `<p>`.\n *\n * In the model each table cell has always at least one block element inside. If no other block was defined (empty table cell) the table\n * feature will insert empty `<paragraph>`. Similarly text nodes will be wrapped in paragraphs. Rendering in the data pipeline differs\n * from rendering in the editing pipeline - text nodes in single `<paragraph>` are rendered in the data pipeline as direct children\n * of the `<td>` or `<th>` elements. In other cases `<paragraph>` elements are rendered as `<p>` blocks.\n *\n * To ensure proper mappings between model and view elements and positions in the editing pipeline the table feature will always render\n * an element in the view: `<span>` for single or empty `<paragraph>` and `<p>` otherwise.\n *\n * Example:\n *\n *\t\t<table>\n *\t\t\t<tableRow>\n *\t\t\t\t<tableCell><paragraph></paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph>foo</paragraph></tableCell>\n *\t\t\t\t<tableCell><paragraph baz=\"bar\">foo</paragraph></tableCell>\n *\t\t\t\t<tableCell><heading2>bar</heading2><paragraph>baz</paragraph></tableCell>\n *\t\t\t</tableRow>\n *\t\t</table>\n *\n * The editor will render in the data pipeline:\n *\n *\t\t<figure>\n *\t\t\t<table>\n *\t\t\t\t<tbody>\n *\t\t\t\t\t<tr>\n *\t\t\t\t\t\t<td></td>\n *\t\t\t\t\t\t<td>foo</td>\n *\t\t\t\t\t\t<td><p baz=\"bar\">foo</p></td>\n *\t\t\t\t\t\t<td><h3>bar</h3><p>baz</p></td>\n *\t\t\t\t\t</tr>\n *\t\t\t\t</tbody>\n *\t\t\t</table>\n *\t\t</figure>\n *\n * and in the editing view (without widget markup):\n *\n *\t\t<figure>\n *\t\t\t<table>\n *\t\t\t\t<tbody>\n *\t\t\t\t\t<tr>\n *\t\t\t\t\t\t<td><span></span></td>\n *\t\t\t\t\t\t<td><span>foo</span></td>\n *\t\t\t\t\t\t<td><p baz=\"bar\">foo</p></td>\n *\t\t\t\t\t\t<td><h3>bar</h3><p>baz</p></td>\n *\t\t\t\t\t</tr>\n *\t\t\t\t</tbody>\n *\t\t\t</table>\n *\t\t</figure>\n *\n * @param {module:engine/model/model~Model} model\n * @param {module:engine/controller/editingcontroller~EditingController} editing\n */\nexport default function injectTableCellPostFixer( model, editing ) {\n\tediting.view.document.registerPostFixer( writer => tableCellPostFixer( writer, model, editing.mapper, editing.view ) );\n}\n\n// The table cell post-fixer.\n//\n// @param {module:engine/view/writer~Writer} writer\n// @param {module:engine/model/model~Model} model\n// @param {module:engine/conversion/mapper~Mapper} mapper\nfunction tableCellPostFixer( writer, model, mapper, view ) {\n\tlet wasFixed = false;\n\n\tconst elementsToCheck = getElementsToCheck( view );\n\n\tfor ( const element of elementsToCheck ) {\n\t\twasFixed = ensureProperElementName( element, mapper, writer ) || wasFixed;\n\t}\n\n\t// Selection in the view might not be updated to renamed elements. Happens mostly when other feature inserts paragraph to the table cell\n\t// (ie. when deleting table cell contents) and sets selection to it while table-post fixer changes view <p> to <span> element.\n\t// The view.selection would have outdated nodes.\n\tif ( wasFixed && selectionNeedsFix( view.document.selection, mapper ) ) {\n\t\tupdateRangesInViewSelection( model.document.selection, mapper, writer );\n\t}\n\n\treturn wasFixed;\n}\n\n// Returns view elements changed in current view.change() block.\n//\n// **Note**: Currently it uses private property of the view: _renderer to get changed view elements to check.\n//\n// @param {module:engine/view/view~View} view\nfunction getElementsToCheck( view ) {\n\tconst elementsWithChangedAttributes = Array.from( view._renderer.markedAttributes )\n\t\t.filter( el => !!el.parent )\n\t\t.filter( isSpanOrP )\n\t\t.filter( el => isTdOrTh( el.parent ) );\n\n\tconst changedChildren = Array.from( view._renderer.markedChildren )\n\t\t.filter( el => !!el.parent )\n\t\t.filter( isTdOrTh )\n\t\t.reduce( ( prev, element ) => {\n\t\t\tconst childrenToCheck = Array.from( element.getChildren() ).filter( isSpanOrP );\n\n\t\t\treturn [ ...prev, ...childrenToCheck ];\n\t\t}, [] );\n\n\treturn [ ...elementsWithChangedAttributes, ...changedChildren ];\n}\n\n// This method checks if view element for model's <paragraph> was properly converter.\n// Paragraph should be either\n// - span: for single paragraph with no attributes.\n// - p   : in other cases.\nfunction ensureProperElementName( currentViewElement, mapper, writer ) {\n\t// This situation may happen if a view element was changed and removed at the same time.\n\t// In this case, the view element is already unbound so the post-fixer would crash.\n\tif ( !currentViewElement.root.is( 'rootElement' ) ) {\n\t\treturn false;\n\t}\n\n\tconst modelParagraph = mapper.toModelElement( currentViewElement );\n\tconst expectedViewElementName = getExpectedElementName( modelParagraph.parent, modelParagraph );\n\n\tif ( currentViewElement.name !== expectedViewElementName ) {\n\t\t// Unbind current view element as it should be cleared from mapper.\n\t\tmapper.unbindViewElement( currentViewElement );\n\n\t\tconst renamedViewElement = writer.rename( expectedViewElementName, currentViewElement );\n\n\t\t// Bind paragraph inside table cell to the renamed view element.\n\t\tmapper.bindElements( modelParagraph, renamedViewElement );\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n// Expected view element name depends on model elements:\n// - <paragraph> with any attribute set should be rendered as <p>\n// - all <paragraphs> in <tableCell> that has more then one children should be rendered as <p>\n// - an only <paragraph> child with no attributes should be rendered as <span>\n//\n// @param {module:engine/model/element~Element} tableCell\n// @param {module:engine/model/element~Element} paragraph\n// @returns {String}\nfunction getExpectedElementName( tableCell, paragraph ) {\n\tconst isOnlyChild = tableCell.childCount > 1;\n\tconst hasAttributes = !![ ...paragraph.getAttributes() ].length;\n\n\treturn ( isOnlyChild || hasAttributes ) ? 'p' : 'span';\n}\n\n// Method to filter out <span> and <p> elements.\n//\n// @param {module:engine/view/element~Element} element\nfunction isSpanOrP( element ) {\n\treturn element.is( 'p' ) || element.is( 'span' );\n}\n\n// Method to filter out <td> and <th> elements.\n//\n// @param {module:engine/view/element~Element} element\nfunction isTdOrTh( element ) {\n\treturn element.is( 'td' ) || element.is( 'th' );\n}\n\n// Resets view selections based on model selection.\nfunction updateRangesInViewSelection( selection, mapper, writer ) {\n\tconst fixedRanges = Array.from( selection.getRanges() )\n\t\t.map( range => mapper.toViewRange( range ) );\n\n\twriter.setSelection( fixedRanges, { backward: selection.isBackward } );\n}\n\n// Checks if selection needs to be fixed by ensuring that current view selection position's parents are present in the editable view.\n//\n// @param {module:engine/view/selection~Selection} viewSelection\nfunction selectionNeedsFix( viewSelection ) {\n\tconst anchor = viewSelection.anchor;\n\tconst focus = viewSelection.focus;\n\n\treturn viewSelection.rangeCount && ( !anchor.root.is( 'rootElement' ) || !focus.root.is( 'rootElement' ) );\n}\n"]},"metadata":{},"sourceType":"module"}