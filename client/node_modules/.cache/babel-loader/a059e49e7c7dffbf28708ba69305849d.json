{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/inlineautoformatediting\n */\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\nexport default class InlineAutoformatEditing {\n  /**\n   * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n   *\n   * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n   * On every change applied to the model the autoformatting engine checks the text on the left of the selection\n   * and executes the provided action if the text matches given criteria (regular expression or callback).\n   *\n   * @param {module:core/editor/editor~Editor} editor The editor instance.\n   * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n   * Provided regular expression *must* have three capture groups. The first and the third capture group\n   * should match opening and closing delimiters. The second capture group should match the text to format.\n   *\n   *\t\t// Matches the `**bold text**` pattern.\n   *\t\t// There are three capturing groups:\n   *\t\t// - The first to match the starting `**` delimiter.\n   *\t\t// - The second to match the text to format.\n   *\t\t// - The third to match the ending `**` delimiter.\n   *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n   *\n   * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n   * The function should return proper \"ranges\" to delete and format.\n   *\n   *\t\t{\n   *\t\t\tremove: [\n   *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n   *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n   *\t\t\t],\n   *\t\t\tformat: [\n   *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n   *\t\t\t]\n   *\t\t}\n   *\n   * @param {Function|String} attributeOrCallback The name of attribute to apply on matching text or a callback for manual\n   * formatting. If callback is passed it should return `false` if changes should not be applied (e.g. if a command is disabled).\n   *\n   *\t\t// Use attribute name:\n   *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n   *\n   *\t\t// Use formatting callback:\n   *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n   *\t\t\tconst command = editor.commands.get( 'bold' );\n   *\n   *\t\t\tif ( !command.isEnabled ) {\n   *\t\t\t\treturn false;\n   *\t\t\t}\n   *\n   *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n   *\n   *\t\t\tfor ( let range of validRanges ) {\n   *\t\t\t\twriter.setAttribute( 'bold', true, range );\n   *\t\t\t}\n   *\t\t} );\n   */\n  constructor(editor, testRegexpOrCallback, attributeOrCallback) {\n    let regExp;\n    let attributeKey;\n    let testCallback;\n    let formatCallback;\n\n    if (testRegexpOrCallback instanceof RegExp) {\n      regExp = testRegexpOrCallback;\n    } else {\n      testCallback = testRegexpOrCallback;\n    }\n\n    if (typeof attributeOrCallback == 'string') {\n      attributeKey = attributeOrCallback;\n    } else {\n      formatCallback = attributeOrCallback;\n    } // A test callback run on changed text.\n\n\n    testCallback = testCallback || (text => {\n      let result;\n      const remove = [];\n      const format = [];\n\n      while ((result = regExp.exec(text)) !== null) {\n        // There should be full match and 3 capture groups.\n        if (result && result.length < 4) {\n          break;\n        }\n\n        let {\n          index,\n          '1': leftDel,\n          '2': content,\n          '3': rightDel\n        } = result; // Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\n        const found = leftDel + content + rightDel;\n        index += result[0].length - found.length; // Start and End offsets of delimiters to remove.\n\n        const delStart = [index, index + leftDel.length];\n        const delEnd = [index + leftDel.length + content.length, index + leftDel.length + content.length + rightDel.length];\n        remove.push(delStart);\n        remove.push(delEnd);\n        format.push([index + leftDel.length, index + leftDel.length + content.length]);\n      }\n\n      return {\n        remove,\n        format\n      };\n    }); // A format callback run on matched text.\n\n\n    formatCallback = formatCallback || ((writer, rangesToFormat) => {\n      const validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);\n\n      for (const range of validRanges) {\n        writer.setAttribute(attributeKey, true, range);\n      } // After applying attribute to the text, remove given attribute from the selection.\n      // This way user is able to type a text without attribute used by auto formatter.\n\n\n      writer.removeSelectionAttribute(attributeKey);\n    });\n\n    editor.model.document.on('change', (evt, batch) => {\n      if (batch.type == 'transparent') {\n        return;\n      }\n\n      const selection = editor.model.document.selection; // Do nothing if selection is not collapsed.\n\n      if (!selection.isCollapsed) {\n        return;\n      }\n\n      const changes = Array.from(editor.model.document.differ.getChanges());\n      const entry = changes[0]; // Typing is represented by only a single change.\n\n      if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {\n        return;\n      }\n\n      const block = selection.focus.parent;\n      const text = getText(block).slice(0, selection.focus.offset);\n      const testOutput = testCallback(text);\n      const rangesToFormat = testOutputToRanges(block, testOutput.format, editor.model);\n      const rangesToRemove = testOutputToRanges(block, testOutput.remove, editor.model);\n\n      if (!(rangesToFormat.length && rangesToRemove.length)) {\n        return;\n      } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\n\n      editor.model.enqueueChange(writer => {\n        // Apply format.\n        const hasChanged = formatCallback(writer, rangesToFormat); // Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\n        if (hasChanged === false) {\n          return;\n        } // Remove delimiters - use reversed order to not mix the offsets while removing.\n\n\n        for (const range of rangesToRemove.reverse()) {\n          writer.remove(range);\n        }\n      });\n    });\n  }\n\n} // Returns whole text from parent element by adding all data from text nodes together.\n//\n// @private\n// @param {module:engine/model/element~Element} element\n// @returns {String}\n\nfunction getText(element) {\n  return Array.from(element.getChildren()).reduce((a, b) => a + b.data, '');\n} // Converts output of the test function provided to the InlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/element~Element} block\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\n\n\nfunction testOutputToRanges(block, arrays, model) {\n  return arrays.filter(array => array[0] !== undefined && array[1] !== undefined).map(array => {\n    return model.createRange(model.createPositionAt(block, array[0]), model.createPositionAt(block, array[1]));\n  });\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulamasÄ±/client/node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js"],"names":["InlineAutoformatEditing","constructor","editor","testRegexpOrCallback","attributeOrCallback","regExp","attributeKey","testCallback","formatCallback","RegExp","text","result","remove","format","exec","length","index","leftDel","content","rightDel","found","delStart","delEnd","push","writer","rangesToFormat","validRanges","model","schema","getValidRanges","range","setAttribute","removeSelectionAttribute","document","on","evt","batch","type","selection","isCollapsed","changes","Array","from","differ","getChanges","entry","name","block","focus","parent","getText","slice","offset","testOutput","testOutputToRanges","rangesToRemove","enqueueChange","hasChanged","reverse","element","getChildren","reduce","a","b","data","arrays","filter","array","undefined","map","createRange","createPositionAt"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/inlineautoformatediting\n */\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\nexport default class InlineAutoformatEditing {\n\t/**\n\t * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n\t *\n\t * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n\t * On every change applied to the model the autoformatting engine checks the text on the left of the selection\n\t * and executes the provided action if the text matches given criteria (regular expression or callback).\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n\t * Provided regular expression *must* have three capture groups. The first and the third capture group\n\t * should match opening and closing delimiters. The second capture group should match the text to format.\n\t *\n\t *\t\t// Matches the `**bold text**` pattern.\n\t *\t\t// There are three capturing groups:\n\t *\t\t// - The first to match the starting `**` delimiter.\n\t *\t\t// - The second to match the text to format.\n\t *\t\t// - The third to match the ending `**` delimiter.\n\t *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n\t *\n\t * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n\t * The function should return proper \"ranges\" to delete and format.\n\t *\n\t *\t\t{\n\t *\t\t\tremove: [\n\t *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n\t *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n\t *\t\t\t],\n\t *\t\t\tformat: [\n\t *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n\t *\t\t\t]\n\t *\t\t}\n\t *\n\t * @param {Function|String} attributeOrCallback The name of attribute to apply on matching text or a callback for manual\n\t * formatting. If callback is passed it should return `false` if changes should not be applied (e.g. if a command is disabled).\n\t *\n\t *\t\t// Use attribute name:\n\t *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n\t *\n\t *\t\t// Use formatting callback:\n\t *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n\t *\t\t\tconst command = editor.commands.get( 'bold' );\n\t *\n\t *\t\t\tif ( !command.isEnabled ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n\t *\n\t *\t\t\tfor ( let range of validRanges ) {\n\t *\t\t\t\twriter.setAttribute( 'bold', true, range );\n\t *\t\t\t}\n\t *\t\t} );\n\t */\n\tconstructor( editor, testRegexpOrCallback, attributeOrCallback ) {\n\t\tlet regExp;\n\t\tlet attributeKey;\n\t\tlet testCallback;\n\t\tlet formatCallback;\n\n\t\tif ( testRegexpOrCallback instanceof RegExp ) {\n\t\t\tregExp = testRegexpOrCallback;\n\t\t} else {\n\t\t\ttestCallback = testRegexpOrCallback;\n\t\t}\n\n\t\tif ( typeof attributeOrCallback == 'string' ) {\n\t\t\tattributeKey = attributeOrCallback;\n\t\t} else {\n\t\t\tformatCallback = attributeOrCallback;\n\t\t}\n\n\t\t// A test callback run on changed text.\n\t\ttestCallback = testCallback || ( text => {\n\t\t\tlet result;\n\t\t\tconst remove = [];\n\t\t\tconst format = [];\n\n\t\t\twhile ( ( result = regExp.exec( text ) ) !== null ) {\n\t\t\t\t// There should be full match and 3 capture groups.\n\t\t\t\tif ( result && result.length < 4 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet {\n\t\t\t\t\tindex,\n\t\t\t\t\t'1': leftDel,\n\t\t\t\t\t'2': content,\n\t\t\t\t\t'3': rightDel\n\t\t\t\t} = result;\n\n\t\t\t\t// Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\t\t\t\tconst found = leftDel + content + rightDel;\n\t\t\t\tindex += result[ 0 ].length - found.length;\n\n\t\t\t\t// Start and End offsets of delimiters to remove.\n\t\t\t\tconst delStart = [\n\t\t\t\t\tindex,\n\t\t\t\t\tindex + leftDel.length\n\t\t\t\t];\n\t\t\t\tconst delEnd = [\n\t\t\t\t\tindex + leftDel.length + content.length,\n\t\t\t\t\tindex + leftDel.length + content.length + rightDel.length\n\t\t\t\t];\n\n\t\t\t\tremove.push( delStart );\n\t\t\t\tremove.push( delEnd );\n\n\t\t\t\tformat.push( [ index + leftDel.length, index + leftDel.length + content.length ] );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tremove,\n\t\t\t\tformat\n\t\t\t};\n\t\t} );\n\n\t\t// A format callback run on matched text.\n\t\tformatCallback = formatCallback || ( ( writer, rangesToFormat ) => {\n\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, attributeKey );\n\n\t\t\tfor ( const range of validRanges ) {\n\t\t\t\twriter.setAttribute( attributeKey, true, range );\n\t\t\t}\n\n\t\t\t// After applying attribute to the text, remove given attribute from the selection.\n\t\t\t// This way user is able to type a text without attribute used by auto formatter.\n\t\t\twriter.removeSelectionAttribute( attributeKey );\n\t\t} );\n\n\t\teditor.model.document.on( 'change', ( evt, batch ) => {\n\t\t\tif ( batch.type == 'transparent' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst selection = editor.model.document.selection;\n\n\t\t\t// Do nothing if selection is not collapsed.\n\t\t\tif ( !selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst changes = Array.from( editor.model.document.differ.getChanges() );\n\t\t\tconst entry = changes[ 0 ];\n\n\t\t\t// Typing is represented by only a single change.\n\t\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst block = selection.focus.parent;\n\t\t\tconst text = getText( block ).slice( 0, selection.focus.offset );\n\t\t\tconst testOutput = testCallback( text );\n\t\t\tconst rangesToFormat = testOutputToRanges( block, testOutput.format, editor.model );\n\t\t\tconst rangesToRemove = testOutputToRanges( block, testOutput.remove, editor.model );\n\n\t\t\tif ( !( rangesToFormat.length && rangesToRemove.length ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\t\teditor.model.enqueueChange( writer => {\n\t\t\t\t// Apply format.\n\t\t\t\tconst hasChanged = formatCallback( writer, rangesToFormat );\n\n\t\t\t\t// Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\t\t\t\tif ( hasChanged === false ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Remove delimiters - use reversed order to not mix the offsets while removing.\n\t\t\t\tfor ( const range of rangesToRemove.reverse() ) {\n\t\t\t\t\twriter.remove( range );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n}\n\n// Returns whole text from parent element by adding all data from text nodes together.\n//\n// @private\n// @param {module:engine/model/element~Element} element\n// @returns {String}\nfunction getText( element ) {\n\treturn Array.from( element.getChildren() ).reduce( ( a, b ) => a + b.data, '' );\n}\n\n// Converts output of the test function provided to the InlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/element~Element} block\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\nfunction testOutputToRanges( block, arrays, model ) {\n\treturn arrays\n\t\t.filter( array => ( array[ 0 ] !== undefined && array[ 1 ] !== undefined ) )\n\t\t.map( array => {\n\t\t\treturn model.createRange( model.createPositionAt( block, array[ 0 ] ), model.createPositionAt( block, array[ 1 ] ) );\n\t\t} );\n}\n"]},"metadata":{},"sourceType":"module"}