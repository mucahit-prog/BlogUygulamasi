{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module block-quote/blockquotecommand\n */\nimport Command from '@ckeditor/ckeditor5-core/src/command';\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n/**\n * The block quote command plugin.\n *\n * @extends module:core/command~Command\n */\n\nexport default class BlockQuoteCommand extends Command {\n  /**\n   * Whether the selection starts in a block quote.\n   *\n   * @observable\n   * @readonly\n   * @member {Boolean} #value\n   */\n\n  /**\n   * @inheritDoc\n   */\n  refresh() {\n    this.value = this._getValue();\n    this.isEnabled = this._checkEnabled();\n  }\n  /**\n   * Executes the command. When the command {@link #value is on}, all top-most block quotes within\n   * the selection will be removed. If it is off, all selected blocks will be wrapped with\n   * a block quote.\n   *\n   * @fires execute\n   * @param {Object} [options] Command options.\n   * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply a block quote,\n   * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.\n   */\n\n\n  execute(options = {}) {\n    const model = this.editor.model;\n    const schema = model.schema;\n    const selection = model.document.selection;\n    const blocks = Array.from(selection.getTopMostBlocks());\n    const value = options.forceValue === undefined ? !this.value : options.forceValue;\n    model.change(writer => {\n      if (!value) {\n        this._removeQuote(writer, blocks.filter(findQuote));\n      } else {\n        const blocksToQuote = blocks.filter(block => {\n          // Already quoted blocks needs to be considered while quoting too\n          // in order to reuse their <bQ> elements.\n          return findQuote(block) || checkCanBeQuoted(schema, block);\n        });\n\n        this._applyQuote(writer, blocksToQuote);\n      }\n    });\n  }\n  /**\n   * Checks the command's {@link #value}.\n   *\n   * @private\n   * @returns {Boolean} The current value.\n   */\n\n\n  _getValue() {\n    const selection = this.editor.model.document.selection;\n    const firstBlock = first(selection.getTopMostBlocks()); // In the current implementation, the block quote must be an immediate parent of a block element.\n\n    return !!(firstBlock && findQuote(firstBlock));\n  }\n  /**\n   * Checks whether the command can be enabled in the current context.\n   *\n   * @private\n   * @returns {Boolean} Whether the command should be enabled.\n   */\n\n\n  _checkEnabled() {\n    if (this.value) {\n      return true;\n    }\n\n    const selection = this.editor.model.document.selection;\n    const schema = this.editor.model.schema;\n    const firstBlock = first(selection.getSelectedBlocks());\n\n    if (!firstBlock) {\n      return false;\n    }\n\n    return checkCanBeQuoted(schema, firstBlock);\n  }\n  /**\n   * Removes the quote from given blocks.\n   *\n   * If blocks which are supposed to be \"unquoted\" are in the middle of a quote,\n   * start it or end it, then the quote will be split (if needed) and the blocks\n   * will be moved out of it, so other quoted blocks remained quoted.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer\n   * @param {Array.<module:engine/model/element~Element>} blocks\n   */\n\n\n  _removeQuote(writer, blocks) {\n    // Unquote all groups of block. Iterate in the reverse order to not break following ranges.\n    getRangesOfBlockGroups(writer, blocks).reverse().forEach(groupRange => {\n      if (groupRange.start.isAtStart && groupRange.end.isAtEnd) {\n        writer.unwrap(groupRange.start.parent);\n        return;\n      } // The group of blocks are at the beginning of an <bQ> so let's move them left (out of the <bQ>).\n\n\n      if (groupRange.start.isAtStart) {\n        const positionBefore = writer.createPositionBefore(groupRange.start.parent);\n        writer.move(groupRange, positionBefore);\n        return;\n      } // The blocks are in the middle of an <bQ> so we need to split the <bQ> after the last block\n      // so we move the items there.\n\n\n      if (!groupRange.end.isAtEnd) {\n        writer.split(groupRange.end);\n      } // Now we are sure that groupRange.end.isAtEnd is true, so let's move the blocks right.\n\n\n      const positionAfter = writer.createPositionAfter(groupRange.end.parent);\n      writer.move(groupRange, positionAfter);\n    });\n  }\n  /**\n   * Applies the quote to given blocks.\n   *\n   * @private\n   * @param {module:engine/model/writer~Writer} writer\n   * @param {Array.<module:engine/model/element~Element>} blocks\n   */\n\n\n  _applyQuote(writer, blocks) {\n    const quotesToMerge = []; // Quote all groups of block. Iterate in the reverse order to not break following ranges.\n\n    getRangesOfBlockGroups(writer, blocks).reverse().forEach(groupRange => {\n      let quote = findQuote(groupRange.start);\n\n      if (!quote) {\n        quote = writer.createElement('blockQuote');\n        writer.wrap(groupRange, quote);\n      }\n\n      quotesToMerge.push(quote);\n    }); // Merge subsequent <bQ> elements. Reverse the order again because this time we want to go through\n    // the <bQ> elements in the source order (due to how merge works – it moves the right element's content\n    // to the first element and removes the right one. Since we may need to merge a couple of subsequent `<bQ>` elements\n    // we want to keep the reference to the first (furthest left) one.\n\n    quotesToMerge.reverse().reduce((currentQuote, nextQuote) => {\n      if (currentQuote.nextSibling == nextQuote) {\n        writer.merge(writer.createPositionAfter(currentQuote));\n        return currentQuote;\n      }\n\n      return nextQuote;\n    });\n  }\n\n}\n\nfunction findQuote(elementOrPosition) {\n  return elementOrPosition.parent.name == 'blockQuote' ? elementOrPosition.parent : null;\n} // Returns a minimal array of ranges containing groups of subsequent blocks.\n//\n// content:         abcdefgh\n// blocks:          [ a, b, d, f, g, h ]\n// output ranges:   [ab]c[d]e[fgh]\n//\n// @param {Array.<module:engine/model/element~Element>} blocks\n// @returns {Array.<module:engine/model/range~Range>}\n\n\nfunction getRangesOfBlockGroups(writer, blocks) {\n  let startPosition;\n  let i = 0;\n  const ranges = [];\n\n  while (i < blocks.length) {\n    const block = blocks[i];\n    const nextBlock = blocks[i + 1];\n\n    if (!startPosition) {\n      startPosition = writer.createPositionBefore(block);\n    }\n\n    if (!nextBlock || block.nextSibling != nextBlock) {\n      ranges.push(writer.createRange(startPosition, writer.createPositionAfter(block)));\n      startPosition = null;\n    }\n\n    i++;\n  }\n\n  return ranges;\n} // Checks whether <bQ> can wrap the block.\n\n\nfunction checkCanBeQuoted(schema, block) {\n  // TMP will be replaced with schema.checkWrap().\n  const isBQAllowed = schema.checkChild(block.parent, 'blockQuote');\n  const isBlockAllowedInBQ = schema.checkChild(['$root', 'blockQuote'], block);\n  return isBQAllowed && isBlockAllowedInBQ;\n}","map":{"version":3,"sources":["C:/Users/Valanis/Desktop/React-Docs-Practice/BlogUygulaması/client/node_modules/@ckeditor/ckeditor5-block-quote/src/blockquotecommand.js"],"names":["Command","first","BlockQuoteCommand","refresh","value","_getValue","isEnabled","_checkEnabled","execute","options","model","editor","schema","selection","document","blocks","Array","from","getTopMostBlocks","forceValue","undefined","change","writer","_removeQuote","filter","findQuote","blocksToQuote","block","checkCanBeQuoted","_applyQuote","firstBlock","getSelectedBlocks","getRangesOfBlockGroups","reverse","forEach","groupRange","start","isAtStart","end","isAtEnd","unwrap","parent","positionBefore","createPositionBefore","move","split","positionAfter","createPositionAfter","quotesToMerge","quote","createElement","wrap","push","reduce","currentQuote","nextQuote","nextSibling","merge","elementOrPosition","name","startPosition","i","ranges","length","nextBlock","createRange","isBQAllowed","checkChild","isBlockAllowedInBQ"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module block-quote/blockquotecommand\n */\n\nimport Command from '@ckeditor/ckeditor5-core/src/command';\n\nimport first from '@ckeditor/ckeditor5-utils/src/first';\n\n/**\n * The block quote command plugin.\n *\n * @extends module:core/command~Command\n */\nexport default class BlockQuoteCommand extends Command {\n\t/**\n\t * Whether the selection starts in a block quote.\n\t *\n\t * @observable\n\t * @readonly\n\t * @member {Boolean} #value\n\t */\n\n\t/**\n\t * @inheritDoc\n\t */\n\trefresh() {\n\t\tthis.value = this._getValue();\n\t\tthis.isEnabled = this._checkEnabled();\n\t}\n\n\t/**\n\t * Executes the command. When the command {@link #value is on}, all top-most block quotes within\n\t * the selection will be removed. If it is off, all selected blocks will be wrapped with\n\t * a block quote.\n\t *\n\t * @fires execute\n\t * @param {Object} [options] Command options.\n\t * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply a block quote,\n\t * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.\n\t */\n\texecute( options = {} ) {\n\t\tconst model = this.editor.model;\n\t\tconst schema = model.schema;\n\t\tconst selection = model.document.selection;\n\n\t\tconst blocks = Array.from( selection.getTopMostBlocks() );\n\n\t\tconst value = ( options.forceValue === undefined ) ? !this.value : options.forceValue;\n\n\t\tmodel.change( writer => {\n\t\t\tif ( !value ) {\n\t\t\t\tthis._removeQuote( writer, blocks.filter( findQuote ) );\n\t\t\t} else {\n\t\t\t\tconst blocksToQuote = blocks.filter( block => {\n\t\t\t\t\t// Already quoted blocks needs to be considered while quoting too\n\t\t\t\t\t// in order to reuse their <bQ> elements.\n\t\t\t\t\treturn findQuote( block ) || checkCanBeQuoted( schema, block );\n\t\t\t\t} );\n\n\t\t\t\tthis._applyQuote( writer, blocksToQuote );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Checks the command's {@link #value}.\n\t *\n\t * @private\n\t * @returns {Boolean} The current value.\n\t */\n\t_getValue() {\n\t\tconst selection = this.editor.model.document.selection;\n\n\t\tconst firstBlock = first( selection.getTopMostBlocks() );\n\n\t\t// In the current implementation, the block quote must be an immediate parent of a block element.\n\t\treturn !!( firstBlock && findQuote( firstBlock ) );\n\t}\n\n\t/**\n\t * Checks whether the command can be enabled in the current context.\n\t *\n\t * @private\n\t * @returns {Boolean} Whether the command should be enabled.\n\t */\n\t_checkEnabled() {\n\t\tif ( this.value ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst selection = this.editor.model.document.selection;\n\t\tconst schema = this.editor.model.schema;\n\n\t\tconst firstBlock = first( selection.getSelectedBlocks() );\n\n\t\tif ( !firstBlock ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn checkCanBeQuoted( schema, firstBlock );\n\t}\n\n\t/**\n\t * Removes the quote from given blocks.\n\t *\n\t * If blocks which are supposed to be \"unquoted\" are in the middle of a quote,\n\t * start it or end it, then the quote will be split (if needed) and the blocks\n\t * will be moved out of it, so other quoted blocks remained quoted.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer\n\t * @param {Array.<module:engine/model/element~Element>} blocks\n\t */\n\t_removeQuote( writer, blocks ) {\n\t\t// Unquote all groups of block. Iterate in the reverse order to not break following ranges.\n\t\tgetRangesOfBlockGroups( writer, blocks ).reverse().forEach( groupRange => {\n\t\t\tif ( groupRange.start.isAtStart && groupRange.end.isAtEnd ) {\n\t\t\t\twriter.unwrap( groupRange.start.parent );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The group of blocks are at the beginning of an <bQ> so let's move them left (out of the <bQ>).\n\t\t\tif ( groupRange.start.isAtStart ) {\n\t\t\t\tconst positionBefore = writer.createPositionBefore( groupRange.start.parent );\n\n\t\t\t\twriter.move( groupRange, positionBefore );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// The blocks are in the middle of an <bQ> so we need to split the <bQ> after the last block\n\t\t\t// so we move the items there.\n\t\t\tif ( !groupRange.end.isAtEnd ) {\n\t\t\t\twriter.split( groupRange.end );\n\t\t\t}\n\n\t\t\t// Now we are sure that groupRange.end.isAtEnd is true, so let's move the blocks right.\n\n\t\t\tconst positionAfter = writer.createPositionAfter( groupRange.end.parent );\n\n\t\t\twriter.move( groupRange, positionAfter );\n\t\t} );\n\t}\n\n\t/**\n\t * Applies the quote to given blocks.\n\t *\n\t * @private\n\t * @param {module:engine/model/writer~Writer} writer\n\t * @param {Array.<module:engine/model/element~Element>} blocks\n\t */\n\t_applyQuote( writer, blocks ) {\n\t\tconst quotesToMerge = [];\n\n\t\t// Quote all groups of block. Iterate in the reverse order to not break following ranges.\n\t\tgetRangesOfBlockGroups( writer, blocks ).reverse().forEach( groupRange => {\n\t\t\tlet quote = findQuote( groupRange.start );\n\n\t\t\tif ( !quote ) {\n\t\t\t\tquote = writer.createElement( 'blockQuote' );\n\n\t\t\t\twriter.wrap( groupRange, quote );\n\t\t\t}\n\n\t\t\tquotesToMerge.push( quote );\n\t\t} );\n\n\t\t// Merge subsequent <bQ> elements. Reverse the order again because this time we want to go through\n\t\t// the <bQ> elements in the source order (due to how merge works – it moves the right element's content\n\t\t// to the first element and removes the right one. Since we may need to merge a couple of subsequent `<bQ>` elements\n\t\t// we want to keep the reference to the first (furthest left) one.\n\t\tquotesToMerge.reverse().reduce( ( currentQuote, nextQuote ) => {\n\t\t\tif ( currentQuote.nextSibling == nextQuote ) {\n\t\t\t\twriter.merge( writer.createPositionAfter( currentQuote ) );\n\n\t\t\t\treturn currentQuote;\n\t\t\t}\n\n\t\t\treturn nextQuote;\n\t\t} );\n\t}\n}\n\nfunction findQuote( elementOrPosition ) {\n\treturn elementOrPosition.parent.name == 'blockQuote' ? elementOrPosition.parent : null;\n}\n\n// Returns a minimal array of ranges containing groups of subsequent blocks.\n//\n// content:         abcdefgh\n// blocks:          [ a, b, d, f, g, h ]\n// output ranges:   [ab]c[d]e[fgh]\n//\n// @param {Array.<module:engine/model/element~Element>} blocks\n// @returns {Array.<module:engine/model/range~Range>}\nfunction getRangesOfBlockGroups( writer, blocks ) {\n\tlet startPosition;\n\tlet i = 0;\n\tconst ranges = [];\n\n\twhile ( i < blocks.length ) {\n\t\tconst block = blocks[ i ];\n\t\tconst nextBlock = blocks[ i + 1 ];\n\n\t\tif ( !startPosition ) {\n\t\t\tstartPosition = writer.createPositionBefore( block );\n\t\t}\n\n\t\tif ( !nextBlock || block.nextSibling != nextBlock ) {\n\t\t\tranges.push( writer.createRange( startPosition, writer.createPositionAfter( block ) ) );\n\t\t\tstartPosition = null;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn ranges;\n}\n\n// Checks whether <bQ> can wrap the block.\nfunction checkCanBeQuoted( schema, block ) {\n\t// TMP will be replaced with schema.checkWrap().\n\tconst isBQAllowed = schema.checkChild( block.parent, 'blockQuote' );\n\tconst isBlockAllowedInBQ = schema.checkChild( [ '$root', 'blockQuote' ], block );\n\n\treturn isBQAllowed && isBlockAllowedInBQ;\n}\n"]},"metadata":{},"sourceType":"module"}