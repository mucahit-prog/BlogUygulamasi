'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var getContentStateFragment = require('draft-js/lib/getContentStateFragment');
var getDraftEditorSelection = require('draft-js/lib/getDraftEditorSelection');
var editOnCopy = require('draft-js/lib/editOnCopy');
var editOnCut = require('draft-js/lib/editOnCut');
var draftJs = require('draft-js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var getContentStateFragment__default = /*#__PURE__*/_interopDefaultLegacy(getContentStateFragment);
var getDraftEditorSelection__default = /*#__PURE__*/_interopDefaultLegacy(getDraftEditorSelection);
var editOnCopy__default = /*#__PURE__*/_interopDefaultLegacy(editOnCopy);
var editOnCut__default = /*#__PURE__*/_interopDefaultLegacy(editOnCut);

// @flow
/*:: import type { BlockNode } from "draft-js/lib/BlockNode";*/

// Default maximum block depth supported by Draft.js CSS.
var DRAFT_DEFAULT_MAX_DEPTH = 4; // Default depth class prefix from Draft.js CSS.

var DRAFT_DEFAULT_DEPTH_CLASS = "public-DraftStyleDefault-depth";
/**
 * Generates CSS styles for list items, for a given selector pattern.
 * @param {string} selectorPrefix
 * @param {number} minDepth
 * @param {number} maxDepth
 */

var generateListNestingStyles = function generateListNestingStyles(selectorPrefix
/*: string*/
, minDepth
/*: number*/
, maxDepth
/*: number*/
) {
  var styles = "";

  for (var depth = minDepth; depth <= maxDepth; depth++) {
    var d = String(depth);
    var prefix = "".concat(selectorPrefix).concat(d);
    var counter = "ol".concat(d);
    var margin = 1.5 * (depth + 1);
    var m = String(margin);
    styles += "\n.".concat(prefix, ".public-DraftStyleDefault-listLTR { margin-left: ").concat(m, "em; }\n.").concat(prefix, ".public-DraftStyleDefault-listRTL { margin-right: ").concat(m, "em; }\n.").concat(prefix, ".public-DraftStyleDefault-orderedListItem::before { content: counter(").concat(counter, ") '. '; counter-increment: ").concat(counter, "; }\n.").concat(prefix, ".public-DraftStyleDefault-reset { counter-reset: ").concat(counter, "; }");
  }

  return styles;
};
/**
 * Dynamically generates the right list nesting styles.
 * Can be wrapped as a pure component - to re-render only when `max` changes (eg. never).
 */

var ListNestingStyles = function ListNestingStyles(props
/*: { max: number }*/
) {
  var max = props.max;
  var min = DRAFT_DEFAULT_MAX_DEPTH + 1;
  return max > DRAFT_DEFAULT_MAX_DEPTH ? /*#__PURE__*/React__default['default'].createElement("style", null, generateListNestingStyles(DRAFT_DEFAULT_DEPTH_CLASS, min, max)) : null;
};
/**
 * Add depth classes that Draft.js doesn't provide.
 * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.
 * @param {ContentBlock} block
 */

var blockDepthStyleFn = function blockDepthStyleFn(block
/*: BlockNode*/
) {
  var depth = block.getDepth();
  return depth > DRAFT_DEFAULT_MAX_DEPTH ? "".concat(DRAFT_DEFAULT_DEPTH_CLASS).concat(String(depth)) : "";
};

// @flow
/*:: import type { ElementRef } from "react";*/

/*:: import type { Editor, EditorState as EditorStateType } from "draft-js";*/

// Custom attribute to store Draft.js content in the HTML clipboard.
var FRAGMENT_ATTR = "data-draftjs-conductor-fragment";
var DRAFT_DECORATOR = '[data-contents="true"] [contenteditable="false"]'; // Checks whether the selection is inside a decorator or not.
// This is important to change the copy-cut behavior accordingly.

var isSelectionInDecorator = function isSelectionInDecorator(selection
/*: Selection*/
) {
  var anchorNode = selection.anchorNode,
      focusNode = selection.focusNode;

  if (!anchorNode || !focusNode) {
    return false;
  }

  var anchor = anchorNode instanceof Element ? anchorNode : anchorNode.parentElement;
  var focus = focusNode instanceof Element ? focusNode : focusNode.parentElement;
  var anchorDecorator = anchor && anchor.closest(DRAFT_DECORATOR);
  var focusDecorator = focus && focus.closest(DRAFT_DECORATOR);
  return anchorDecorator && focusDecorator && (anchorDecorator.contains(focusDecorator) || focusDecorator.contains(anchorDecorator));
}; // Get clipboard content from the selection like Draft.js would.


var getSelectedContent = function getSelectedContent(editorState
/*: EditorStateType*/
, editorRoot
/*: HTMLElement*/
) {
  var _getDraftEditorSelect = getDraftEditorSelection__default['default'](editorState, editorRoot),
      selectionState = _getDraftEditorSelect.selectionState;

  var fragment = getContentStateFragment__default['default'](editorState.getCurrentContent(), selectionState); // If the selection contains no content (according to Draft.js), use the default browser behavior.
  // This happens when selecting text that's within contenteditable=false blocks in Draft.js.
  // See https://github.com/thibaudcolas/draftjs-conductor/issues/12.

  var isEmpty = fragment.every(function (block) {
    return block.getText().length === 0;
  });
  return isEmpty ? null : fragment;
}; // Overrides the default copy/cut behavior, adding the serialised Draft.js content to the clipboard data.
// See also https://github.com/basecamp/trix/blob/62145978f352b8d971cf009882ba06ca91a16292/src/trix/controllers/input_controller.coffee#L415-L422
// We serialise the editor content within HTML, not as a separate mime type, because Draft.js only allows access
// to HTML in its paste event handler.


var draftEditorCopyCutListener = function draftEditorCopyCutListener(ref
/*: ElementRef<Editor>*/
, e
/*: SyntheticClipboardEvent<>*/
) {
  var selection = window.getSelection(); // Completely skip event handling if clipboardData is not supported (IE11 is out).
  // Also skip if there is no selection ranges.
  // Or if the selection is fully within a decorator.

  if (!e.clipboardData || selection.rangeCount === 0 || isSelectionInDecorator(selection)) {
    return;
  }

  var fragment = getSelectedContent(ref._latestEditorState, ref.editor); // Override the default behavior if there is selected content.

  if (fragment) {
    var content = draftJs.ContentState.createFromBlockArray(fragment.toArray());
    var serialisedContent = JSON.stringify(draftJs.convertToRaw(content)); // Create a temporary element to store the selectionâ€™s HTML.
    // See also Rangy's implementation: https://github.com/timdown/rangy/blob/1e55169d2e4d1d9458c2a87119addf47a8265276/src/core/domrange.js#L515-L520.

    var fragmentElt = document.createElement("div"); // Modern browsers only support a single range.

    fragmentElt.appendChild(selection.getRangeAt(0).cloneContents());
    fragmentElt.setAttribute(FRAGMENT_ATTR, serialisedContent); // We set the style property to replicate the browser's behavior of inline styles in rich text copy-paste.
    // In Draft.js, this is important for line breaks to be interpreted correctly when pasted into another word processor.
    // See https://github.com/facebook/draft-js/blob/a1f4593d8fa949954053e5d5840d33ce1d1082c6/src/component/base/DraftEditor.react.js#L328.

    fragmentElt.setAttribute("style", "white-space: pre-wrap;");
    e.clipboardData.setData("text/plain", selection.toString());
    e.clipboardData.setData("text/html", fragmentElt.outerHTML);
    e.preventDefault();
  }
};

var onDraftEditorCopy = function onDraftEditorCopy(editor
/*: Editor*/
, e
/*: SyntheticClipboardEvent<>*/
) {
  draftEditorCopyCutListener(editor, e);
  editOnCopy__default['default'](editor, e);
};
var onDraftEditorCut = function onDraftEditorCut(editor
/*: Editor*/
, e
/*: SyntheticClipboardEvent<>*/
) {
  draftEditorCopyCutListener(editor, e);
  editOnCut__default['default'](editor, e);
};
/**
 * Registers custom copy/cut event listeners on an editor.
 */

var registerCopySource = function registerCopySource(ref
/*: ElementRef<Editor>*/
) {
  var editorElt = ref.editor;
  var onCopyCut = draftEditorCopyCutListener.bind(null, ref);
  editorElt.addEventListener("copy", onCopyCut);
  editorElt.addEventListener("cut", onCopyCut);
  return {
    unregister() {
      editorElt.removeEventListener("copy", onCopyCut);
      editorElt.removeEventListener("cut", onCopyCut);
    }

  };
};
/**
 * Returns pasted content coming from Draft.js editors set up to serialise
 * their Draft.js content within the HTML.
 */

var getDraftEditorPastedContent = function getDraftEditorPastedContent(html
/*: ?string*/
) {
  // Plain-text pastes are better handled by Draft.js.
  if (html === "" || typeof html === "undefined" || html === null) {
    return null;
  }

  var doc = new DOMParser().parseFromString(html, "text/html");
  var fragmentElt = doc.querySelector("[".concat(FRAGMENT_ATTR, "]")); // Handle the paste if it comes from draftjs-conductor.

  if (fragmentElt) {
    var fragmentAttr = fragmentElt.getAttribute(FRAGMENT_ATTR);
    var rawContent;

    try {
      // If JSON parsing fails, leave paste handling to Draft.js.
      // There is no reason for this to happen, unless the clipboard was altered somehow.
      // $FlowFixMe
      rawContent = JSON.parse(fragmentAttr);
    } catch (error) {
      return null;
    }

    return draftJs.convertFromRaw(rawContent);
  }

  return null;
};
/**
 * Handles pastes coming from Draft.js editors set up to serialise
 * their Draft.js content within the HTML.
 * This SHOULD NOT be used for stripPastedStyles editor.
 */

var handleDraftEditorPastedText = function handleDraftEditorPastedText(html
/*: ?string*/
, editorState
/*: EditorStateType*/
) {
  var pastedContent = getDraftEditorPastedContent(html);

  if (pastedContent) {
    var fragment = pastedContent.getBlockMap();
    var content = draftJs.Modifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
    return draftJs.EditorState.push(editorState, content, "insert-fragment");
  }

  return false;
};

// @flow
/*:: import type { RawDraftContentState } from "draft-js/lib/RawDraftContentState";*/

/*:: import type { DraftDecoratorType } from "draft-js/lib/DraftDecoratorType";*/

var EMPTY_CONTENT_STATE = null;
/**
 * Creates a new EditorState from a RawDraftContentState, or an empty editor state by
 * passing `null`. Optionally takes a decorator.
 */

var createEditorStateFromRaw = function createEditorStateFromRaw(rawContentState
/*: ?RawDraftContentState*/
, decorator
/*:: ?: ?DraftDecoratorType*/
) {
  var editorState;

  if (rawContentState) {
    var contentState = draftJs.convertFromRaw(rawContentState);
    editorState = draftJs.EditorState.createWithContent(contentState, decorator);
  } else {
    editorState = draftJs.EditorState.createEmpty(decorator);
  }

  return editorState;
};
/**
 * Serialises the editorState using `convertToRaw`, but returns `null` if
 * the editor content is empty (no text, entities, styles).
 */

var serialiseEditorStateToRaw = function serialiseEditorStateToRaw(editorState
/*: EditorState*/
) {
  var contentState = editorState.getCurrentContent();
  var rawContentState = draftJs.convertToRaw(contentState);
  var isEmpty = rawContentState.blocks.every(function (block) {
    var isEmptyBlock = block.text.trim().length === 0 && (!block.entityRanges || block.entityRanges.length === 0) && (!block.inlineStyleRanges || block.inlineStyleRanges.length === 0);
    return isEmptyBlock;
  });
  return isEmpty ? EMPTY_CONTENT_STATE : rawContentState;
};

exports.DRAFT_DEFAULT_DEPTH_CLASS = DRAFT_DEFAULT_DEPTH_CLASS;
exports.DRAFT_DEFAULT_MAX_DEPTH = DRAFT_DEFAULT_MAX_DEPTH;
exports.ListNestingStyles = ListNestingStyles;
exports.blockDepthStyleFn = blockDepthStyleFn;
exports.createEditorStateFromRaw = createEditorStateFromRaw;
exports.generateListNestingStyles = generateListNestingStyles;
exports.getDraftEditorPastedContent = getDraftEditorPastedContent;
exports.handleDraftEditorPastedText = handleDraftEditorPastedText;
exports.onDraftEditorCopy = onDraftEditorCopy;
exports.onDraftEditorCut = onDraftEditorCut;
exports.registerCopySource = registerCopySource;
exports.serialiseEditorStateToRaw = serialiseEditorStateToRaw;
